<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WARFRONT - Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥</title>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1f16 0%, #2d3425 50%, #1a1f16 100%);
      font-family: 'Share Tech Mono', monospace;
      color: #c4d4a5;
      overflow-x: hidden;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)' opacity='0.03'/%3E%3C/svg%3E");
      pointer-events: none;
      z-index: 1000;
    }
    
    /* Ìó§Îçî */
    header {
      padding: 20px;
      text-align: center;
      border-bottom: 2px solid #4a5d23;
      background: rgba(0,0,0,0.3);
    }
    
    h1 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2.5rem;
      font-weight: bold;
      letter-spacing: 8px;
      text-transform: uppercase;
      text-shadow: 0 0 20px rgba(74, 93, 35, 0.8), 2px 2px 0 #2d3425;
      background: linear-gradient(180deg, #8fa85a 0%, #c4d4a5 50%, #8fa85a 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .subtitle {
      font-size: 0.9rem;
      letter-spacing: 4px;
      color: #6b7a4a;
      margin-top: 8px;
    }
    
    /* ÌôîÎ©¥ */
    .screen {
      display: none;
    }
    
    .screen.active {
      display: flex;
      flex-direction: column;
    }
    
    /* ==================== Î°úÍ∑∏Ïù∏ ÌôîÎ©¥ ==================== */
    #login-screen {
      align-items: center;
      justify-content: center;
      min-height: 80vh;
      padding: 20px;
    }
    
    .login-box {
      background: linear-gradient(145deg, rgba(45,52,37,0.9) 0%, rgba(26,31,22,0.95) 100%);
      border: 3px solid #4a5d23;
      border-radius: 4px;
      padding: 60px 50px;
      max-width: 450px;
      width: 100%;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5), inset 0 1px 0 rgba(196,212,165,0.1);
      position: relative;
    }
    
    .login-label {
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      background: #1a1f16;
      padding: 5px 20px;
      border: 2px solid #4a5d23;
      font-size: 0.75rem;
      letter-spacing: 3px;
      color: #8fa85a;
    }
    
    .login-title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      font-weight: bold;
      letter-spacing: 5px;
      margin-bottom: 40px;
      text-align: center;
    }
    
    .login-input {
      width: 100%;
      padding: 18px 20px;
      font-size: 1.1rem;
      background: rgba(0,0,0,0.4);
      border: 2px solid #3a4a23;
      border-radius: 2px;
      color: #c4d4a5;
      font-family: 'Share Tech Mono', monospace;
      letter-spacing: 3px;
      outline: none;
      transition: all 0.3s ease;
      margin-bottom: 30px;
    }
    
    .login-input:focus {
      border-color: #6b8a35;
      box-shadow: 0 0 15px rgba(107,138,53,0.3);
    }
    
    .login-input::placeholder {
      color: #5a6a4a;
    }
    
    .btn {
      width: 100%;
      padding: 18px;
      font-size: 1.1rem;
      font-weight: bold;
      letter-spacing: 4px;
      background: linear-gradient(180deg, #5a7a2a 0%, #4a5d23 100%);
      border: 2px solid #6b8a35;
      border-radius: 2px;
      color: #c4d4a5;
      font-family: 'Share Tech Mono', monospace;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
    }
    
    .btn:hover {
      background: linear-gradient(180deg, #6b8a35 0%, #5a7a2a 100%);
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    .btn:disabled {
      background: rgba(74,93,35,0.3);
      color: #6b7a4a;
      cursor: not-allowed;
      transform: none;
    }
    
    /* ==================== Î°úÎπÑ ÌôîÎ©¥ ==================== */
    #lobby-screen {
      height: calc(100vh - 100px);
    }
    
    .lobby-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    /* Î°úÎπÑ ÏÉÅÎã® - ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ */
    .lobby-header {
      background: rgba(0,0,0,0.4);
      border-bottom: 2px solid #3a4a23;
      padding: 20px 30px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .player-card {
      display: flex;
      align-items: center;
      gap: 20px;
    }
    
    .player-avatar {
      width: 70px;
      height: 70px;
      background: linear-gradient(135deg, #4a5d23 0%, #2d3425 100%);
      border: 3px solid #6b8a35;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
    }
    
    .player-info .label {
      font-size: 0.7rem;
      color: #6b7a4a;
      letter-spacing: 2px;
      margin-bottom: 4px;
    }
    
    .player-info .name {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.4rem;
      font-weight: bold;
      letter-spacing: 3px;
      color: #c4d4a5;
    }
    
    .player-stats {
      display: flex;
      gap: 20px;
      margin-top: 8px;
    }
    
    .stat-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.9rem;
    }
    
    .stat-item.wins {
      color: #8fa85a;
    }
    
    .stat-item.losses {
      color: #a07a7a;
    }
    
    .currency-display {
      display: flex;
      gap: 20px;
    }
    
    .currency-item {
      background: rgba(0,0,0,0.3);
      border: 2px solid #3a4a23;
      padding: 10px 20px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .currency-item .icon {
      font-size: 1.3rem;
    }
    
    .currency-item .amount {
      font-size: 1.1rem;
      font-weight: bold;
      color: #c4d4a5;
    }
    
    /* Î°úÎπÑ Î©îÏù∏ ÏòÅÏó≠ */
    .lobby-main {
      flex: 1;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      padding: 30px;
      overflow-y: auto;
    }
    
    /* ÌÉ≠ Ïª®ÌÖêÏ∏† */
    .tab-content {
      display: none;
      width: 100%;
    }
    
    .tab-content.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    
    /* Îß§Ïπ≠ ÌÉ≠ÏùÄ Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨ */
    #match-tab.active {
      justify-content: center;
      min-height: 100%;
    }
    
    /* ÏÉÅÏ†ê ÌÉ≠ÎèÑ Í∞ÄÏö¥Îç∞ Ï†ïÎ†¨ */
    #shop-tab.active {
      justify-content: center;
      min-height: 100%;
    }
    
    .coming-soon {
      font-size: 1.5rem;
      color: #6b7a4a;
      letter-spacing: 4px;
    }
    
    .coming-soon-icon {
      font-size: 4rem;
      margin-bottom: 20px;
      opacity: 0.5;
    }
    
    /* Îß§Ïπ≠ ÌÉ≠ */
    #match-tab .match-options {
      display: flex;
      gap: 30px;
    }
    
    .match-btn {
      width: 220px;
      padding: 50px 30px;
      background: linear-gradient(145deg, rgba(74,93,35,0.8) 0%, rgba(45,52,37,0.9) 100%);
      border: 3px solid #6b8a35;
      border-radius: 8px;
      color: #c4d4a5;
      font-family: 'Share Tech Mono', monospace;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
    }
    
    .match-btn:hover {
      background: linear-gradient(145deg, rgba(107,138,53,0.8) 0%, rgba(74,93,35,0.9) 100%);
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0,0,0,0.4);
    }
    
    .match-btn.disabled {
      background: linear-gradient(145deg, rgba(45,52,37,0.6) 0%, rgba(26,31,22,0.7) 100%);
      border-color: #3a4a23;
      color: #6b7a4a;
      cursor: not-allowed;
    }
    
    .match-btn.disabled:hover {
      transform: none;
      box-shadow: none;
    }
    
    .match-btn .icon {
      font-size: 3.5rem;
      margin-bottom: 20px;
    }
    
    .match-btn .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.3rem;
      font-weight: bold;
      letter-spacing: 3px;
      margin-bottom: 10px;
    }
    
    .match-btn .desc {
      font-size: 0.8rem;
      color: #8fa85a;
    }
    
    .match-btn.disabled .desc {
      color: #5a6a4a;
    }
    
    /* Ïú†Îãõ ÌÉ≠ */
    #unit-tab {
      text-align: center;
      padding-bottom: 20px;
    }
    
    /* ÌïòÎã® ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò */
    .lobby-nav {
      background: rgba(0,0,0,0.5);
      border-top: 2px solid #4a5d23;
      display: flex;
      justify-content: center;
    }
    
    .nav-btn {
      flex: 1;
      max-width: 200px;
      padding: 20px;
      background: transparent;
      border: none;
      border-right: 1px solid #3a4a23;
      color: #6b7a4a;
      font-family: 'Share Tech Mono', monospace;
      font-size: 1rem;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    
    .nav-btn:last-child {
      border-right: none;
    }
    
    .nav-btn:hover {
      background: rgba(74,93,35,0.2);
      color: #8fa85a;
    }
    
    .nav-btn.active {
      background: rgba(74,93,35,0.4);
      color: #c4d4a5;
      border-bottom: 3px solid #6b8a35;
    }
    
    .nav-btn .nav-icon {
      font-size: 1.5rem;
    }
    
    .nav-btn .nav-label {
      font-size: 0.85rem;
    }
    
    /* ==================== Îß§Ïπ≠ ÌôîÎ©¥ ==================== */
    #matching-screen {
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 100px);
      padding: 40px 20px;
    }
    
    .matching-box {
      background: linear-gradient(145deg, rgba(45,52,37,0.9) 0%, rgba(26,31,22,0.95) 100%);
      border: 3px solid #4a5d23;
      border-radius: 8px;
      padding: 60px;
      text-align: center;
      max-width: 500px;
      width: 100%;
    }
    
    .spinner {
      width: 120px;
      height: 120px;
      margin: 0 auto 30px;
      border: 4px solid #3a4a23;
      border-top: 4px solid #6b8a35;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    
    .matching-text {
      font-size: 1.5rem;
      font-weight: bold;
      letter-spacing: 4px;
      margin-bottom: 10px;
    }
    
    .matching-timer {
      font-size: 2rem;
      color: #6b8a35;
      font-weight: bold;
      margin-bottom: 20px;
    }
    
    .matching-desc {
      font-size: 0.85rem;
      color: #6b7a4a;
      margin-bottom: 30px;
    }
    
    .btn-cancel {
      padding: 15px 40px;
      background: transparent;
      border: 2px solid #6b7a4a;
      border-radius: 4px;
      color: #8fa85a;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.9rem;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .btn-cancel:hover {
      border-color: #8fa85a;
      color: #c4d4a5;
    }
    
    .match-found {
      display: none;
    }
    
    .match-found.active {
      display: block;
    }
    
    .match-found .icon {
      font-size: 4rem;
      margin-bottom: 20px;
      animation: pulse 0.5s ease-in-out infinite;
    }
    
    .match-found .text {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.8rem;
      font-weight: bold;
      letter-spacing: 4px;
      color: #8fa85a;
    }
    
    .match-found .subtext {
      font-size: 1rem;
      color: #6b7a4a;
      margin-top: 15px;
    }
    
    /* ==================== Í≤åÏûÑ ÌôîÎ©¥ ==================== */
    #game-screen {
      flex-direction: row;
      height: calc(100vh - 100px);
    }
    
    .left-panel {
      width: 280px;
      background: rgba(0,0,0,0.3);
      border-right: 2px solid #3a4a23;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .info-box {
      background: rgba(74,93,35,0.3);
      border: 2px solid #4a5d23;
      padding: 15px;
      border-radius: 4px;
    }
    
    .info-box.enemy {
      background: rgba(106,42,42,0.3);
      border-color: #5a2a2a;
    }
    
    .info-box .label {
      font-size: 0.75rem;
      color: #6b7a4a;
      letter-spacing: 2px;
    }
    
    .info-box.enemy .label {
      color: #7a4a4a;
    }
    
    .info-box .name {
      font-size: 1.2rem;
      font-weight: bold;
      color: #8fa85a;
    }
    
    .info-box.enemy .name {
      color: #c49a9a;
    }
    
    .info-box .stats {
      display: flex;
      gap: 15px;
      margin-top: 10px;
      font-size: 0.85rem;
    }
    
    .info-box.enemy .stats {
      color: #a07a7a;
    }
    
    .turn-box {
      background: rgba(74,93,35,0.5);
      border: 3px solid #6b8a35;
      padding: 20px;
      border-radius: 4px;
      text-align: center;
    }
    
    .turn-box.enemy-turn {
      background: rgba(106,42,42,0.3);
      border-color: #5a2a2a;
    }
    
    .turn-box .turn-number {
      font-size: 0.75rem;
      letter-spacing: 2px;
      margin-bottom: 5px;
    }
    
    .turn-box .timer {
      font-size: 2rem;
      font-weight: bold;
      color: #c4d4a5;
    }
    
    .turn-box.enemy-turn .timer {
      color: #c49a9a;
    }
    
    .turn-box .turn-text {
      font-size: 0.9rem;
      margin-top: 10px;
      color: #8fa85a;
    }
    
    .turn-box.enemy-turn .turn-text {
      color: #a07a7a;
    }
    
    .btn-end-turn {
      padding: 15px;
      background: linear-gradient(180deg, #5a7a2a 0%, #4a5d23 100%);
      border: 2px solid #6b8a35;
      border-radius: 4px;
      color: #c4d4a5;
      font-family: 'Share Tech Mono', monospace;
      font-weight: bold;
      letter-spacing: 3px;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .btn-end-turn:hover {
      background: linear-gradient(180deg, #6b8a35 0%, #5a7a2a 100%);
    }
    
    .btn-end-turn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .btn-surrender {
      padding: 12px;
      background: transparent;
      border: 2px solid #5a2a2a;
      border-radius: 4px;
      color: #a07a7a;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.85rem;
      letter-spacing: 2px;
      cursor: pointer;
      margin-top: auto;
    }
    
    .btn-surrender:hover {
      border-color: #8a3535;
      color: #c49a9a;
    }
    
    /* Îßµ ÏòÅÏó≠ */
    .map-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 20px;
      min-width: 0;
    }
    
    .territory-label {
      padding: 8px 20px;
      border-radius: 4px;
      font-size: 0.85rem;
      letter-spacing: 2px;
    }
    
    .territory-label.enemy {
      background: rgba(106,42,42,0.5);
      border: 2px solid #5a2a2a;
      color: #c49a9a;
      margin-bottom: 10px;
    }
    
    .territory-label.player {
      background: rgba(74,93,35,0.5);
      border: 2px solid #4a5d23;
      color: #8fa85a;
      margin-top: 10px;
    }
    
    /* Îßµ Î∑∞ ÌÉ≠ */
    .map-view-tabs {
      display: flex;
      gap: 10px;
    }
    
    .map-view-tab {
      padding: 8px 20px;
      background: rgba(45,52,37,0.6);
      border: 2px solid #3a4a23;
      border-radius: 4px;
      color: #8fa85a;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.9rem;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .map-view-tab:hover {
      border-color: #6b8a35;
      background: rgba(74,93,35,0.4);
    }
    
    .map-view-tab.active {
      background: linear-gradient(180deg, #5a7a2a 0%, #4a5d23 100%);
      border-color: #6b8a35;
      color: #c4d4a5;
    }
    
    .map-view-tab.air-tab.active {
      background: linear-gradient(180deg, #2a5a7a 0%, #1a4a6a 100%);
      border-color: #3a7a9a;
    }
    
    /* Îßµ Ïä§ÌÅ¨Î°§ ÏòÅÏó≠ */
    .map-scroll-area {
      flex: 1;
      overflow: scroll;
      background: rgba(0,0,0,0.2);
      border: 2px solid #3a4a23;
      border-radius: 4px;
      padding: 10px;
      position: relative;
    }
    
    .map-grid {
      display: inline-block;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 4px;
      min-width: 1300px;
    }
    
    .map-row {
      display: flex;
      gap: 2px;
      margin-bottom: 2px;
      white-space: nowrap;
    }
    
    :root {
      --tile-size: 28px;
      --tile-font-size: 0.75rem;
    }
    
    .tile {
      width: var(--tile-size);
      height: var(--tile-size);
      min-width: var(--tile-size);
      min-height: var(--tile-size);
      flex-shrink: 0;
      background: rgba(45,52,37,0.6);
      border: 1px solid #3a4a23;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s ease;
      font-size: var(--tile-font-size);
      position: relative;
    }
    
    .tile:hover:not(.disabled) {
      border-color: #6b8a35;
      transform: scale(1.08);
      z-index: 10;
    }
    
    .tile.selected {
      border-color: #c4d4a5;
      box-shadow: 0 0 10px rgba(196,212,165,0.5);
      transform: scale(1.1);
      z-index: 11;
    }
    
    /* Î∞îÎã§ ÌÉÄÏùº */
    .tile.sea {
      background: linear-gradient(180deg, #1a3a5a 0%, #0a2a4a 100%);
      border-color: #2a4a6a;
    }
    
    .tile.sea:hover:not(.disabled) {
      border-color: #3a6a8a;
    }
    
    /* Îßµ Ïª®Ìä∏Î°§ Î∞î */
    .map-controls-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    
    /* Ï§å Ïª®Ìä∏Î°§ (Ïù∏ÎùºÏù∏) */
    .zoom-controls-inline {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(0,0,0,0.4);
      padding: 5px 10px;
      border-radius: 4px;
      border: 1px solid #3a4a23;
    }
    
    .zoom-btn-small {
      width: 28px;
      height: 28px;
      background: linear-gradient(180deg, #4a5d23 0%, #3a4a1a 100%);
      border: 1px solid #6b8a35;
      border-radius: 4px;
      color: #c4d4a5;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .zoom-btn-small:hover {
      background: linear-gradient(180deg, #5a7a2a 0%, #4a5d23 100%);
    }
    
    .zoom-level-small {
      font-size: 0.75rem;
      color: #8fa85a;
      min-width: 40px;
      text-align: center;
    }
    
    /* Îπ†Î•∏ Ïù¥Îèô Ìå®ÎÑê */
    .quick-nav-panel {
      background: rgba(0,0,0,0.4);
      border: 2px solid #4a5d23;
      border-radius: 4px;
      margin-bottom: 15px;
      padding: 8px;
    }
    
    .quick-nav-header {
      font-size: 0.7rem;
      color: #8fa85a;
      text-align: center;
      margin-bottom: 8px;
    }
    
    .quick-nav-grid {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .quick-nav-row {
      display: flex;
      gap: 5px;
    }
    
    .area-btn {
      flex: 1;
      padding: 8px 4px;
      border-radius: 4px;
      cursor: pointer;
      border: 2px solid;
      text-align: center;
      font-size: 0.65rem;
    }
    
    .area-btn.enemy {
      background: rgba(90,42,42,0.5);
      border-color: #6a3a3a;
      color: #c49a9a;
    }
    
    .area-btn.enemy:hover {
      background: rgba(120,52,52,0.7);
    }
    
    .area-btn.player {
      background: rgba(74,93,35,0.5);
      border-color: #5a7a2a;
      color: #c4d4a5;
    }
    
    .area-btn.player:hover {
      background: rgba(94,113,55,0.7);
    }
    
    .area-btn.sea {
      background: rgba(26,58,90,0.5);
      border-color: #2a5a8a;
      color: #9ac4e4;
    }
    
    .area-btn.sea:hover {
      background: rgba(36,78,120,0.7);
    }
    
    /* ÌÉÄÏùº ÎÇ¥ ÌëúÏãúÍ∏∞ (ÏûëÏùÄ ÌÅ¨Í∏∞Ïóê ÎßûÍ≤å Ï°∞Ï†ï) */
    .map-timer-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(180deg, #3a4a23 0%, #2d3425 100%);
      border: 2px solid #4a5d23;
      border-bottom: none;
      border-radius: 4px 4px 0 0;
      padding: 8px 15px;
    }
    
    .map-timer-bar .turn-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .map-timer-bar .turn-label {
      font-size: 0.9rem;
      color: #c4d4a5;
      font-weight: bold;
    }
    
    .map-timer-bar .turn-text {
      font-size: 0.8rem;
      color: #8fa85a;
    }
    
    .map-timer-bar .timer {
      font-size: 1.2rem;
      font-weight: bold;
      color: #ffd700;
      background: rgba(0,0,0,0.4);
      padding: 4px 12px;
      border-radius: 4px;
    }
    
    .map-timer-bar.enemy-turn {
      background: linear-gradient(180deg, #5a2a2a 0%, #3d2525 100%);
      border-color: #6a3a3a;
    }
    
    .map-timer-bar.enemy-turn .timer {
      color: #ff9999;
    }
    
    .map-timer-bar.enemy-turn .turn-text {
      color: #c49a9a;
    }
    
    /* ÌÉÄÏùº ÎÇ¥ ÌëúÏãúÍ∏∞ (ÏûëÏùÄ ÌÅ¨Í∏∞Ïóê ÎßûÍ≤å Ï°∞Ï†ï) */
    .unit-indicator {
      position: absolute;
      bottom: 1px;
      right: 1px;
      font-size: 0.5rem;
      background: rgba(0,0,0,0.7);
      padding: 1px 2px;
      border-radius: 2px;
      color: #ffd700;
    }
    
    .base-hp-indicator, .building-hp-indicator {
      position: absolute;
      bottom: 1px;
      right: 1px;
      font-size: 0.45rem;
      background: rgba(0,0,0,0.7);
      padding: 1px 2px;
      border-radius: 2px;
      color: #8fa85a;
    }
    
    .building-icon-small {
      position: absolute;
      top: 1px;
      left: 1px;
      font-size: 0.5rem;
    }
    
    .building-income-indicator {
      position: absolute;
      top: 1px;
      right: 1px;
      font-size: 0.4rem;
      background: rgba(0,0,0,0.7);
      padding: 1px 2px;
      border-radius: 2px;
      color: #ffd700;
    }
    
    /* Íµ∞Ìï≠ ÌÉÄÏùº */
    .tile.harbor-player {
      background: linear-gradient(145deg, #3a5a6a 0%, #2a4a5a 100%);
      border-color: #4a7a8a;
    }
    
    .tile.harbor-enemy {
      background: linear-gradient(145deg, #5a3a3a 0%, #4a2a2a 100%);
      border-color: #7a4a4a;
    }
    
    .tile.destroyed-harbor {
      background: linear-gradient(145deg, #3a3a3a 0%, #2a2a2a 100%);
      border-color: #5a5a5a;
    }
    
    .tile.main-base-player {
      background: linear-gradient(145deg, #4a6a2a 0%, #3a5a1a 100%);
      border-color: #6b8a35;
    }
    
    .tile.sub-base-player {
      background: linear-gradient(145deg, #3a5a1a 0%, #2a4a0a 100%);
      border-color: #5a7a25;
    }
    
    .tile.main-base-enemy {
      background: linear-gradient(145deg, #6a2a2a 0%, #5a1a1a 100%);
      border-color: #8a3535;
    }
    
    .tile.sub-base-enemy {
      background: linear-gradient(145deg, #5a1a1a 0%, #4a0a0a 100%);
      border-color: #7a2525;
    }
    
    .tile.river {
      background: linear-gradient(180deg, #1a3a5a 0%, #0a2a4a 100%);
      border-color: #2a4a6a;
      cursor: not-allowed;
    }
    
    .tile.river.buildable {
      cursor: pointer;
      border-color: #8a7a35;
      animation: bridgePulse 1.5s ease-in-out infinite;
    }
    
    @keyframes bridgePulse {
      0%, 100% { box-shadow: 0 0 5px rgba(138, 122, 53, 0.5); }
      50% { box-shadow: 0 0 15px rgba(138, 122, 53, 0.8); }
    }
    
    .tile.fog {
      background: linear-gradient(145deg, #2a3020 0%, #1a1f16 100%);
      cursor: default;
      opacity: 0.7;
    }
    
    .tile.fog.scourable {
      cursor: pointer;
      opacity: 0.9;
      border-color: #5a8a5a;
      animation: scoutPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes scoutPulse {
      0%, 100% { box-shadow: 0 0 5px rgba(90, 138, 90, 0.5); }
      50% { box-shadow: 0 0 15px rgba(90, 138, 90, 0.8); }
    }
    
    .tile.farmable {
      border-color: #9a7a35;
      animation: farmPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes farmPulse {
      0%, 100% { box-shadow: 0 0 5px rgba(154, 122, 53, 0.5); }
      50% { box-shadow: 0 0 12px rgba(154, 122, 53, 0.7); }
    }
    
    .tile.military-buildable {
      border-color: #9a4535;
      animation: militaryPulse 1.5s ease-in-out infinite;
    }
    
    @keyframes militaryPulse {
      0%, 100% { box-shadow: 0 0 5px rgba(154, 69, 53, 0.5); }
      50% { box-shadow: 0 0 12px rgba(154, 69, 53, 0.7); }
    }
    
    .tile.captured-player {
      background: linear-gradient(135deg, rgba(60, 100, 180, 0.4), rgba(40, 80, 150, 0.3)) !important;
      border: 2px solid rgba(80, 140, 220, 0.8) !important;
    }
    
    .tile.captured-player::after {
      content: 'üö©';
      font-size: 0.6em;
      position: absolute;
      top: 1px;
      right: 1px;
      opacity: 0.7;
    }
    
    .tile.captured-enemy {
      background: linear-gradient(135deg, rgba(180, 60, 60, 0.4), rgba(150, 40, 40, 0.3)) !important;
      border: 2px solid rgba(220, 80, 80, 0.8) !important;
    }
    
    .tile.fired {
      opacity: 0.6;
    }
    
    .tile.disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }
    
    /* Ïï°ÏÖò Î©îÎâ¥ */
    .action-menu {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, rgba(45,52,37,0.98) 0%, rgba(26,31,22,0.98) 100%);
      border: 3px solid #4a5d23;
      border-radius: 8px;
      padding: 20px;
      z-index: 100;
      min-width: 600px;
      max-width: 800px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    }
    
    .action-menu.active {
      display: block;
    }
    
    .action-menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #3a4a23;
    }
    
    .action-menu-header .coords {
      letter-spacing: 2px;
      font-size: 0.9rem;
      color: #8fa85a;
    }
    
    .action-menu-header .close {
      background: none;
      border: none;
      color: #6b7a4a;
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .action-menu-header .close:hover {
      color: #c4d4a5;
    }
    
    .action-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }
    
    .action-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 5px;
      padding: 12px 8px;
      background: rgba(74,93,35,0.3);
      border: 2px solid #3a4a23;
      border-radius: 4px;
      color: #c4d4a5;
      font-family: 'Share Tech Mono', monospace;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      min-height: 70px;
    }
    
    .action-btn:hover {
      background: rgba(107,138,53,0.4);
      border-color: #6b8a35;
    }
    
    .action-btn .icon {
      font-size: 1.3rem;
    }
    
    .action-btn .info .title {
      font-weight: bold;
      font-size: 0.75rem;
      letter-spacing: 1px;
    }
    
    .action-btn .info .desc {
      font-size: 0.65rem;
      color: #6b7a4a;
      display: none;
    }
    
    /* ÏóÖÍ∑∏Î†àÏù¥Îìú Î≤ÑÌäºÏùÄ ÏÑ§Î™Ö ÌëúÏãú */
    #upgrade-btn .info .desc {
      display: block;
      color: #ffd700;
    }
    
    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(50,50,50,0.3);
      border-color: #333;
    }
    
    .action-btn:disabled:hover {
      background: rgba(50,50,50,0.3);
      border-color: #333;
    }
    
    .action-btn.disabled-visual {
      opacity: 0.5;
      background: rgba(50,50,50,0.3);
      border-color: #555;
    }
    
    .action-btn.disabled-visual:hover {
      background: rgba(70,70,70,0.3);
      border-color: #666;
    }
    
    /* Ïò§Î•∏Ï™Ω Ìå®ÎÑê */
    .right-panel {
      width: 280px;
      background: rgba(0,0,0,0.3);
      border-left: 2px solid #3a4a23;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .log-header {
      font-size: 0.8rem;
      letter-spacing: 2px;
      color: #6b7a4a;
      margin-bottom: 8px;
      padding-bottom: 8px;
      border-bottom: 1px solid #3a4a23;
    }
    
    .log-container {
      height: 200px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    /* ÏóÖÍ∑∏Î†àÏù¥Îìú Ìå®ÎÑê */
    /* ÌÉÄÏùº Ï†ïÎ≥¥ Ìå®ÎÑê */
    .tile-info-panel {
      background: rgba(45,52,37,0.5);
      border: 2px solid #4a5d23;
      border-radius: 8px;
      padding: 10px;
    }
    
    .tile-info-panel .panel-header {
      font-size: 0.8rem;
      letter-spacing: 2px;
      color: #8fa85a;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #3a4a23;
    }
    
    .tile-info-panel .info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      font-size: 0.75rem;
      border-bottom: 1px solid rgba(58,74,35,0.5);
    }
    
    .tile-info-panel .info-row:last-child {
      border-bottom: none;
    }
    
    .tile-info-panel .info-label {
      color: #6b7a4a;
    }
    
    .tile-info-panel .info-value {
      color: #c4d4a5;
      font-weight: bold;
    }
    
    .tile-info-panel .info-value.gold {
      color: #ffd700;
    }
    
    .tile-info-panel .info-value.red {
      color: #f55;
    }
    
    .tile-info-panel .info-value.green {
      color: #5f5;
    }
    
    .tile-info-panel .tile-icon {
      font-size: 1.5rem;
      text-align: center;
      margin-bottom: 8px;
    }
    
    .tile-info-panel .no-selection {
      text-align: center;
      color: #6b7a4a;
      font-size: 0.8rem;
      padding: 15px;
    }
    
    .log-entry {
      padding: 8px 12px;
      background: rgba(45,52,37,0.5);
      border-radius: 4px;
      font-size: 0.8rem;
      border-left: 3px solid #4a5d23;
    }
    
    .log-entry.enemy {
      background: rgba(106,42,42,0.3);
      border-left-color: #8a3535;
    }
    
    .log-entry.action {
      background: rgba(74,93,35,0.3);
      border-left-color: #6b8a35;
    }
    
    .log-entry .time {
      color: #4a5a3a;
      margin-right: 8px;
    }
    
    /* Ïò§Î≤ÑÎ†àÏù¥ */
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 99;
    }
    
    .overlay.active {
      display: block;
    }
    
    /* ÏûêÏõê ÌëúÏãú (Í≤åÏûÑ ÎÇ¥) */
    .game-resources {
      background: rgba(0,0,0,0.4);
      border: 2px solid #4a5d23;
      padding: 10px 15px;
      border-radius: 4px;
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 15px;
    }
    
    .game-resources .resource-icon {
      font-size: 1.2rem;
    }
    
    .game-resources .resource-amount {
      font-size: 1.3rem;
      font-weight: bold;
      color: #ffd700;
    }
    
    .game-resources .resource-label {
      font-size: 0.7rem;
      color: #8fa85a;
    }
    
    /* Í±¥Î¨º ÌÉÄÏùº */
    .tile.building-barracks {
      background: linear-gradient(145deg, #5a4a2a 0%, #4a3a1a 100%);
      border-color: #8a7a35;
    }
    
    .tile.building-bridge {
      background: linear-gradient(145deg, #3a4a5a 0%, #2a3a4a 100%);
      border-color: #5a7a8a;
    }
    
    .tile.building-farm {
      background: linear-gradient(145deg, #4a5a2a 0%, #3a4a1a 100%);
      border-color: #7a9a35;
    }
    
    .tile.building-greenhouse {
      background: linear-gradient(145deg, #3a5a4a 0%, #2a4a3a 100%);
      border-color: #5a9a7a;
    }
    
    .tile.building-mortar {
      background: linear-gradient(145deg, #5a4a3a 0%, #4a3a2a 100%);
      border-color: #8a6a4a;
    }
    
    .tile.building-mortar.fired {
      opacity: 0.6;
    }
    
    .tile.building-runway {
      background: linear-gradient(145deg, #4a4a5a 0%, #3a3a4a 100%);
      border-color: #6a6a8a;
    }
    
    .tile.building-runway.produced {
      opacity: 0.6;
    }
    
    .tile.building-arms_factory {
      background: linear-gradient(145deg, #5a5a4a 0%, #4a4a3a 100%);
      border-color: #8a8a5a;
    }
    
    .tile.building-arms_factory.produced {
      opacity: 0.6;
    }
    
    .tile.building-missile_silo {
      background: linear-gradient(145deg, #4a3a5a 0%, #3a2a4a 100%);
      border-color: #7a5a9a;
    }
    
    .tile.building-missile_silo.fired {
      opacity: 0.6;
    }
    
    /* Ïú†ÎãõÏù¥ ÏûàÎäî ÌÉÄÏùº */
    .tile.has-unit {
      position: relative;
    }
    
    .tile.has-unit.unit-moved {
      opacity: 0.6;
    }
    
    .tile.has-unit.unit-moved::after {
      content: '‚úì';
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 0.6rem;
      color: #8fa85a;
    }
    
    .tile .unit-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      background: rgba(0,0,0,0.7);
      padding: 1px 4px;
      border-radius: 2px;
      font-size: 0.6rem;
      color: #c4d4a5;
    }
    
    .tile .base-hp-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.5rem;
      background: rgba(0,0,0,0.7);
      padding: 1px 3px;
      border-radius: 2px;
      color: #7f7;
    }
    
    /* Ïú†ÎãõÏù¥ ÏûàÏùÑ Îïå HP Î∞îÎäî Ï¢åÌïòÎã®ÏúºÎ°ú */
    .tile.has-unit .base-hp-indicator,
    .tile.has-unit .building-hp-indicator {
      right: auto;
      left: 2px;
    }
    
    .tile .building-hp-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 0.5rem;
      background: rgba(0,0,0,0.7);
      padding: 1px 3px;
      border-radius: 2px;
      color: #ff7;
    }
    
    .tile .building-income-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 0.5rem;
      background: rgba(0,100,0,0.8);
      padding: 1px 3px;
      border-radius: 2px;
      color: #7f7;
    }
    
    .tile .building-level-indicator {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 0.5rem;
      background: rgba(200,150,0,0.9);
      padding: 1px 3px;
      border-radius: 2px;
      color: #fff;
      font-weight: bold;
    }
    
    .tile .building-icon-small {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 0.55rem;
      background: rgba(0,0,0,0.6);
      padding: 1px 3px;
      border-radius: 2px;
    }
    
    .tile.destroyed {
      opacity: 0.5;
    }
    
    /* Ïú†Îãõ Ïπ¥Îìú Ïä§ÌÉÄÏùº */
    .unit-card {
      background: linear-gradient(145deg, #3a4a2a 0%, #2a3a1a 100%);
      border: 2px solid #5a7a25;
      border-radius: 8px;
      padding: 12px;
      width: 140px;
      text-align: center;
      box-shadow: 0 4px 15px rgba(0,0,0,0.4);
      position: relative;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .unit-card:hover {
      border-color: #8fa85a;
      transform: translateY(-2px);
    }
    
    .unit-card.selected {
      border-color: #4a9;
      background: linear-gradient(145deg, #2a5a4a 0%, #1a4a3a 100%);
      box-shadow: 0 0 15px rgba(68, 170, 153, 0.5);
    }
    
    .unit-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #6b8a35, #8fa85a, #6b8a35);
    }
    
    .unit-card.enemy {
      background: linear-gradient(145deg, #4a2a2a 0%, #3a1a1a 100%);
      border-color: #7a2525;
    }
    
    .unit-card.enemy::before {
      background: linear-gradient(90deg, #8a3535, #c49a9a, #8a3535);
    }
    
    .unit-card .unit-icon {
      font-size: 2rem;
      margin-bottom: 8px;
    }
    
    .unit-card .unit-name {
      font-size: 0.85rem;
      font-weight: bold;
      letter-spacing: 1px;
      margin-bottom: 8px;
      color: #c4d4a5;
    }
    
    .unit-card .unit-count {
      background: rgba(0,0,0,0.3);
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 1.1rem;
      font-weight: bold;
      color: #ffd700;
      margin-bottom: 8px;
    }
    
    .unit-card .unit-stats {
      display: flex;
      justify-content: space-around;
      font-size: 0.75rem;
      color: #8fa85a;
    }
    
    .unit-card .unit-stats .stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    
    .unit-card .unit-stats .stat-icon {
      font-size: 0.9rem;
    }
    
    /* Í±¥Ï∂ï/ÏßïÎ≥ë Î™®Îã¨ */
    .modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, rgba(45,52,37,0.98) 0%, rgba(26,31,22,0.98) 100%);
      border: 3px solid #4a5d23;
      border-radius: 8px;
      padding: 25px;
      z-index: 101;
      min-width: 650px;
      max-width: 850px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    }
    
    .modal.active {
      display: block;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 2px solid #3a4a23;
    }
    
    .modal-header .title {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2rem;
      letter-spacing: 2px;
      color: #c4d4a5;
    }
    
    .modal-header .close {
      background: none;
      border: none;
      color: #6b7a4a;
      font-size: 1.5rem;
      cursor: pointer;
    }
    
    .modal-header .close:hover {
      color: #c4d4a5;
    }
    
    .modal-content {
      margin-bottom: 15px;
    }
    
    /* Í±¥Ï∂ï ÏòµÏÖò - Í∑∏Î¶¨Îìú */
    .build-options {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    
    .build-option {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 15px 10px;
      background: rgba(74,93,35,0.3);
      border: 2px solid #3a4a23;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      min-height: 100px;
    }
    
    .build-option:hover {
      background: rgba(107,138,53,0.4);
      border-color: #6b8a35;
    }
    
    .build-option.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .build-option .option-icon {
      font-size: 1.8rem;
    }
    
    .build-option .option-info {
      flex: 1;
    }
    
    .build-option .option-name {
      font-weight: bold;
      font-size: 0.85rem;
      letter-spacing: 1px;
      margin-bottom: 3px;
    }
    
    .build-option .option-desc {
      font-size: 0.7rem;
      color: #6b7a4a;
      line-height: 1.2;
    }
    
    .build-option .option-cost {
      font-size: 0.8rem;
      color: #ffd700;
      font-weight: bold;
      margin-top: 5px;
    }
    
    /* ÏßïÎ≥ë Ïª®Ìä∏Î°§ */
    .recruit-control {
      text-align: center;
      padding: 20px;
    }
    
    .recruit-control .unit-preview {
      margin-bottom: 20px;
    }
    
    .recruit-control .quantity-control {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .recruit-control .qty-btn {
      width: 40px;
      height: 40px;
      background: linear-gradient(180deg, #5a7a2a 0%, #4a5d23 100%);
      border: 2px solid #6b8a35;
      border-radius: 4px;
      color: #c4d4a5;
      font-size: 1.5rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .recruit-control .qty-btn:hover {
      background: linear-gradient(180deg, #6b8a35 0%, #5a7a2a 100%);
    }
    
    .recruit-control .qty-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .recruit-control .qty-display {
      font-size: 1.5rem;
      font-weight: bold;
      min-width: 80px;
      color: #c4d4a5;
    }
    
    .recruit-control .total-cost {
      font-size: 1.1rem;
      color: #ffd700;
      margin-bottom: 20px;
    }
    
    .recruit-control .recruit-btn {
      padding: 12px 30px;
      background: linear-gradient(180deg, #5a7a2a 0%, #4a5d23 100%);
      border: 2px solid #6b8a35;
      border-radius: 4px;
      color: #c4d4a5;
      font-family: 'Share Tech Mono', monospace;
      font-weight: bold;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .recruit-control .recruit-btn:hover {
      background: linear-gradient(180deg, #6b8a35 0%, #5a7a2a 100%);
    }
    
    .recruit-control .recruit-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .max-buy-btn {
      padding: 8px 20px;
      background: linear-gradient(180deg, #7a5a2a 0%, #5d4a23 100%);
      border: 2px solid #8a6a35;
      border-radius: 4px;
      color: #d4c4a5;
      font-family: 'Share Tech Mono', monospace;
      font-size: 0.85rem;
      cursor: pointer;
      margin-bottom: 15px;
      transition: all 0.2s ease;
    }
    
    .max-buy-btn:hover {
      background: linear-gradient(180deg, #8a6a35 0%, #7a5a2a 100%);
    }
    
    /* Î°úÎπÑ Ïú†Îãõ ÌÉ≠ Ïä§ÌÉÄÏùº */
    .unit-tab-container {
      width: 100%;
      max-width: 800px;
    }
    
    .unit-tab-header {
      text-align: center;
      margin-bottom: 30px;
    }
    
    .unit-tab-header h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      letter-spacing: 3px;
      color: #c4d4a5;
      margin-bottom: 10px;
    }
    
    .unit-tab-desc {
      font-size: 0.85rem;
      color: #6b7a4a;
    }
    
    .unit-list {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }
    
    .unit-card-large {
      background: linear-gradient(145deg, #3a4a2a 0%, #2a3a1a 100%);
      border: 3px solid #5a7a25;
      border-radius: 12px;
      padding: 20px;
      width: 180px;
      text-align: center;
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .unit-card-large:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 35px rgba(0,0,0,0.5);
    }
    
    .unit-card-large::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, #6b8a35, #8fa85a, #6b8a35);
    }
    
    .unit-card-large .default-badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(107,138,53,0.8);
      padding: 3px 8px;
      border-radius: 3px;
      font-size: 0.6rem;
      letter-spacing: 1px;
      color: #c4d4a5;
    }
    
    .unit-card-large .unit-icon {
      font-size: 3rem;
      margin: 15px 0;
    }
    
    .unit-card-large .unit-name {
      font-family: 'Orbitron', sans-serif;
      font-size: 1rem;
      font-weight: bold;
      letter-spacing: 2px;
      margin-bottom: 10px;
      color: #c4d4a5;
    }
    
    .unit-card-large .unit-desc {
      font-size: 0.75rem;
      color: #8fa85a;
      margin-bottom: 15px;
      min-height: 30px;
    }
    
    .unit-card-large .unit-stats {
      display: flex;
      justify-content: space-around;
      padding: 10px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
      margin-bottom: 10px;
    }
    
    .unit-card-large .stat {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
    }
    
    .unit-card-large .stat-icon {
      font-size: 1rem;
    }
    
    .unit-card-large .unit-cost {
      font-size: 0.85rem;
      color: #ffd700;
      font-weight: bold;
    }
    
    /* ÌñâÍµ∞/Ï£ºÎëî Î™®Îã¨ */
    .deploy-modal, .build-modal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, rgba(45,52,37,0.98) 0%, rgba(26,31,22,0.98) 100%);
      border: 3px solid #4a5d23;
      border-radius: 8px;
      padding: 25px;
      z-index: 101;
      min-width: 700px;
      max-width: 900px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
    }
    
    .deploy-modal.active, .build-modal.active {
      display: block;
    }
    
    .deploy-unit-list {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-height: 400px;
      overflow-y: auto;
    }
    
    .deploy-unit-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: rgba(74,93,35,0.3);
      border: 2px solid #3a4a23;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }
    
    .deploy-unit-item:hover {
      background: rgba(107,138,53,0.4);
      border-color: #6b8a35;
    }
    
    .deploy-unit-item.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .deploy-unit-item .unit-icon {
      font-size: 1.8rem;
      width: 45px;
      height: 45px;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .deploy-unit-item .unit-info {
      flex: 1;
    }
    
    .deploy-unit-item .unit-name {
      font-weight: bold;
      letter-spacing: 2px;
      margin-bottom: 4px;
    }
    
    .deploy-unit-item .unit-location {
      font-size: 0.75rem;
      color: #6b7a4a;
    }
    
    .deploy-unit-item .unit-count {
      font-size: 1.1rem;
      font-weight: bold;
      color: #ffd700;
    }
    
    .deploy-unit-item .unit-status {
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 3px;
      background: rgba(107,138,53,0.5);
      color: #c4d4a5;
    }
    
    .deploy-unit-item .unit-status.moved {
      background: rgba(138,53,53,0.5);
      color: #c49a9a;
    }
    
    .no-units-message {
      text-align: center;
      padding: 30px;
      color: #6b7a4a;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <!-- Ìó§Îçî -->
  <header>
    <h1>WARFRONT</h1>
    <p class="subtitle">TACTICAL COMBAT SIMULATOR</p>
  </header>
  
  <!-- Î°úÍ∑∏Ïù∏ ÌôîÎ©¥ -->
  <div id="login-screen" class="screen active">
    <div class="login-box">
      <div class="login-label">AUTHENTICATION</div>
      <div class="login-title">COMMANDER ID</div>
      <input type="text" id="player-name" class="login-input" placeholder="ENTER CALLSIGN" maxlength="15">
      <button id="login-btn" class="btn" disabled>‚ñ∂ COMMENCE OPERATION</button>
    </div>
  </div>
  
  <!-- Î°úÎπÑ ÌôîÎ©¥ -->
  <div id="lobby-screen" class="screen">
    <div class="lobby-content">
      <!-- ÏÉÅÎã® ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ -->
      <div class="lobby-header">
        <div class="player-card">
          <div class="player-avatar">‚≠ê</div>
          <div class="player-info">
            <div class="label">COMMANDER</div>
            <div class="name" id="lobby-player-name"></div>
            <div class="player-stats">
              <div class="stat-item wins">
                <span>üèÜ</span>
                <span>ÏäπÎ¶¨: <strong id="lobby-wins">0</strong></span>
              </div>
              <div class="stat-item losses">
                <span>üíÄ</span>
                <span>Ìå®Î∞∞: <strong id="lobby-losses">0</strong></span>
              </div>
            </div>
          </div>
        </div>
        <div class="currency-display">
          <div class="currency-item">
            <span class="icon">üí∞</span>
            <span class="amount" id="currency-gold">10000</span>
          </div>
          <div class="currency-item">
            <span class="icon">üíé</span>
            <span class="amount" id="currency-gems">100</span>
          </div>
        </div>
      </div>
      
      <!-- Î©îÏù∏ Ïª®ÌÖêÏ∏† ÏòÅÏó≠ -->
      <div class="lobby-main">
        <!-- ÏÉÅÏ†ê ÌÉ≠ -->
        <div id="shop-tab" class="tab-content">
          <div class="coming-soon-icon">üè™</div>
          <div class="coming-soon">ÏÉÅÏ†ê Ï§ÄÎπÑ Ï§ë...</div>
        </div>
        
        <!-- Îß§Ïπ≠ ÌÉ≠ -->
        <div id="match-tab" class="tab-content active">
          <div class="match-options">
            <button id="pvp-btn" class="match-btn">
              <div class="icon">‚öîÔ∏è</div>
              <div class="title">PVP Îß§Ïπ≠</div>
              <div class="desc">Îã§Î•∏ ÏßÄÌúòÍ¥ÄÍ≥º ÎåÄÏ†Ñ</div>
            </button>
            <button id="ai-btn" class="match-btn">
              <div class="icon">ü§ñ</div>
              <div class="title">AI ÎåÄÏ†Ñ</div>
              <div class="desc">AI ÏÉÅÎåÄÏôÄ ÎåÄÏ†Ñ</div>
            </button>
          </div>
        </div>
        
        <!-- AI ÌÉÄÏûÖ ÏÑ†ÌÉù Î™®Îã¨ -->
        <div id="ai-select-modal" class="modal" style="display:none;">
          <div class="modal-header">
            <span class="title">ü§ñ AI ÌÉÄÏûÖ ÏÑ†ÌÉù</span>
            <button class="close" id="close-ai-modal">√ó</button>
          </div>
          <div class="modal-content">
            <div class="build-options">
              <div class="build-option" data-ai-type="defensive">
                <span class="option-icon">üõ°Ô∏è</span>
                <div class="option-info">
                  <div class="option-name">ÏàòÎπÑÌòï AI</div>
                  <div class="option-desc">Í±¥Î¨º Ïö∞ÏÑ†, ÎäêÎ¶∞ ÏßÑÍ≤©, Î∞©Ïñ¥Ï†Å Ïö¥ÏòÅ</div>
                </div>
              </div>
              <div class="build-option" data-ai-type="balanced">
                <span class="option-icon">‚öñÔ∏è</span>
                <div class="option-info">
                  <div class="option-name">Î∞∏Îü∞Ïä§Ìòï AI</div>
                  <div class="option-desc">Í∑†Ìòï Ïû°Ìûå ÏÉùÏÇ∞Í≥º Í≥µÍ≤©</div>
                </div>
              </div>
              <div class="build-option" data-ai-type="aggressive">
                <span class="option-icon">‚öîÔ∏è</span>
                <div class="option-info">
                  <div class="option-name">Í≥µÍ≤©Ìòï AI</div>
                  <div class="option-desc">Ïú†Îãõ Ïö∞ÏÑ†, Îπ†Î•∏ ÏßÑÍ≤©, Ï†ÅÍ∑πÏ†Å Í≥µÍ≤©</div>
                </div>
              </div>
              <div class="build-option" data-ai-type="hard" style="border: 2px solid #f44; background: rgba(255,50,50,0.1);">
                <span class="option-icon">üíÄ</span>
                <div class="option-info">
                  <div class="option-name" style="color: #f55;">ÌïòÎìú Î™®Îìú (ÌéòÏù¥Ïª§)</div>
                  <div class="option-desc" style="color: #faa;">Ï¥àÍ∏∞ ÎåÄÍµ∞ Î∞∞Ïπò, ÎØ∏ÏÇ¨Ïùº 5Î∞ú, 50ÎßåÏõê ÏãúÏûë</div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ PVP Î™®Îã¨ -->
        <div id="pvp-modal" class="modal" style="display:none;">
          <div class="modal-header">
            <span class="title">üåê Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥</span>
            <button class="close" id="close-pvp-modal">√ó</button>
          </div>
          <div class="modal-content">
            <div style="text-align: center; margin-bottom: 15px; color: #4a9;">
              üë• Ï†ëÏÜç Ï§ë: <span id="online-count">1</span>Î™Ö
            </div>
            
            <!-- Îπ†Î•∏ Îß§Ïπ≠ -->
            <div class="build-option" id="quick-match-option" style="cursor: pointer;">
              <span class="option-icon">‚ö°</span>
              <div class="option-info">
                <div class="option-name">Îπ†Î•∏ Îß§Ïπ≠</div>
                <div class="option-desc">ÎûúÎç§ ÏÉÅÎåÄÏôÄ Ï¶âÏãú ÎåÄÏ†Ñ</div>
              </div>
            </div>
            
            <!-- Îß§Ïπ≠ ÏÉÅÌÉú -->
            <div id="matching-status" style="display:none; text-align:center; padding:20px; color:#aa5; animation: pulse 1.5s infinite;">
              üîç ÏÉÅÎåÄÎ•º Ï∞æÎäî Ï§ë...
            </div>
            <div class="build-option" id="cancel-match-btn" style="display:none; cursor:pointer; border-color:#a55;">
              <span class="option-icon">‚ùå</span>
              <div class="option-info">
                <div class="option-name" style="color:#f77;">Îß§Ïπ≠ Ï∑®ÏÜå</div>
              </div>
            </div>
            
            <div style="text-align:center; color:#4a5d23; margin:15px 0;">‚îÄ‚îÄ ÎòêÎäî ‚îÄ‚îÄ</div>
            
            <!-- Î∞© ÎßåÎì§Í∏∞ -->
            <div class="build-option" id="create-room-option" style="cursor: pointer;">
              <span class="option-icon">üîë</span>
              <div class="option-info">
                <div class="option-name">Î∞© ÎßåÎì§Í∏∞</div>
                <div class="option-desc">ÏπúÍµ¨ÏóêÍ≤å ÏΩîÎìúÎ•º Í≥µÏú†ÌïòÏÑ∏Ïöî</div>
              </div>
            </div>
            
            <!-- Î∞© ÏΩîÎìú ÌëúÏãú -->
            <div id="room-code-display" style="display:none; background:rgba(0,0,0,0.5); padding:20px; text-align:center; border-radius:8px; margin:10px 0;">
              <div style="color:#6b7a4a;">Î∞© ÏΩîÎìú</div>
              <div id="room-code" style="font-family:'Orbitron',sans-serif; font-size:2.5rem; color:#4a9; letter-spacing:10px;">----</div>
              <div style="color:#6b7a4a; font-size:0.85rem; margin-top:10px;">ÏπúÍµ¨ÏóêÍ≤å Ïù¥ ÏΩîÎìúÎ•º ÏïåÎ†§Ï£ºÏÑ∏Ïöî!</div>
              <div id="room-waiting" style="color:#aa5; margin-top:10px; animation: pulse 1.5s infinite;">ÏÉÅÎåÄÎ∞© ÎåÄÍ∏∞ Ï§ë...</div>
            </div>
            
            <!-- Î∞© Ï∞∏Í∞Ä -->
            <div style="margin-top:15px;">
              <input type="text" id="join-code-input" placeholder="Î∞© ÏΩîÎìú ÏûÖÎ†• (4ÏûêÎ¶¨)" maxlength="4" 
                style="width:100%; padding:12px; background:rgba(0,0,0,0.3); border:2px solid #4a5d23; border-radius:4px; color:#c4d4a5; font-family:inherit; font-size:1rem; text-transform:uppercase; text-align:center; letter-spacing:5px;">
              <div class="build-option" id="join-room-option" style="cursor:pointer; margin-top:10px;">
                <span class="option-icon">üö™</span>
                <div class="option-info">
                  <div class="option-name">Î∞© Ï∞∏Í∞Ä</div>
                  <div class="option-desc">ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÍ≥† Ï∞∏Í∞Ä</div>
                </div>
              </div>
            </div>
            
            <div id="pvp-error" style="display:none; color:#f77; text-align:center; padding:10px;"></div>
          </div>
        </div>
        
        <!-- Îß§Ïπ≠ ÏôÑÎ£å Î™®Îã¨ -->
        <div id="match-found-modal" class="modal" style="display:none;">
          <div class="modal-header">
            <span class="title">üéÆ ÎåÄÏ†Ñ ÏÉÅÎåÄ Î∞úÍ≤¨!</span>
          </div>
          <div class="modal-content" style="text-align:center;">
            <div style="display:flex; justify-content:center; align-items:center; gap:20px; font-size:1.3rem; margin:20px 0;">
              <span id="match-player1" style="color:#8fa85a;">ÎÇò</span>
              <span style="color:#a55; font-family:'Orbitron',sans-serif;">VS</span>
              <span id="match-player2" style="color:#f77;">ÏÉÅÎåÄÎ∞©</span>
            </div>
            <div id="ready-status" style="color:#aa5; margin:15px 0;">Ï§ÄÎπÑ ÎåÄÍ∏∞ Ï§ë...</div>
            <div class="build-option" id="ready-btn" style="cursor:pointer; border-color:#4a9;">
              <span class="option-icon">‚úÖ</span>
              <div class="option-info">
                <div class="option-name" style="color:#4a9;">Ï§ÄÎπÑ ÏôÑÎ£å</div>
                <div class="option-desc">ÌÅ¥Î¶≠ÌïòÏó¨ Í≤åÏûÑ ÏãúÏûë</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Ïú†Îãõ ÌÉ≠ -->
        <div id="unit-tab" class="tab-content">
          <div class="unit-tab-container">
            <div class="unit-tab-header">
              <h2>üìã Î≥¥Ïú† Ïú†Îãõ</h2>
              <p class="unit-tab-desc">Í∏∞Î≥∏ Ïú†ÎãõÏùÄ ÏßïÎ≥ëÏÜåÏóêÏÑú ÏßïÎ≥ëÌï† Ïàò ÏûàÏäµÎãàÎã§</p>
            </div>
            <div class="unit-list" id="lobby-unit-list">
              <!-- Ïú†Îãõ Ïπ¥ÎìúÎì§Ïù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê® -->
            </div>
          </div>
        </div>
      </div>
      
      <!-- ÌïòÎã® ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò -->
      <nav class="lobby-nav">
        <button class="nav-btn" data-tab="shop-tab">
          <span class="nav-icon">üè™</span>
          <span class="nav-label">ÏÉÅÏ†ê</span>
        </button>
        <button class="nav-btn active" data-tab="match-tab">
          <span class="nav-icon">‚öîÔ∏è</span>
          <span class="nav-label">Îß§Ïπ≠</span>
        </button>
        <button class="nav-btn" data-tab="unit-tab">
          <span class="nav-icon">üéñÔ∏è</span>
          <span class="nav-label">Ïú†Îãõ</span>
        </button>
      </nav>
    </div>
  </div>
  
  <!-- Îß§Ïπ≠ ÌôîÎ©¥ -->
  <div id="matching-screen" class="screen">
    <div class="matching-box">
      <div id="matching-content">
        <div class="spinner"></div>
        <div class="matching-text">Ï†Å ÌÉêÏÉâ Ï§ë<span id="matching-dots"></span></div>
        <div class="matching-timer" id="matching-time">00:00</div>
        <div class="matching-desc">ÎπÑÏä∑Ìïú Ï†ÑÏ†ÅÏùò ÏßÄÌúòÍ¥ÄÏùÑ Ï∞æÍ≥† ÏûàÏäµÎãàÎã§...</div>
        <button id="cancel-match-btn" class="btn-cancel">Ï∑®ÏÜå</button>
      </div>
      <div id="match-found" class="match-found">
        <div class="icon">‚öîÔ∏è</div>
        <div class="text">ÏÉÅÎåÄ Î∞úÍ≤¨!</div>
        <div class="subtext">Ï†ÑÌà¨ Ï§ÄÎπÑ Ï§ë...</div>
      </div>
    </div>
  </div>
  
  <!-- Í≤åÏûÑ ÌôîÎ©¥ -->
  <div id="game-screen" class="screen">
    <!-- Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ìó§Îçî -->
    <div id="mp-header" style="display:none; position:fixed; top:0; left:0; right:0; background:rgba(26,31,22,0.95); border-bottom:2px solid #4a5d23; padding:10px 20px; z-index:1000; display:flex; justify-content:space-between; align-items:center;">
      <div style="color:#8fa85a;">üë§ ÏÉÅÎåÄ: <span id="opponent-name-display">ÏÉÅÎåÄÎ∞©</span></div>
      <div id="turn-display" style="font-family:'Orbitron',sans-serif; color:#4a9;">üü¢ ÎÇ¥ ÌÑ¥</div>
      <button id="surrender-btn" style="padding:8px 15px; background:linear-gradient(180deg,#5a3020,#4a2515); border:1px solid #7a4030; border-radius:4px; color:#faa; cursor:pointer; font-family:inherit;">üè≥Ô∏è Ìï≠Î≥µ</button>
    </div>
    
    <!-- Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Ï±ÑÌåÖ -->
    <div id="mp-chat-box" style="display:none; position:fixed; bottom:20px; right:20px; width:280px; background:rgba(26,31,22,0.95); border:2px solid #4a5d23; border-radius:8px; z-index:1000;">
      <div style="padding:10px; border-bottom:1px solid #4a5d23; display:flex; justify-content:space-between; align-items:center;">
        <span>üí¨ Ï±ÑÌåÖ</span>
        <button id="toggle-chat-btn" style="background:none; border:none; color:#c4d4a5; cursor:pointer; font-size:1.2rem;">‚àí</button>
      </div>
      <div id="mp-chat-messages" style="height:120px; overflow-y:auto; padding:10px; font-size:0.85rem;"></div>
      <div id="mp-chat-input-area" style="display:flex; border-top:1px solid #4a5d23;">
        <input type="text" id="mp-chat-input" placeholder="Î©îÏãúÏßÄ..." maxlength="100" style="flex:1; padding:10px; background:rgba(0,0,0,0.3); border:none; color:#c4d4a5; font-family:inherit;">
        <button id="mp-chat-send" style="padding:10px 15px; background:#4a5d23; border:none; color:#c4d4a5; cursor:pointer;">Ï†ÑÏÜ°</button>
      </div>
    </div>
    
    <div class="left-panel">
      <!-- Í≤åÏûÑ ÎÇ¥ ÏûêÏõê ÌëúÏãú -->
      <div class="game-resources">
        <span class="resource-icon">üí∞</span>
        <div>
          <div class="resource-amount" id="game-resource-amount">1000</div>
          <div class="resource-label">Î≥¥Ïú† ÏûêÏõê</div>
        </div>
      </div>
      
      <div class="info-box">
        <div class="label">ÎÇò</div>
        <div class="name" id="game-player-name"></div>
        <div class="stats">
          <span>üè∞ Í∏∞ÏßÄ: 3</span>
          <span>‚öîÔ∏è Ïú†Îãõ: 0</span>
        </div>
      </div>
      
      <div class="info-box enemy">
        <div class="label">ÏÉÅÎåÄ</div>
        <div class="name" id="game-enemy-name"></div>
        <div class="stats">
          <span>üè∞ Í∏∞ÏßÄ: ?</span>
          <span>‚öîÔ∏è Ïú†Îãõ: ?</span>
        </div>
      </div>
      
      <!-- Îπ†Î•∏ Ïù¥Îèô (ÏÑ¨ ÏÑ†ÌÉù) -->
      <div class="quick-nav-panel">
        <div class="quick-nav-header">üìç Îπ†Î•∏ Ïù¥Îèô</div>
        <div class="quick-nav-grid">
          <div class="quick-nav-row">
            <button class="area-btn enemy" onclick="goToArea('enemy-sub')">1Ô∏è‚É£ Ï†ÅÎ∂Ä</button>
            <button class="area-btn enemy" onclick="goToArea('enemy-main')">2Ô∏è‚É£ Ï†ÅÎ≥∏</button>
          </div>
          <div class="quick-nav-row">
            <button class="area-btn sea" onclick="goToArea('sea')">üåä Î∞îÎã§</button>
          </div>
          <div class="quick-nav-row">
            <button class="area-btn player" onclick="goToArea('player-sub')">3Ô∏è‚É£ ÏïÑÎ∂Ä</button>
            <button class="area-btn player" onclick="goToArea('player-main')">4Ô∏è‚É£ ÏïÑÎ≥∏</button>
          </div>
        </div>
      </div>
      
      <button id="end-turn-btn" class="btn-end-turn">ÌÑ¥ Ï¢ÖÎ£å ‚ñ∂</button>
      <button id="surrender-btn" class="btn-surrender" onclick="surrender()">üè≥Ô∏è Ìï≠Î≥µ</button>
    </div>
    
    <div class="map-container">
      <!-- ÌÉÄÏù¥Î®∏ -->
      <div class="map-timer-bar">
        <div class="turn-info">
          <span class="turn-label">ÌÑ¥ <span id="turn-number">1</span></span>
          <span class="turn-text" id="turn-text">ÎãπÏã†Ïùò ÌÑ¥</span>
        </div>
        <div class="timer" id="turn-timer">3:00</div>
      </div>
      
      <!-- Îßµ Î∑∞ ÌÉ≠ + Ï§å -->
      <div class="map-controls-bar">
        <div class="map-view-tabs">
          <button class="map-view-tab active" data-view="ground" onclick="switchMapView('ground')">üó∫Ô∏è ÏßÄÏÉÅÎßµ</button>
          <button class="map-view-tab air-tab" data-view="air" onclick="switchMapView('air')">‚úàÔ∏è Í≥µÏ§ëÎßµ</button>
        </div>
        <div class="zoom-controls-inline">
          <button class="zoom-btn-small" onclick="zoomOut()">‚àí</button>
          <span class="zoom-level-small" id="zoom-level">100%</span>
          <button class="zoom-btn-small" onclick="zoomIn()">+</button>
        </div>
      </div>
      
      <!-- Ïä§ÌÅ¨Î°§ Í∞ÄÎä•Ìïú Îßµ ÏòÅÏó≠ -->
      <div class="map-scroll-area" id="map-scroll-area">
        <div class="map-grid" id="map-grid"></div>
      </div>
    </div>
    
    <div class="right-panel">
      <div class="log-header">üìã Ï†ÑÌà¨ Í∏∞Î°ù</div>
      <div class="log-container" id="log-container"></div>
      
      <!-- ÌÉÄÏùº Ï†ïÎ≥¥ Ìå®ÎÑê -->
      <div class="tile-info-panel" id="tile-info-panel">
        <div class="panel-header">üìç ÌÉÄÏùº Ï†ïÎ≥¥</div>
        <div id="tile-info-content">
          <div class="no-selection">ÌÉÄÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>
        </div>
      </div>
      
      <!-- ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÌÅê -->
      <div class="missile-queue-panel" id="missile-queue-panel" style="display:none;">
        <div class="log-header" style="background:#2a1a1a;border-color:#7a2525;">üöÄ ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞</div>
        <div id="missile-queue-container" style="padding:8px;background:#1a1a2e;border-radius:0 0 8px 8px;max-height:120px;overflow-y:auto;">
          <div style="color:#aaa;text-align:center;padding:10px;">ÏÉùÏÇ∞ Ï§ëÏù∏ ÎØ∏ÏÇ¨Ïùº ÏóÜÏùå</div>
        </div>
        <div style="padding:8px;background:#0a2a1a;border-radius:8px;margin-top:5px;">
          <span style="color:#4a9;">üì¶ ÏôÑÏÑ± Ïû¨Í≥†: </span>
          <span id="completed-missile-count" style="color:#fff;font-weight:bold;">0</span>Í∞ú
        </div>
      </div>
    </div>
  </div>
  
  <!-- Ïï°ÏÖò Î©îÎâ¥ -->
  <div class="overlay" id="action-overlay"></div>
  <div class="action-menu" id="action-menu">
    <div class="action-menu-header">
      <span class="coords">Ï¢åÌëú: (<span id="tile-x">0</span>, <span id="tile-y">0</span>)</span>
      <button class="close" id="close-action-menu">√ó</button>
    </div>
    <div class="action-buttons">
      <button class="action-btn" data-action="march">
        <span class="icon">üö∂</span>
        <div class="info">
          <div class="title">ÌñâÍµ∞</div>
          <div class="desc">Ïú†ÎãõÏùÑ Ïù¥ÎèôÌï©ÎãàÎã§</div>
        </div>
      </button>
      <button class="action-btn" data-action="station">
        <span class="icon">üèïÔ∏è</span>
        <div class="info">
          <div class="title">Ï£ºÎëî</div>
          <div class="desc">Ïú†ÎãõÏùÑ Î∞∞ÏπòÌï©ÎãàÎã§</div>
        </div>
      </button>
      <button class="action-btn" data-action="attack" id="attack-action-btn">
        <span class="icon">‚öîÔ∏è</span>
        <div class="info">
          <div class="title">Í≥µÍ≤©</div>
          <div class="desc">Ï†ÅÏùÑ Í≥µÍ≤©Ìï©ÎãàÎã§</div>
        </div>
      </button>
      <button class="action-btn" data-action="build">
        <span class="icon">üî®</span>
        <div class="info">
          <div class="title">Í±¥Ï∂ï</div>
          <div class="desc">Í±¥Î¨ºÏùÑ Í±¥ÏÑ§Ìï©ÎãàÎã§</div>
        </div>
      </button>
      <button class="action-btn" data-action="recruit" id="recruit-action-btn" style="display: none;">
        <span class="icon">üéñÔ∏è</span>
        <div class="info">
          <div class="title">ÏßïÎ≥ë</div>
          <div class="desc">Î≥ëÏÇ¨Î•º ÏßïÎ≥ëÌï©ÎãàÎã§</div>
        </div>
      </button>
      <button class="action-btn" data-action="build-bridge" id="bridge-action-btn" style="display: none;">
        <span class="icon">üåâ</span>
        <div class="info">
          <div class="title">Îã§Î¶¨ Í±¥ÏÑ§</div>
          <div class="desc">Í∞ïÏóê Îã§Î¶¨Î•º Í±¥ÏÑ§Ìï©ÎãàÎã§ (300)</div>
        </div>
      </button>
      <button class="action-btn" data-action="build-farm" id="farm-action-btn" style="display: none;">
        <span class="icon">üåæ</span>
        <div class="info">
          <div class="title">ÎÜçÏû• Í±¥ÏÑ§</div>
          <div class="desc">ÌÑ¥Îãπ 600 ÏûêÏõê (ÎπÑÏö©: 300)</div>
        </div>
      </button>
      <button class="action-btn" data-action="build-greenhouse" id="greenhouse-action-btn" style="display: none;">
        <span class="icon">üè°</span>
        <div class="info">
          <div class="title">Ïò®Ïã§ Í±¥ÏÑ§</div>
          <div class="desc">ÌÑ¥Îãπ 3000 ÏûêÏõê (ÎπÑÏö©: 1000)</div>
        </div>
      </button>
      <button class="action-btn" data-action="military-build" id="military-build-btn" style="display: none;">
        <span class="icon">üèóÔ∏è</span>
        <div class="info">
          <div class="title">Íµ∞ÏÇ¨ Í±¥ÏÑ§</div>
          <div class="desc">Î∞ïÍ≤©Ìè¨, ÌôúÏ£ºÎ°ú Îì± Íµ∞ÏÇ¨ ÏãúÏÑ§ Í±¥ÏÑ§</div>
        </div>
      </button>
      <button class="action-btn" data-action="fire-mortar" id="fire-mortar-btn" style="display: none;">
        <span class="icon">üéÜ</span>
        <div class="info">
          <div class="title">Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨</div>
          <div class="desc">10000 ÌîºÌï¥ (Î∞úÏÇ¨ÎπÑÏö©: 5000)</div>
        </div>
      </button>
      <button class="action-btn" data-action="produce-aircraft" id="produce-aircraft-btn" style="display: none;">
        <span class="icon">‚úàÔ∏è</span>
        <div class="info">
          <div class="title">ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞</div>
          <div class="desc">ÌôúÏ£ºÎ°úÏóêÏÑú Ìï≠Í≥µÍ∏∞ ÏÉùÏÇ∞</div>
        </div>
      </button>
      <button class="action-btn" data-action="produce-ship" id="produce-ship-btn" style="display: none;">
        <span class="icon">üö¢</span>
        <div class="info">
          <div class="title">Ìï®ÏÑ† ÏÉùÏÇ∞</div>
          <div class="desc">Ìï≠Íµ¨ÏóêÏÑú Ìï®ÏÑ† ÏÉùÏÇ∞</div>
        </div>
      </button>
      <button class="action-btn attack" data-action="attack-harbor" id="attack-harbor-btn" style="display: none;">
        <span class="icon">üí•</span>
        <div class="info">
          <div class="title">Ìï≠Íµ¨ Í≥µÍ≤©</div>
          <div class="desc">Ï†ÑÌï®ÏúºÎ°ú Ï†Å Ìï≠Íµ¨ Í≥µÍ≤© (3000 ÌîºÌï¥)</div>
        </div>
      </button>
      <button class="action-btn" data-action="rebuild-harbor" id="rebuild-harbor-btn" style="display: none;">
        <span class="icon">üîß</span>
        <div class="info">
          <div class="title">Ìï≠Íµ¨ Ïû¨Í±¥</div>
          <div class="desc">ÌååÍ¥¥Îêú Ìï≠Íµ¨ Ïû¨Í±¥ (üí∞ 5000)</div>
        </div>
      </button>
      <button class="action-btn attack" data-action="attack-ship" id="attack-ship-btn" style="display: none;">
        <span class="icon">üöÄ</span>
        <div class="info">
          <div class="title">Ìï®ÏÑ† Í≥µÍ≤©</div>
          <div class="desc">ÎØ∏ÏÇ¨ÏùºÎ°ú Ï†Å Ìï®ÏÑ† Í≥µÍ≤©</div>
        </div>
      </button>
      <button class="action-btn" data-action="transport" id="transport-btn" style="display: none;">
        <span class="icon">üì¶</span>
        <div class="info">
          <div class="title">ÏàòÏÜ°</div>
          <div class="desc">Ïú†ÎãõÏùÑ ÏàòÏÜ°Ìï®Ïóê ÌÉëÏäπ</div>
        </div>
      </button>
      <button class="action-btn" data-action="land" id="land-btn" style="display: none;">
        <span class="icon">üèñÔ∏è</span>
        <div class="info">
          <div class="title">ÏÉÅÎ•ô</div>
          <div class="desc">ÏàòÏÜ°Ìïú Ïú†ÎãõÏùÑ Ïú°ÏßÄÏóê ÎÇ¥Î¶º</div>
        </div>
      </button>
      <button class="action-btn attack" data-action="bomb" id="bomb-btn" style="display: none;">
        <span class="icon">üí•</span>
        <div class="info">
          <div class="title">Ìè≠Í≤©</div>
          <div class="desc">Ï†Å Ïú°ÏßÄÏóê 2Îßå Îç∞ÎØ∏ÏßÄ</div>
        </div>
      </button>
      <button class="action-btn" data-action="produce-missile" id="produce-missile-btn" style="display: none;">
        <span class="icon">üè≠</span>
        <div class="info">
          <div class="title">ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞</div>
          <div class="desc">ÎØ∏ÏÇ¨Ïùº Ï†úÏûë (10ÎßåÏõê, 3ÌÑ¥)</div>
        </div>
      </button>
      <button class="action-btn" data-action="produce-tank" id="produce-tank-btn" style="display: none;">
        <span class="icon">üöú</span>
        <div class="info">
          <div class="title">ÌÉ±ÌÅ¨ ÏÉùÏÇ∞</div>
          <div class="desc">Í∞ïÎ†•Ìïú Í∏∞Í∞ë Ïú†Îãõ ÏÉùÏÇ∞</div>
        </div>
      </button>
      <button class="action-btn attack" data-action="launch-missile" id="launch-missile-btn" style="display: none;">
        <span class="icon">üöÄ</span>
        <div class="info">
          <div class="title">ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨</div>
          <div class="desc">20Ïπ∏ ÏÇ¨Í±∞Î¶¨, 10Îßå ÌîºÌï¥ (5ÎßåÏõê)</div>
        </div>
      </button>
      <button class="action-btn" data-action="upgrade" id="upgrade-btn" style="display: none;">
        <span class="icon">‚¨ÜÔ∏è</span>
        <div class="info">
          <div class="title">ÏóÖÍ∑∏Î†àÏù¥Îìú</div>
          <div class="desc" id="upgrade-btn-desc">Í±¥Î¨º Î†àÎ≤®ÏóÖ</div>
        </div>
      </button>
      <button class="action-btn" data-action="place-mine" id="place-mine-btn" style="display: none;">
        <span class="icon">üí£</span>
        <div class="info">
          <div class="title">ÏßÄÎ¢∞ ÏÑ§Ïπò</div>
          <div class="desc">ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ (10,000Ïõê)</div>
        </div>
      </button>
      <button class="action-btn" data-action="engineer-build" id="engineer-build-btn" style="display: none;">
        <span class="icon">üèóÔ∏è</span>
        <div class="info">
          <div class="title">Ï†ÑÎ¨∏ Í±¥Ï∂ï</div>
          <div class="desc">Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö© Í±¥Î¨º</div>
        </div>
      </button>
      <button class="action-btn" data-action="capture" id="capture-btn" style="display: none;">
        <span class="icon">üö©</span>
        <div class="info">
          <div class="title">Ï†êÎ†π</div>
          <div class="desc">Ï†Å ÏòÅÌÜ† Ï†êÎ†π</div>
        </div>
      </button>
    </div>
  </div>
  
  <!-- Í±¥Ï∂ï Î™®Îã¨ -->
  <div class="modal" id="build-modal">
    <div class="modal-header">
      <span class="title">üî® Í±¥Ï∂ï</span>
      <button class="close" id="close-build-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-option" data-building="barracks" id="build-barracks">
        <span class="option-icon">üèõÔ∏è</span>
        <div class="option-info">
          <div class="option-name">ÏßïÎ≥ëÏÜå</div>
          <div class="option-desc">Î≥ëÏÇ¨Î•º ÏßïÎ≥ëÌï† Ïàò ÏûàÎäî Í±¥Î¨º</div>
        </div>
        <div class="option-cost">üí∞ 500</div>
      </div>
    </div>
  </div>
  
  <!-- Ï†ÑÎ¨∏ Í±¥Ï∂ï Î™®Îã¨ (Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö©) -->
  <div class="build-modal" id="engineer-build-modal">
    <div class="modal-header">
      <span class="title">üèóÔ∏è Ï†ÑÎ¨∏ Í±¥Ï∂ï</span>
      <button class="close" id="close-engineer-build-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-options">
        <div class="build-option" data-building="city" id="build-city">
          <span class="option-icon">üèôÔ∏è</span>
          <div class="option-info">
            <div class="option-name">ÎèÑÏãú</div>
            <div class="option-desc">ÌÑ¥Îãπ 20ÎßåÏõê ÏàòÏûÖ (ÏóÖÍ∑∏Î†àÏù¥Îìú Í∞ÄÎä•)</div>
          </div>
          <div class="option-cost">üí∞ 100,000</div>
        </div>
      </div>
      <div style="margin-top:15px;padding:10px;background:#1a2a1a;border-radius:8px;border:1px solid #3a5a3a;">
        <div style="color:#4a9;font-size:0.9em;">üí° Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö© Í±¥Î¨º</div>
        <div style="color:#aaa;font-size:0.85em;margin-top:5px;">Í±¥Ï∂ïÍ∞ÄÍ∞Ä Ïù∏Ï†ëÌï¥Ïïº Í±¥ÏÑ§ Í∞ÄÎä•Ìï©ÎãàÎã§.</div>
      </div>
    </div>
  </div>
  
  <!-- ÏàòÏÜ° Î™®Îã¨ -->
  <div class="deploy-modal" id="transport-modal">
    <div class="modal-header">
      <span class="title">üì¶ Ïú†Îãõ ÏàòÏÜ°</span>
      <button class="close" id="close-transport-modal">√ó</button>
    </div>
    <div class="modal-content">
      <p style="color:#aaa;margin-bottom:10px;">ÏàòÏÜ°Ìï† Ïú†ÎãõÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (ÏµúÎåÄ 2Í∞ú)</p>
      <div class="unit-list" id="transport-unit-list">
        <!-- Ïú†Îãõ Î™©Î°ùÏù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê® -->
      </div>
      <div style="margin-top:15px;text-align:center;">
        <button class="modal-btn confirm" id="confirm-transport-btn" disabled>ÏàòÏÜ° ÌôïÏ†ï (0/2)</button>
      </div>
    </div>
  </div>
  
  <!-- ÏÉÅÎ•ô Î™®Îã¨ -->
  <div class="deploy-modal" id="land-modal">
    <div class="modal-header">
      <span class="title">üèñÔ∏è ÏÉÅÎ•ô</span>
      <button class="close" id="close-land-modal">√ó</button>
    </div>
    <div class="modal-content">
      <p style="color:#aaa;margin-bottom:10px;">ÏÉÅÎ•ôÌï† ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</p>
      <div class="build-options" id="land-positions">
        <!-- ÏÉÅÎ•ô Í∞ÄÎä• ÏúÑÏπòÍ∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê® -->
      </div>
    </div>
  </div>
  
  <!-- ÏßïÎ≥ë Î™®Îã¨ -->
  <div class="modal" id="recruit-modal">
    <div class="modal-header">
      <span class="title">üéñÔ∏è ÏßïÎ≥ë</span>
      <button class="close" id="close-recruit-modal">√ó</button>
    </div>
    <div class="modal-content">
      <!-- Ïú†Îãõ ÌÉÄÏûÖ ÏÑ†ÌÉù -->
      <div class="recruit-type-select" id="recruit-type-select">
        <div class="build-options">
          <div class="build-option" data-unit="soldier">
            <span class="option-icon">üéñÔ∏è</span>
            <div class="option-info">
              <div class="option-name">ÏùºÎ∞ò Î≥ëÏÇ¨</div>
              <div class="option-desc">Í∏∞Î≥∏ Î≥¥Î≥ë (100Î™Ö)</div>
            </div>
            <div class="option-cost">üí∞ 100</div>
          </div>
          <div class="build-option" data-unit="engineer">
            <span class="option-icon">üë∑</span>
            <div class="option-info">
              <div class="option-name">Í±¥Ï∂ïÍ∞Ä</div>
              <div class="option-desc">Í±¥Î¨º Í±¥ÏÑ§</div>
            </div>
            <div class="option-cost">üí∞ 150</div>
          </div>
          <div class="build-option" data-unit="scout">
            <span class="option-icon">üî≠</span>
            <div class="option-info">
              <div class="option-name">Ï†ïÏ∞∞Î≥ë</div>
              <div class="option-desc">ÏïàÍ∞ú Ï†ïÏ∞∞</div>
            </div>
            <div class="option-cost">üí∞ 120</div>
          </div>
          <div class="build-option" data-unit="farmer">
            <span class="option-icon">üë®‚Äçüåæ</span>
            <div class="option-info">
              <div class="option-name">ÎÜçÎ∂Ä</div>
              <div class="option-desc">ÎÜçÏû•/Ïò®Ïã§ Í±¥ÏÑ§</div>
            </div>
            <div class="option-cost">üí∞ 100</div>
          </div>
          <div class="build-option" data-unit="commando">
            <span class="option-icon">üéØ</span>
            <div class="option-info">
              <div class="option-name">ÌäπÍ≥µÎåÄ</div>
              <div class="option-desc">30% ÌîºÌï¥ (100Î™Ö)</div>
            </div>
            <div class="option-cost">üí∞ 1000</div>
          </div>
          <div class="build-option" data-unit="military_engineer">
            <span class="option-icon">üîß</span>
            <div class="option-info">
              <div class="option-name">Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞Ä</div>
              <div class="option-desc">Íµ∞ÏÇ¨ ÏãúÏÑ§ Í±¥ÏÑ§</div>
            </div>
            <div class="option-cost">üí∞ 500</div>
          </div>
          <div class="build-option" data-unit="anti_tank">
            <span class="option-icon">üöÄ</span>
            <div class="option-info">
              <div class="option-name">ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë</div>
              <div class="option-desc">ÌÉ±ÌÅ¨ ÌäπÌôî + ÏßÄÎ¢∞ ÏÑ§Ïπò</div>
            </div>
            <div class="option-cost">üí∞ 2000</div>
          </div>
        </div>
      </div>
      
      <!-- ÏßïÎ≥ë ÏàòÎüâ ÏÑ†ÌÉù -->
      <div class="recruit-control" id="recruit-control" style="display: none;">
        <button class="btn-cancel" id="recruit-back" style="margin-bottom: 20px;">‚Üê Îí§Î°ú</button>
        <div class="unit-preview">
          <div class="unit-card" style="margin: 0 auto;">
            <div class="unit-icon" id="recruit-unit-icon">üéñÔ∏è</div>
            <div class="unit-name" id="recruit-unit-name">ÏùºÎ∞ò Î≥ëÏÇ¨</div>
            <div class="unit-count" id="recruit-preview-count">100Î™Ö</div>
            <div class="unit-stats">
              <div class="stat">
                <span class="stat-icon">‚öîÔ∏è</span>
                <span id="recruit-stat-atk">10</span>
              </div>
              <div class="stat">
                <span class="stat-icon">üõ°Ô∏è</span>
                <span id="recruit-stat-def">5</span>
              </div>
              <div class="stat">
                <span class="stat-icon">‚ù§Ô∏è</span>
                <span id="recruit-stat-hp">100</span>
              </div>
            </div>
          </div>
        </div>
        <div class="quantity-control">
          <button class="qty-btn" id="recruit-minus">-</button>
          <div class="qty-display"><span id="recruit-quantity">100</span>Î™Ö</div>
          <button class="qty-btn" id="recruit-plus">+</button>
        </div>
        <button class="max-buy-btn" id="recruit-max">ÏµúÎåÄ Íµ¨Îß§</button>
        <div class="total-cost">
          Ï¥ù ÎπÑÏö©: üí∞ <span id="recruit-total-cost">100</span> / Î≥¥Ïú†: üí∞ <span id="recruit-available">1000</span>
        </div>
        <button class="recruit-btn" id="confirm-recruit">ÏßïÎ≥ëÌïòÍ∏∞</button>
      </div>
    </div>
  </div>
  
  <!-- ÌñâÍµ∞/Ï£ºÎëî Î™®Îã¨ -->
  <div class="deploy-modal" id="deploy-modal">
    <div class="modal-header">
      <span class="title" id="deploy-modal-title">üö∂ ÌñâÍµ∞</span>
      <button class="close" id="close-deploy-modal">√ó</button>
    </div>
    <div class="modal-content">
      <p style="margin-bottom: 15px; color: #8fa85a; font-size: 0.85rem;">
        Ïù¥ÎèôÌï† Ïú†ÎãõÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (Î™©Ìëú: <span id="deploy-target-coords"></span>)
      </p>
      <div class="deploy-unit-list" id="deploy-unit-list">
        <!-- Ïú†Îãõ Î™©Î°ùÏù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê® -->
      </div>
    </div>
  </div>
  
  <!-- Ìï≠Î≥µ ÌôïÏù∏ Î™®Îã¨ -->
  <div class="modal" id="surrender-modal">
    <div class="modal-header">
      <span class="title">üè≥Ô∏è Ìï≠Î≥µ ÌôïÏù∏</span>
      <button class="close" id="close-surrender-modal">√ó</button>
    </div>
    <div class="modal-content" style="text-align: center;">
      <p style="margin-bottom: 20px; font-size: 1.1rem;">Ï†ïÎßê Ìï≠Î≥µÌïòÏãúÍ≤†ÏäµÎãàÍπå?</p>
      <p style="margin-bottom: 25px; color: #c49a9a;">ÏÉÅÎåÄÎ∞©Ïùò ÏäπÎ¶¨Î°ú Ï≤òÎ¶¨Îê©ÎãàÎã§.</p>
      <div style="display: flex; gap: 15px; justify-content: center;">
        <button class="btn-cancel" id="cancel-surrender">Ï∑®ÏÜå</button>
        <button class="recruit-btn" id="confirm-surrender" style="background: linear-gradient(145deg, #8a3535 0%, #6a2525 100%);">Ìï≠Î≥µÌïòÍ∏∞</button>
      </div>
    </div>
  </div>
  
  <!-- Í≥µÍ≤© Î™®Îã¨ -->
  <div class="deploy-modal" id="attack-modal">
    <div class="modal-header">
      <span class="title">‚öîÔ∏è Í≥µÍ≤©</span>
      <button class="close" id="close-attack-modal">√ó</button>
    </div>
    <div class="modal-content">
      <p style="margin-bottom: 10px; color: #8fa85a; font-size: 0.85rem;">
        Í≥µÍ≤© ÎåÄÏÉÅ: <span id="attack-target-info"></span>
      </p>
      <p style="margin-bottom: 15px; color: #c49a9a; font-size: 0.85rem;">
        ÏòàÏÉÅ ÌîºÌï¥Îüâ: <span id="attack-damage-preview">0</span>
      </p>
      <div class="deploy-unit-list" id="attack-unit-list">
        <!-- Í≥µÍ≤© Í∞ÄÎä•Ìïú Ïú†Îãõ Î™©Î°ù -->
      </div>
    </div>
  </div>
  
  <!-- Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ Î™®Îã¨ -->
  <div class="deploy-modal" id="mortar-fire-modal">
    <div class="modal-header">
      <span class="title">üí£ Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨</span>
      <button class="close" id="close-mortar-modal">√ó</button>
    </div>
    <div class="modal-content">
      <p style="margin-bottom: 10px; color: #8fa85a; font-size: 0.85rem;">
        ÏÇ¨Í±∞Î¶¨: 5Ïπ∏ | ÌîºÌï¥: 10,000 | Î∞úÏÇ¨ÎπÑÏö©: 5,000
      </p>
      <p style="margin-bottom: 15px; color: #c49a9a; font-size: 0.85rem;">
        Í≥µÍ≤©Ìï† ÎåÄÏÉÅÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî
      </p>
      <div class="deploy-unit-list" id="mortar-target-list">
        <!-- Î∞ïÍ≤©Ìè¨ ÌÉÄÍ≤ü Î™©Î°ù -->
      </div>
    </div>
  </div>
  
  <!-- Íµ∞ÏÇ¨ Í±¥ÏÑ§ Î™®Îã¨ -->
  <div class="build-modal" id="military-build-modal">
    <div class="modal-header">
      <span class="title">üèóÔ∏è Íµ∞ÏÇ¨ Í±¥ÏÑ§</span>
      <button class="close" id="close-military-build-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-options">
        <div class="build-option" id="build-mortar-option" data-building="mortar">
          <span class="option-icon">üí£</span>
          <div class="option-info">
            <div class="option-name">Î∞ïÍ≤©Ìè¨</div>
            <div class="option-desc">5Ïπ∏ ÏÇ¨Í±∞Î¶¨, 10000 ÌîºÌï¥</div>
          </div>
          <div class="option-cost">üí∞ 50,000</div>
        </div>
        <div class="build-option" id="build-runway-option" data-building="runway">
          <span class="option-icon">üõ´</span>
          <div class="option-info">
            <div class="option-name">ÌôúÏ£ºÎ°ú</div>
            <div class="option-desc">ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Í∞ÄÎä•</div>
          </div>
          <div class="option-cost">üí∞ 30,000</div>
        </div>
        <div class="build-option" id="build-arms-factory-option" data-building="arms_factory">
          <span class="option-icon">üè≠</span>
          <div class="option-info">
            <div class="option-name">Íµ∞Ïàò Í≥µÏû•</div>
            <div class="option-desc">ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ (10ÎßåÏõê, 3ÌÑ¥)</div>
          </div>
          <div class="option-cost">üí∞ 50,000</div>
        </div>
        <div class="build-option" id="build-missile-silo-option" data-building="missile_silo">
          <span class="option-icon">üöÄ</span>
          <div class="option-info">
            <div class="option-name">ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ÎåÄ</div>
            <div class="option-desc">20Ïπ∏ ÏÇ¨Í±∞Î¶¨, 10Îßå ÌîºÌï¥</div>
          </div>
          <div class="option-cost">üí∞ 100,000</div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Î™®Îã¨ -->
  <div class="build-modal" id="aircraft-modal">
    <div class="modal-header">
      <span class="title">‚úàÔ∏è ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞</span>
      <button class="close" id="close-aircraft-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-options">
        <div class="build-option" id="build-recon-plane" data-unit="recon_plane">
          <span class="option-icon">‚úàÔ∏è</span>
          <div class="option-info">
            <div class="option-name">Ï†ïÏ∞∞Í∏∞</div>
            <div class="option-desc">Ï†Å ÏßÑÏòÅ ÏßÑÏûÖ Ïãú Î™®Îì† ÏïàÍ∞ú Ï†úÍ±∞</div>
          </div>
          <div class="option-cost">üí∞ 8,000</div>
        </div>
        <div class="build-option" id="build-bomber" data-unit="bomber">
          <span class="option-icon">üí£</span>
          <div class="option-info">
            <div class="option-name">Ìè≠Í≤©Í∏∞</div>
            <div class="option-desc">Ï†Å Ïú°ÏßÄÏóê 2Îßå Îç∞ÎØ∏ÏßÄ Ìè≠Í≤©</div>
          </div>
          <div class="option-cost">üí∞ 15,000</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Ìï®ÏÑ† ÏÉùÏÇ∞ Î™®Îã¨ -->
  <div class="build-modal" id="ship-modal">
    <div class="modal-header">
      <span class="title">‚öì Ìï®ÏÑ† ÏÉùÏÇ∞</span>
      <button class="close" id="close-ship-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-options">
        <div class="build-option" id="build-attack-ship" data-unit="attack_ship">
          <span class="option-icon">üö¢</span>
          <div class="option-info">
            <div class="option-name">Ï†ÑÌï®</div>
            <div class="option-desc">Ï†Å Ìï≠Íµ¨ Í≥µÍ≤© (3000 ÌîºÌï¥)</div>
          </div>
          <div class="option-cost">üí∞ 3,000</div>
        </div>
        <div class="build-option" id="build-missile-cruiser" data-unit="missile_cruiser">
          <span class="option-icon">üõ≥Ô∏è</span>
          <div class="option-info">
            <div class="option-name">ÎØ∏ÏÇ¨Ïùº ÏàúÏñëÌï®</div>
            <div class="option-desc">10Ïπ∏ ÏÇ¨Í±∞Î¶¨, Ï†Å Ìï®ÏÑ† Í≥µÍ≤©</div>
          </div>
          <div class="option-cost">üí∞ 5,000</div>
        </div>
        <div class="build-option" id="build-transport-ship" data-unit="transport_ship">
          <span class="option-icon">‚õ¥Ô∏è</span>
          <div class="option-info">
            <div class="option-name">ÏàòÏÜ°Ìï®</div>
            <div class="option-desc">Ïú†Îãõ 2Í∞ú ÏàòÏÜ°, Ï†Å Ìï¥Ïïà ÏÉÅÎ•ô</div>
          </div>
          <div class="option-cost">üí∞ 2,000</div>
        </div>
      </div>
    </div>
  </div>

  <!-- ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î™®Îã¨ -->
  <div class="build-modal" id="missile-produce-modal">
    <div class="modal-header">
      <span class="title">üè≠ ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞</span>
      <button class="close" id="close-missile-produce-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-options">
        <div class="build-option" id="produce-missile-option">
          <span class="option-icon">üöÄ</span>
          <div class="option-info">
            <div class="option-name">ÎØ∏ÏÇ¨Ïùº Ï†úÏûë</div>
            <div class="option-desc">3ÌÑ¥ ÌõÑ ÏôÑÏÑ± (Í∏ÄÎ°úÎ≤å Ïû¨Í≥†Ïóê Ï∂îÍ∞Ä)</div>
          </div>
          <div class="option-cost">üí∞ 100,000</div>
        </div>
      </div>
      <div style="margin-top:15px;padding:10px;background:#1a1a2e;border-radius:8px;">
        <div style="color:#4a9;margin-bottom:8px;">üì¶ ÌòÑÏû¨ ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥†: <span id="missile-stock-display">0</span>Í∞ú</div>
        <div style="color:#aaa;font-size:0.9em;">ÏÉùÏÇ∞ Ï§ë: <span id="missile-queue-display">ÏóÜÏùå</span></div>
      </div>
    </div>
  </div>

  <!-- ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Î™®Îã¨ -->
  <div class="deploy-modal" id="missile-launch-modal">
    <div class="modal-header">
      <span class="title">üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨</span>
      <button class="close" id="close-missile-launch-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div style="margin-bottom:15px;padding:10px;background:#1a1a2e;border-radius:8px;">
        <div style="color:#4a9;">üì¶ ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥†: <span id="launch-missile-stock">0</span>Í∞ú</div>
        <div style="color:#f55;margin-top:5px;">üí∞ Î∞úÏÇ¨ ÎπÑÏö©: 50,000</div>
        <div style="color:#aaa;margin-top:5px;">üéØ ÏÇ¨Í±∞Î¶¨: 20Ïπ∏ | üí• ÌîºÌï¥: 100,000</div>
      </div>
      <p style="color:#aaa;margin-bottom:10px;">Î∞úÏÇ¨Ìï† Î™©ÌëúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:</p>
      <div class="unit-list" id="missile-target-list" style="max-height:200px;overflow-y:auto;">
        <!-- ÌÉÄÍ≤ü Î™©Î°ùÏù¥ Ïó¨Í∏∞Ïóê ÌëúÏãúÎê® -->
      </div>
    </div>
  </div>

  <!-- ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ Î™®Îã¨ -->
  <div class="build-modal" id="tank-produce-modal">
    <div class="modal-header">
      <span class="title">üöú ÌÉ±ÌÅ¨ ÏÉùÏÇ∞</span>
      <button class="close" id="close-tank-produce-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div class="build-options">
        <!-- Í∏∞Î≥∏ ÌÉ±ÌÅ¨ -->
        <div class="build-option tank-option" data-tank-type="tank_basic">
          <span class="option-icon">üöú</span>
          <div class="option-info">
            <div class="option-name">Í∏∞Î≥∏ ÌÉ±ÌÅ¨</div>
            <div class="option-desc">ÏÇ¨Í±∞Î¶¨ 3 | Îç∞ÎØ∏ÏßÄ 5,000 | Ïù¥Îèô 2Ïπ∏</div>
          </div>
          <div class="option-cost">üí∞ 10,000</div>
        </div>
        <!-- Ï§ëÍ∏â ÌÉ±ÌÅ¨ -->
        <div class="build-option tank-option" data-tank-type="tank_medium">
          <span class="option-icon">üõ°Ô∏èüöú</span>
          <div class="option-info">
            <div class="option-name">Ï§ëÍ∏â ÌÉ±ÌÅ¨</div>
            <div class="option-desc">ÏÇ¨Í±∞Î¶¨ 4 | Îç∞ÎØ∏ÏßÄ 7,000 | Ïù¥Îèô 3Ïπ∏</div>
          </div>
          <div class="option-cost">üí∞ 20,000</div>
        </div>
        <!-- Í≥†Í∏â ÌÉ±ÌÅ¨ -->
        <div class="build-option tank-option" data-tank-type="tank_advanced">
          <span class="option-icon">‚≠êüöú</span>
          <div class="option-info">
            <div class="option-name">Í≥†Í∏â ÌÉ±ÌÅ¨</div>
            <div class="option-desc">ÏÇ¨Í±∞Î¶¨ 5 | Îç∞ÎØ∏ÏßÄ 10,000 | Ïù¥Îèô 5Ïπ∏</div>
          </div>
          <div class="option-cost">üí∞ 50,000</div>
        </div>
      </div>
      
      <!-- ÏàòÎüâ ÏÑ†ÌÉù -->
      <div id="tank-quantity-section" style="display:none; margin-top:15px; padding:15px; background:#1a1a2e; border-radius:8px;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
          <span style="color:#fff;">ÏÑ†ÌÉù: <span id="selected-tank-name">-</span></span>
          <span style="color:#4a9;">Îã®Í∞Ä: <span id="selected-tank-price">0</span>Ïõê</span>
        </div>
        <div style="display:flex; align-items:center; gap:10px; margin-bottom:15px;">
          <label style="color:#aaa;">ÏàòÎüâ:</label>
          <button class="quantity-btn" id="tank-qty-decrease">-</button>
          <input type="number" id="tank-quantity" value="1" min="1" style="width:60px;text-align:center;padding:5px;border-radius:4px;border:1px solid #444;background:#2a2a3e;color:#fff;">
          <button class="quantity-btn" id="tank-qty-increase">+</button>
          <button class="max-btn" id="tank-qty-max" style="padding:5px 10px;background:#4a9;border:none;border-radius:4px;color:#fff;cursor:pointer;">ÏµúÎåÄ</button>
        </div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
          <span style="color:#f55;">Ï¥ù ÎπÑÏö©: <span id="tank-total-cost">0</span>Ïõê</span>
          <span style="color:#aaa;">Î≥¥Ïú†: <span id="tank-player-resources">0</span>Ïõê</span>
        </div>
        <button id="confirm-tank-produce" style="width:100%;padding:12px;background:#4a9;border:none;border-radius:8px;color:#fff;font-size:1em;cursor:pointer;">üöú ÌÉ±ÌÅ¨ ÏÉùÏÇ∞</button>
      </div>
      
      <div style="margin-top:15px;padding:10px;background:#2a1a1a;border-radius:8px;border:1px solid #533;">
        <div style="color:#f99;font-size:0.9em;">‚ö†Ô∏è ÌÉ±ÌÅ¨ ÌäπÏÑ±</div>
        <div style="color:#aaa;font-size:0.85em;margin-top:5px;">‚Ä¢ Íµ¨Ï°∞Î¨º(Í±¥Î¨º/Í∏∞ÏßÄ) Í≥µÍ≤© Ïãú 5Î∞∞ ÌîºÌï¥</div>
        <div style="color:#aaa;font-size:0.85em;">‚Ä¢ ÌÉ±ÌÅ¨ vs ÌÉ±ÌÅ¨: HP Í∏∞Î∞ò Ï†ÑÌà¨</div>
        <div style="color:#aaa;font-size:0.85em;">‚Ä¢ Í∏∞Î≥∏ 1,000HP / Ï§ëÍ∏â 3,000HP / Í≥†Í∏â 5,000HP</div>
      </div>
    </div>
  </div>

  <!-- ÏßÄÎ¢∞ ÏÑ§Ïπò Î™®Îã¨ -->
  <div class="build-modal" id="mine-place-modal">
    <div class="modal-header">
      <span class="title">üí£ ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ ÏÑ§Ïπò</span>
      <button class="close" id="close-mine-modal">√ó</button>
    </div>
    <div class="modal-content">
      <div style="padding:15px;background:#1a1a2e;border-radius:8px;margin-bottom:15px;">
        <div style="color:#fff;margin-bottom:10px;">üìç ÏÑ§Ïπò ÏúÑÏπò: (<span id="mine-target-x">0</span>, <span id="mine-target-y">0</span>)</div>
        <div style="color:#4a9;">üí∞ ÏÑ§Ïπò ÎπÑÏö©: 10,000Ïõê</div>
        <div style="color:#aaa;margin-top:5px;">Î≥¥Ïú† ÏûêÏõê: <span id="mine-player-resources">0</span>Ïõê</div>
      </div>
      
      <div style="display:flex;align-items:center;gap:10px;margin-bottom:15px;">
        <label style="color:#aaa;">ÏÑ§Ïπò ÏàòÎüâ:</label>
        <button class="quantity-btn" id="mine-qty-decrease">-</button>
        <input type="number" id="mine-quantity" value="1" min="1" style="width:60px;text-align:center;padding:5px;border-radius:4px;border:1px solid #444;background:#2a2a3e;color:#fff;">
        <button class="quantity-btn" id="mine-qty-increase">+</button>
        <button class="max-btn" id="mine-qty-max" style="padding:5px 10px;background:#4a9;border:none;border-radius:4px;color:#fff;cursor:pointer;">ÏµúÎåÄ</button>
      </div>
      
      <div style="display:flex;justify-content:space-between;margin-bottom:15px;">
        <span style="color:#f55;">Ï¥ù ÎπÑÏö©: <span id="mine-total-cost">10,000</span>Ïõê</span>
      </div>
      
      <button id="confirm-mine-place" style="width:100%;padding:12px;background:#c55;border:none;border-radius:8px;color:#fff;font-size:1em;cursor:pointer;">üí£ ÏßÄÎ¢∞ ÏÑ§Ïπò</button>
      
      <div style="margin-top:15px;padding:10px;background:#2a1a1a;border-radius:8px;border:1px solid #533;">
        <div style="color:#f99;font-size:0.9em;">‚ö†Ô∏è ÏßÄÎ¢∞ ÌäπÏÑ±</div>
        <div style="color:#aaa;font-size:0.85em;margin-top:5px;">‚Ä¢ ÏßÄÎ¢∞ 1Í∞úÎãπ ÌÉ±ÌÅ¨ 5ÎåÄ ÌååÍ¥¥</div>
        <div style="color:#aaa;font-size:0.85em;">‚Ä¢ Ï†ÅÏóêÍ≤å Î≥¥Ïù¥ÏßÄ ÏïäÏùå (ÏïÑÍµ∞Îßå ÌôïÏù∏ Í∞ÄÎä•)</div>
        <div style="color:#aaa;font-size:0.85em;">‚Ä¢ ÌÉ±ÌÅ¨/Ï∞®ÎüâÏù¥ ÏßÄÎÇòÍ∞ÄÎ©¥ Ìè≠Î∞ú</div>
        <div style="color:#aaa;font-size:0.85em;">‚Ä¢ Î≥¥Î≥ëÏóêÍ≤åÎäî ÏûëÎèôÌïòÏßÄ ÏïäÏùå</div>
      </div>
    </div>
  </div>

  <script>
    // ==================== Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÏÑ§Ï†ï ====================
    let socket = null;
    let isMultiplayer = false;
    let mySocketId = '';
    let opponentName = 'ÏÉÅÎåÄÎ∞©';
    let opponentId = '';
    let roomId = '';
    let isPlayer1 = false;  // player1Ïù¥ ÏÑ†Í≥µ
    let myName = 'ÌîåÎ†àÏù¥Ïñ¥_' + Math.random().toString(36).slice(2, 6);
    
    // ===== Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏ†ê Î≥ÄÌôò Ìï®Ïàò =====
    // player2Îäî ÎßµÏùÑ Îí§ÏßëÏñ¥ÏÑú Î≥¥Í≥†, ownerÎèÑ Î∞òÏ†ÑÌï¥ÏÑú ÌëúÏãú
    
    // Îç∞Ïù¥ÌÑ∞ YÏ¢åÌëú ‚Üí ÌôîÎ©¥ YÏ¢åÌëú
    function toViewY(dataY) {
      if (isMultiplayer && !isPlayer1) {
        return MAP_HEIGHT - 1 - dataY;
      }
      return dataY;
    }
    
    // ÌôîÎ©¥ YÏ¢åÌëú ‚Üí Îç∞Ïù¥ÌÑ∞ YÏ¢åÌëú
    function toDataY(viewY) {
      if (isMultiplayer && !isPlayer1) {
        return MAP_HEIGHT - 1 - viewY;
      }
      return viewY;
    }
    
    // Îç∞Ïù¥ÌÑ∞ XÏ¢åÌëú ‚Üí ÌôîÎ©¥ XÏ¢åÌëú
    function toViewX(dataX) {
      if (isMultiplayer && !isPlayer1) {
        return MAP_WIDTH - 1 - dataX;
      }
      return dataX;
    }
    
    // ÌôîÎ©¥ XÏ¢åÌëú ‚Üí Îç∞Ïù¥ÌÑ∞ XÏ¢åÌëú
    function toDataX(viewX) {
      if (isMultiplayer && !isPlayer1) {
        return MAP_WIDTH - 1 - viewX;
      }
      return viewX;
    }
    
    // owner ÌëúÏãú Î≥ÄÌôò (ÌôîÎ©¥Ïóê Î≥¥Ïó¨Ï§Ñ Îïå)
    function toDisplayOwner(dataOwner) {
      if (isMultiplayer && !isPlayer1) {
        return dataOwner === 'player' ? 'enemy' : 'player';
      }
      return dataOwner;
    }
    
    // ÎÇ¥ owner Í∞í (Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ÏÇ¨Ïö©)
    function getMyOwner() {
      if (isMultiplayer && !isPlayer1) {
        return 'enemy';  // player2Ïùò Ïú†Îãõ/Í±¥Î¨ºÏùÄ Îç∞Ïù¥ÌÑ∞ÏÉÅ 'enemy'
      }
      return 'player';
    }
    
    // ÏÉÅÎåÄ owner Í∞í
    function getOpponentOwner() {
      if (isMultiplayer && !isPlayer1) {
        return 'player';
      }
      return 'enemy';
    }
    
    // ÎÇ¥ Ïú†ÎãõÏù∏ÏßÄ ÌôïÏù∏
    function isMyUnit(unit) {
      return unit.owner === getMyOwner();
    }
    
    // ÎÇ¥ Í±¥Î¨ºÏù∏ÏßÄ ÌôïÏù∏
    function isMyBuilding(building) {
      return building.owner === getMyOwner();
    }
    
    // ÎÇ¥ ÏßÑÏòÅÏù∏ÏßÄ ÌôïÏù∏ (YÏ¢åÌëú Í∏∞Ï§Ä)
    function isMyZone(dataY) {
      if (isMultiplayer && !isPlayer1) {
        return dataY <= ENEMY_ZONE_END;  // player2Îäî Î∂ÅÏ™ΩÏù¥ ÏûêÍ∏∞ ÏßÑÏòÅ
      }
      return dataY >= PLAYER_ZONE_START;  // player1ÏùÄ ÎÇ®Ï™ΩÏù¥ ÏûêÍ∏∞ ÏßÑÏòÅ
    }
    
    // ÏïàÍ∞ú ÌëúÏãú Ïó¨Î∂Ä (Ï†Å ÏßÑÏòÅÏùÄ ÏïàÍ∞ú)
    function shouldShowFog(dataY, tile) {
      if (isMultiplayer && !isPlayer1) {
        // player2: ÎÇ®Ï™Ω(Ï†Å ÏßÑÏòÅ)Ïóê ÏïàÍ∞ú
        return dataY >= PLAYER_ZONE_START && !tile.visible;
      }
      // player1: Î∂ÅÏ™Ω(Ï†Å ÏßÑÏòÅ)Ïóê ÏïàÍ∞ú
      return dataY <= ENEMY_ZONE_END && !tile.visible;
    }
    
    // ===== Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏ†ê Î≥ÄÌôò Ìï®Ïàò ÎÅù =====
    
    // Socket.io Ïó∞Í≤∞ Ï¥àÍ∏∞Ìôî
    function initSocket() {
      if (socket) return;
      
      socket = io();
      
      socket.on('connect', () => {
        mySocketId = socket.id;
        console.log('‚úÖ ÏÑúÎ≤Ñ Ïó∞Í≤∞Îê®:', mySocketId);
        socket.emit('set_name', myName);
      });
      
      // Ï†ëÏÜçÏûê Ïàò
      socket.on('online_count', (count) => {
        const el = document.getElementById('online-count');
        if (el) el.textContent = count;
      });
      
      // Îß§Ïπ≠ ÎåÄÍ∏∞ Ï§ë
      socket.on('waiting_match', () => {
        document.getElementById('matching-status').style.display = 'block';
        document.getElementById('matching-status').textContent = '‚è≥ ÎåÄÍ∏∞Ïó¥ÏóêÏÑú ÏÉÅÎåÄÎ•º Í∏∞Îã§Î¶¨Îäî Ï§ë...';
      });
      
      // Î∞© ÏÉùÏÑ±Îê®
      socket.on('room_created', (data) => {
        document.getElementById('room-code-display').style.display = 'block';
        document.getElementById('room-code').textContent = data.roomCode;
        document.getElementById('create-room-option').style.display = 'none';
      });
      
      // Î∞© Ï∞∏Í∞Ä ÏóêÎü¨
      socket.on('join_error', (message) => {
        document.getElementById('pvp-error').style.display = 'block';
        document.getElementById('pvp-error').textContent = message;
      });
      
      // Îß§Ïπ≠ ÏôÑÎ£å!
      socket.on('match_found', (data) => {
        roomId = data.roomId;
        isPlayer1 = data.player1.id === mySocketId;
        
        if (isPlayer1) {
          opponentName = data.player2.name;
          opponentId = data.player2.id;
        } else {
          opponentName = data.player1.name;
          opponentId = data.player1.id;
        }
        
        document.getElementById('pvp-modal').style.display = 'none';
        document.getElementById('match-found-modal').style.display = 'block';
        document.getElementById('match-player1').textContent = isPlayer1 ? myName : opponentName;
        document.getElementById('match-player2').textContent = isPlayer1 ? opponentName : myName;
        
        // Ï§ÄÎπÑ Î≤ÑÌäº ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        document.getElementById('ready-btn').style.opacity = '1';
        document.getElementById('ready-btn').style.pointerEvents = 'auto';
        document.getElementById('ready-status').textContent = 'Ï§ÄÎπÑ ÎåÄÍ∏∞ Ï§ë...';
        document.getElementById('ready-status').style.color = '#aa5';
        
        console.log('üéÆ Îß§Ïπ≠ ÏôÑÎ£å!', data);
        console.log('üì¢ mySocketId:', mySocketId);
        console.log('üì¢ isPlayer1:', isPlayer1);
      });
      
      // ÏÉÅÎåÄÎ∞© Ï§ÄÎπÑ ÏôÑÎ£å
      socket.on('opponent_ready', () => {
        document.getElementById('ready-status').textContent = '‚úÖ ÏÉÅÎåÄÎ∞© Ï§ÄÎπÑ ÏôÑÎ£å!';
        document.getElementById('ready-status').style.color = '#4a9';
      });
      
      // Í≤åÏûÑ ÏãúÏûë!
      socket.on('game_start', (data) => {
        console.log('üéÆ Í≤åÏûÑ ÏãúÏûë!', data);
        document.getElementById('match-found-modal').style.display = 'none';
        isMultiplayer = true;
        
        // ÌîåÎ†àÏù¥Ïñ¥1Ïù¥ ÏÑ†Í≥µ
        const iAmFirst = data.player1Id === mySocketId;
        startMultiplayerGame(iAmFirst);
      });
      
      // ÏÉÅÎåÄÎ∞© Ïï°ÏÖò ÏàòÏã†
      socket.on('opponent_action', (action) => {
        console.log('üì• ÏÉÅÎåÄÎ∞© Ïï°ÏÖò:', action);
        handleOpponentAction(action);
      });
      
      // ÎÇ¥ ÌÑ¥ ÏãúÏûë
      socket.on('your_turn', (data) => {
        console.log('üîÑ ÎÇ¥ ÌÑ¥ ÏãúÏûë!', data);
        if (data.gameState) {
          applyOpponentGameState(data.gameState);
        }
        startMyTurn();
      });
      
      // Ï±ÑÌåÖ Î©îÏãúÏßÄ
      socket.on('chat_message', (data) => {
        addChatMessage(data.sender, data.message);
      });
      
      // ÏÉÅÎåÄÎ∞© Ìï≠Î≥µ
      socket.on('opponent_surrendered', (data) => {
        alert('üèÜ ÏäπÎ¶¨! ' + data.surrenderedPlayer + 'ÎãòÏù¥ Ìï≠Î≥µÌñàÏäµÎãàÎã§.');
        isMultiplayer = false;
        showScreen('lobby');
      });
      
      // ÏÉÅÎåÄÎ∞© Ïó∞Í≤∞ ÎÅäÍπÄ
      socket.on('opponent_disconnected', () => {
        if (isMultiplayer) {
          alert('‚ö†Ô∏è ÏÉÅÎåÄÎ∞©Ïùò Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§.');
          isMultiplayer = false;
          showScreen('lobby');
        }
      });
    }
    
    // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ ÏãúÏûë
    function startMultiplayerGame(iAmFirst) {
      // ÌôîÎ©¥ Ï†ÑÌôò
      showScreen('game');
      
      // Îßµ ÏÉùÏÑ±
      gameState.map = createMap();
      gameState.turnNumber = 1;
      gameState.isPlayerTurn = iAmFirst;
      currentMapView = 'ground';
      
      // ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÎ≥¥ ÏÑ§Ï†ï
      gameState.player = { name: myName };
      gameState.opponent = { name: opponentName };
      
      // ÏûêÏõê, Ïú†Îãõ, Í±¥Î¨º, Í∏∞ÏßÄ ÎÇ¥Íµ¨ÎèÑ Ï¥àÍ∏∞Ìôî
      gameState.resources.player = 1000;
      gameState.resources.enemy = 1000;  // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥Îäî ÎèôÏùº ÏûêÏõê
      gameState.units = [];
      gameState.buildings = [];
      gameState.landmines = [];
      gameState.capturedTiles = { player: [], enemy: [] };
      gameState.bases = {
        player: { main: BASE_HP.main_base, sub1: BASE_HP.sub_base, sub2: BASE_HP.sub_base },
        enemy: { main: BASE_HP.main_base, sub1: BASE_HP.sub_base, sub2: BASE_HP.sub_base }
      };
      
      // ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥† Ï¥àÍ∏∞Ìôî
      gameState.missiles.player = 0;
      gameState.missiles.enemy = 0;
      gameState.missileQueue.player = [];
      gameState.missileQueue.enemy = [];
      
      // player2Ïùò Í≤ΩÏö∞ visible ÏÉÅÌÉú Î∞òÏ†Ñ (Î∂ÅÏ™ΩÏù¥ ÏûêÍ∏∞ ÏßÑÏòÅ)
      if (!isPlayer1) {
        gameState.map.forEach((row, y) => {
          row.forEach((tile, x) => {
            // player2Îäî Î∂ÅÏ™Ω(y <= 11)Ïù¥ ÏûêÍ∏∞ ÏßÑÏòÅÏù¥ÎØÄÎ°ú visible
            // ÎÇ®Ï™Ω(y >= 18)Ïù¥ Ï†Å ÏßÑÏòÅÏù¥ÎØÄÎ°ú ÏïàÍ∞ú
            if (y <= ENEMY_ZONE_END) {
              tile.visible = true;  // Î∂ÅÏ™Ω Î≥¥ÏûÑ
            } else if (y >= PLAYER_ZONE_START) {
              tile.visible = false;  // ÎÇ®Ï™Ω ÏïàÍ∞ú
            }
          });
        });
      }
      
      // UI ÏóÖÎç∞Ïù¥Ìä∏
      document.getElementById('opponent-name-display').textContent = opponentName;
      document.getElementById('game-enemy-name').textContent = opponentName;
      document.getElementById('game-player-name').textContent = myName;
      
      // ÌÉ≠ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      document.querySelectorAll('.map-view-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === 'ground');
      });
      
      // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ UI ÌëúÏãú
      document.getElementById('mp-header').style.display = 'flex';
      document.getElementById('mp-chat-box').style.display = 'block';
      
      // Î°úÍ∑∏ Ï¥àÍ∏∞Ìôî
      document.getElementById('log-container').innerHTML = '';
      addLog('üéÆ Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Í≤åÏûÑ ÏãúÏûë!', 'system');
      addLog('Îßµ ÌÅ¨Í∏∞: ' + MAP_WIDTH + 'x' + MAP_HEIGHT, 'system');
      addLog('Ï¥àÍ∏∞ ÏûêÏõê: 1000', 'system');
      
      if (iAmFirst) {
        addLog('üü¢ ÎãπÏã†Ïù¥ ÏÑ†Í≥µÏûÖÎãàÎã§!', 'system');
        startTurnTimer();
      } else {
        addLog('üî¥ ÏÉÅÎåÄÎ∞©Ïù¥ ÏÑ†Í≥µÏûÖÎãàÎã§.', 'system');
        addLog('‚è≥ ÏÉÅÎåÄÎ∞©Ïùò ÌÑ¥ÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë...', 'system');
      }
      
      renderMap();
      updateResourceDisplay();
      updateMpTurnDisplay();
      
      // Ï¥àÍ∏∞ Îßµ ÏúÑÏπòÎ•º ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄÎ°ú Ïù¥Îèô
      setTimeout(() => {
        goToArea('player-main');
      }, 100);
    }
    
    // ÎÇ¥ ÌÑ¥ ÏãúÏûë (Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥)
    function startMyTurn() {
      gameState.isPlayerTurn = true;
      gameState.turnNumber++;
      
      const myOwner = getMyOwner();
      
      // Î™®Îì† ÏïÑÍµ∞ Ïú†Îãõ/Í±¥Î¨º ÌñâÎèô Ï¥àÍ∏∞Ìôî
      gameState.units.forEach(u => {
        if (u.owner === myOwner) u.moved = false;
      });
      gameState.buildings.forEach(b => {
        if (b.owner === myOwner) {
          b.fired = false;
          b.produced = false;
        }
      });
      
      // ÏûêÏõê ÏàòÏûÖ
      processIncome(myOwner);
      
      // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÏßÑÌñâ
      processMissileProduction(myOwner);
      
      // ÌÉÄÏù¥Î®∏ ÏãúÏûë
      startTurnTimer();
      
      addLog('üîÑ ÌÑ¥ ' + gameState.turnNumber + ' - ÎãπÏã†Ïùò ÌÑ¥ÏûÖÎãàÎã§!', 'system');
      updateMpTurnDisplay();
      renderMap();
      updateResourceDisplay();
    }
    
    // ÏûêÏõê ÏàòÏûÖ Ï≤òÎ¶¨
    function processIncome(owner) {
      let income = TURN_INCOME;
      gameState.buildings.forEach(b => {
        if (b.owner === owner) {
          income += getBuildingIncome(b);
        }
      });
      gameState.resources[owner] += income;
    }
    
    // ÏÉÅÎåÄÎ∞© Í≤åÏûÑ ÏÉÅÌÉú Ï†ÅÏö© (ÏÜåÏú†Ïûê Î∞òÏ†Ñ!)
    function applyOpponentGameState(state) {
      // ÏûêÏõê
      gameState.resources.enemy = state.resources.player;
      
      // Ïú†Îãõ (ÏÜåÏú†Ïûê Î∞òÏ†Ñ)
      gameState.units = state.units.map(u => ({
        ...u,
        owner: u.owner === 'player' ? 'enemy' : 'player'
      }));
      
      // Í±¥Î¨º (ÏÜåÏú†Ïûê Î∞òÏ†Ñ)
      gameState.buildings = state.buildings.map(b => ({
        ...b,
        owner: b.owner === 'player' ? 'enemy' : 'player'
      }));
      
      // Í∏∞ÏßÄ HP (Î∞òÏ†Ñ)
      gameState.bases.enemy = { ...state.bases.player };
      gameState.bases.player = { ...state.bases.enemy };
      
      // Ï†êÎ†πÎêú ÌÉÄÏùº (Î∞òÏ†Ñ)
      gameState.capturedTiles.enemy = [...(state.capturedTiles.player || [])];
      gameState.capturedTiles.player = [...(state.capturedTiles.enemy || [])];
      
      // ÎØ∏ÏÇ¨Ïùº
      gameState.missiles.enemy = state.missiles.player;
      
      renderMap();
      updateResourceDisplay();
    }
    
    // ÏÉÅÎåÄÎ∞© Ïï°ÏÖò Ï≤òÎ¶¨
    function handleOpponentAction(action) {
      switch(action.type) {
        case 'move':
          const unit = gameState.units.find(u => u.id === action.unitId);
          if (unit) {
            unit.x = action.toX;
            unit.y = action.toY;
            unit.moved = true;
          }
          break;
      }
      renderMap();
    }
    
    // ÎÇ¥ Ïï°ÏÖòÏùÑ ÏÉÅÎåÄÎ∞©ÏóêÍ≤å Ï†ÑÏÜ°
    function sendAction(action) {
      if (isMultiplayer && socket) {
        socket.emit('game_action', action);
      }
    }
    
    // ÌÑ¥ Ï¢ÖÎ£å (Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥)
    function endMultiplayerTurn() {
      if (!isMultiplayer) return;
      
      gameState.isPlayerTurn = false;
      stopTurnTimer();
      
      // Í≤åÏûÑ ÏÉÅÌÉúÎ•º ÏÉÅÎåÄÎ∞©ÏóêÍ≤å Ï†ÑÏÜ°
      const stateToSend = {
        resources: gameState.resources,
        units: gameState.units,
        buildings: gameState.buildings,
        bases: gameState.bases,
        capturedTiles: gameState.capturedTiles,
        missiles: gameState.missiles,
        turnNumber: gameState.turnNumber
      };
      
      socket.emit('end_turn', stateToSend);
      
      addLog('‚è≥ ÏÉÅÎåÄÎ∞©Ïùò ÌÑ¥ÏùÑ Í∏∞Îã§Î¶¨Îäî Ï§ë...', 'system');
      updateMpTurnDisplay();
      renderMap();
    }
    
    // Ï±ÑÌåÖ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
    function addChatMessage(sender, message) {
      const chatMessages = document.getElementById('mp-chat-messages');
      if (!chatMessages) return;
      
      const msgEl = document.createElement('div');
      msgEl.style.marginBottom = '5px';
      msgEl.innerHTML = '<span style="color:#8fa85a;">' + sender + ':</span> ' + message;
      chatMessages.appendChild(msgEl);
      chatMessages.scrollTop = chatMessages.scrollHeight;
    }
    
    // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÌÑ¥ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    function updateMpTurnDisplay() {
      const turnDisplay = document.getElementById('turn-display');
      if (turnDisplay) {
        if (gameState.isPlayerTurn) {
          turnDisplay.textContent = 'üü¢ ÎÇ¥ ÌÑ¥';
          turnDisplay.style.color = '#4a9';
        } else {
          turnDisplay.textContent = 'üî¥ ÏÉÅÎåÄ ÌÑ¥';
          turnDisplay.style.color = '#f77';
        }
      }
    }
    
    // ÌÉÄÏù¥Î®∏ Ï†ïÏßÄ
    function stopTurnTimer() {
      if (gameState.turnInterval) {
        clearInterval(gameState.turnInterval);
        gameState.turnInterval = null;
      }
    }
    
    // ==================== Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÏÑ§Ï†ï ÎÅù ====================
    
    // Í≤åÏûÑ ÏÉÅÏàò
    const MAP_WIDTH = 40;
    const MAP_HEIGHT = 30;
    const TURN_TIME_LIMIT = 180;
    const TURN_INCOME = 1000; // ÌÑ¥Îãπ ÏûêÏõê ÏàòÏûÖ
    
    // ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ ÏÑ§Ï†ï
    const MINE_COST = 10000;  // ÏßÄÎ¢∞ 1Í∞ú ÎπÑÏö©
    const MINE_DAMAGE = 5;    // ÏßÄÎ¢∞ 1Í∞úÎãπ ÌÉ±ÌÅ¨ ÌååÍ¥¥ Ïàò
    
    // Îßµ Íµ¨Ïó≠ ÏÑ§Ï†ï (40x30 - 4Í∞ú ÏÑ¨ + Ïã≠ÏûêÍ∞Ä Î∞îÎã§)
    // ÏÑ¨ ÏòÅÏó≠ Ï†ïÏùò
    const ISLAND = {
      // Ï¢åÏÉÅÎã® ÏÑ¨ (Ï†Å Î≥∏Í∏∞ÏßÄ + Î∂ÄÍ∏∞ÏßÄ1)
      ENEMY_LEFT: { x1: 0, x2: 14, y1: 0, y2: 11 },
      // Ïö∞ÏÉÅÎã® ÏÑ¨ (Ï†Å Î∂ÄÍ∏∞ÏßÄ2 + Íµ∞Ìï≠)
      ENEMY_RIGHT: { x1: 25, x2: 39, y1: 0, y2: 11 },
      // Ï¢åÌïòÎã® ÏÑ¨ (ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄ2 + Íµ∞Ìï≠)
      PLAYER_LEFT: { x1: 0, x2: 14, y1: 18, y2: 29 },
      // Ïö∞ÌïòÎã® ÏÑ¨ (ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄ + Î∂ÄÍ∏∞ÏßÄ1)
      PLAYER_RIGHT: { x1: 25, x2: 39, y1: 18, y2: 29 }
    };
    
    // Î∞îÎã§ ÏòÅÏó≠ Ï†ïÏùò
    const SEA = {
      // ÏÑ∏Î°ú Î∞îÎã§ (Ï§ëÏïô)
      VERTICAL: { x1: 15, x2: 24, y1: 0, y2: 29 },
      // Í∞ÄÎ°ú Î∞îÎã§ (Ï§ëÏïô)
      HORIZONTAL: { x1: 0, x2: 39, y1: 12, y2: 17 }
    };
    
    // ÌîåÎ†àÏù¥Ïñ¥ ÏòÅÏó≠ (y >= 18)
    const PLAYER_ZONE_START = 18;
    // Ï†Å ÏòÅÏó≠ (y <= 11)
    const ENEMY_ZONE_END = 11;
    // ÏãúÏïº ÏÑ§Ï†ï (Î∞îÎã§ + ÏïÑÍµ∞ ÏòÅÏó≠Îßå Î≥¥ÏûÑ)
    const VISIBLE_FROM_ROW = 12;
    
    // ÌòÑÏû¨ Îßµ Î∑∞ Î™®Îìú ('ground' ÎòêÎäî 'air')
    let currentMapView = 'ground';
    
    // Ï§å ÏÑ§Ï†ï
    const ZOOM_LEVELS = [50, 75, 100, 125, 150, 200];
    let currentZoomIndex = 2; // 100%Í∞Ä Í∏∞Î≥∏
    const BASE_TILE_SIZE = 28;
    
    // Ï§å Ïù∏
    function zoomIn() {
      if (currentZoomIndex < ZOOM_LEVELS.length - 1) {
        currentZoomIndex++;
        applyZoom();
      }
    }
    
    // Ï§å ÏïÑÏõÉ
    function zoomOut() {
      if (currentZoomIndex > 0) {
        currentZoomIndex--;
        applyZoom();
      }
    }
    
    // Ï§å Ï†ÅÏö©
    function applyZoom() {
      const zoomPercent = ZOOM_LEVELS[currentZoomIndex];
      const tileSize = Math.floor(BASE_TILE_SIZE * zoomPercent / 100);
      const fontSize = Math.max(0.5, 0.75 * zoomPercent / 100);
      
      // CSS Î≥ÄÏàòÎ°ú ÌÉÄÏùº ÌÅ¨Í∏∞ Ï†ÅÏö©
      document.documentElement.style.setProperty('--tile-size', tileSize + 'px');
      document.documentElement.style.setProperty('--tile-font-size', fontSize + 'rem');
      
      // Ï§å Î†àÎ≤® ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
      const zoomLevelEl = document.getElementById('zoom-level');
      if (zoomLevelEl) {
        zoomLevelEl.textContent = zoomPercent + '%';
      }
      
      // Îßµ Îã§Ïãú Î†åÎçîÎßÅ
      renderMap();
    }
    
    // Í±¥Î¨º Ï†ïÏùò
    const BUILDINGS = {
      barracks: {
        id: 'barracks',
        name: 'ÏßïÎ≥ëÏÜå',
        icon: 'üèõÔ∏è',
        cost: 500,
        hp: 5000,
        income: 0,
        description: 'Î≥ëÏÇ¨Î•º ÏßïÎ≥ëÌï† Ïàò ÏûàÎäî Í±¥Î¨º',
        upgradable: false
      },
      city: {
        id: 'city',
        name: 'ÎèÑÏãú',
        icon: 'üèôÔ∏è',
        cost: 100000,
        hp: 15000,
        income: 200000,
        description: 'ÌÑ¥Îãπ 20Îßå ÏûêÏõê (Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö©)',
        upgradable: true,
        maxLevel: 3,
        upgradeType: 'income',
        levelStats: {
          1: { income: 200000, upgradeCost: 0 },
          2: { income: 400000, upgradeCost: 200000 },
          3: { income: 2000000, upgradeCost: 1000000 }
        }
      },
      bridge: {
        id: 'bridge',
        name: 'Îã§Î¶¨',
        icon: 'üåâ',
        cost: 300,
        hp: 2000,
        income: 0,
        description: 'Í∞ïÏùÑ Í±¥ÎÑê Ïàò ÏûàÎäî Îã§Î¶¨ (Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö©)',
        upgradable: false
      },
      farm: {
        id: 'farm',
        name: 'ÎÜçÏû•',
        icon: 'üåæ',
        cost: 300,
        hp: 1500,
        income: 600,
        description: 'ÌÑ¥Îãπ 600 ÏûêÏõê ÏÉùÏÇ∞ (ÎÜçÎ∂Ä Ï†ÑÏö©)',
        upgradable: true,
        maxLevel: 3,
        upgradeType: 'income',  // ÏàòÏûÖ Ï¶ùÍ∞Ä
        levelStats: {
          1: { income: 600 },
          2: { income: 1200 },
          3: { income: 2400 }
        }
      },
      greenhouse: {
        id: 'greenhouse',
        name: 'Ïò®Ïã§',
        icon: 'üè°',
        cost: 1000,
        hp: 3000,
        income: 3000,
        description: 'ÌÑ¥Îãπ 3000 ÏûêÏõê ÏÉùÏÇ∞ (ÎÜçÎ∂Ä Ï†ÑÏö©)',
        upgradable: true,
        maxLevel: 3,
        upgradeType: 'income',
        levelStats: {
          1: { income: 3000 },
          2: { income: 6000 },
          3: { income: 12000 }
        }
      },
      mortar: {
        id: 'mortar',
        name: 'Î∞ïÍ≤©Ìè¨',
        icon: 'üí£',
        cost: 50000,
        hp: 8000,
        income: 0,
        fireCost: 5000,
        attackRange: 5,
        damage: 10000,
        description: '5Ïπ∏ ÏÇ¨Í±∞Î¶¨, 10000 ÌîºÌï¥ (Î∞úÏÇ¨ÎπÑÏö© 5000)',
        upgradable: true,
        maxLevel: 3,
        upgradeType: 'range',  // ÏÇ¨Í±∞Î¶¨ Ï¶ùÍ∞Ä
        levelStats: {
          1: { attackRange: 5 },
          2: { attackRange: 7 },
          3: { attackRange: 10 }
        }
      },
      runway: {
        id: 'runway',
        name: 'ÌôúÏ£ºÎ°ú',
        icon: 'üõ´',
        cost: 30000,
        hp: 10000,
        income: 0,
        description: 'ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Í∞ÄÎä•',
        upgradable: false
      },
      arms_factory: {
        id: 'arms_factory',
        name: 'Íµ∞Ïàò Í≥µÏû•',
        icon: 'üè≠',
        cost: 50000,
        hp: 10000,
        income: 0,
        description: 'ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ (10ÎßåÏõê, 3ÌÑ¥)',
        upgradable: true,
        maxLevel: 3,
        upgradeType: 'production',  // ÏÉùÏÇ∞ ÏãúÍ∞Ñ Í∞êÏÜå
        levelStats: {
          1: { buildTurns: 3 },
          2: { buildTurns: 2 },
          3: { buildTurns: 1 }
        }
      },
      missile_silo: {
        id: 'missile_silo',
        name: 'ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ÎåÄ',
        icon: 'üöÄ',
        cost: 100000,
        hp: 5000,
        income: 0,
        launchCost: 50000,
        attackRange: 20,
        damage: 100000,
        description: 'ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ (5ÎßåÏõê, 20Ïπ∏, 10Îßå ÌîºÌï¥)',
        upgradable: true,
        maxLevel: 3,
        upgradeType: 'range',
        levelStats: {
          1: { attackRange: 20 },
          2: { attackRange: 25 },
          3: { attackRange: 30 }
        }
      }
    };
    
    // ÏóÖÍ∑∏Î†àÏù¥Îìú ÎπÑÏö© Í≥ÑÏÇ∞ (Í∏∞Î≥∏ ÎπÑÏö©Ïùò 2Î∞∞, 4Î∞∞)
    function getUpgradeCost(buildingType, currentLevel) {
      const buildingDef = BUILDINGS[buildingType];
      
      // levelStatsÏóê upgradeCostÍ∞Ä Ï†ïÏùòÎêòÏñ¥ ÏûàÏúºÎ©¥ ÏÇ¨Ïö© (ÎèÑÏãú Îì±)
      if (buildingDef.levelStats) {
        const nextLevel = currentLevel + 1;
        if (buildingDef.levelStats[nextLevel] && buildingDef.levelStats[nextLevel].upgradeCost !== undefined) {
          return buildingDef.levelStats[nextLevel].upgradeCost;
        }
      }
      
      // Í∏∞Î≥∏ ÏóÖÍ∑∏Î†àÏù¥Îìú ÎπÑÏö© (Í±¥ÏÑ§ ÎπÑÏö©Ïùò Î∞∞Ïàò)
      const baseCost = buildingDef.cost;
      if (currentLevel === 1) return baseCost * 2;
      if (currentLevel === 2) return baseCost * 4;
      return 0;
    }
    
    // Í∏∞ÏßÄ ÎÇ¥Íµ¨ÎèÑ Ï†ïÏùò
    const BASE_HP = {
      main_base: 1000000,  // 100Îßå
      sub_base: 500000     // 50Îßå
    };
    
    // ÎØ∏ÏÇ¨Ïùº ÏãúÏä§ÌÖú
    const MISSILE_COST = 100000;      // ÎØ∏ÏÇ¨Ïùº Ï†úÏûë ÎπÑÏö©
    const MISSILE_BUILD_TURNS = 3;    // ÎØ∏ÏÇ¨Ïùº Ï†úÏûë ÌÑ¥ Ïàò
    
    // Ïú†Îãõ Ï†ïÏùò
    const UNITS = {
      soldier: {
        id: 'soldier',
        name: 'ÏùºÎ∞ò Î≥ëÏÇ¨',
        icon: 'üéñÔ∏è',
        cost: 100,
        attack: 10,
        defense: 5,
        hp: 100,
        maxHp: 100,
        moveRange: 2,
        attackRange: 2,
        description: 'Í∏∞Î≥∏ Î≥¥Î≥ë Ïú†Îãõ',
        isDefault: true,
        damagePercent: 10
      },
      engineer: {
        id: 'engineer',
        name: 'Í±¥Ï∂ïÍ∞Ä',
        icon: 'üë∑',
        cost: 150,
        attack: 2,
        defense: 3,
        hp: 50,
        maxHp: 50,
        moveRange: 2,
        attackRange: 0,
        description: 'Í±¥Î¨ºÏùÑ Í±¥ÏÑ§Ìï† Ïàò ÏûàÎäî Ïú†Îãõ',
        isDefault: true,
        canBuild: true
      },
      scout: {
        id: 'scout',
        name: 'Ï†ïÏ∞∞Î≥ë',
        icon: 'üî≠',
        cost: 120,
        attack: 5,
        defense: 3,
        hp: 60,
        maxHp: 60,
        moveRange: 3,
        attackRange: 1,
        description: 'ÏïàÍ∞ú ÏßÄÏó≠ÏùÑ Ï†ïÏ∞∞Ìï† Ïàò ÏûàÎäî Ïú†Îãõ',
        isDefault: true,
        canScout: true
      },
      farmer: {
        id: 'farmer',
        name: 'ÎÜçÎ∂Ä',
        icon: 'üë®‚Äçüåæ',
        cost: 100,
        attack: 1,
        defense: 2,
        hp: 40,
        maxHp: 40,
        moveRange: 2,
        attackRange: 0,
        description: 'ÎÜçÏû•Í≥º Ïò®Ïã§ÏùÑ Í±¥ÏÑ§ÌïòÎäî Ïú†Îãõ',
        isDefault: true,
        canFarm: true
      },
      commando: {
        id: 'commando',
        name: 'ÌäπÍ≥µÎåÄ',
        icon: 'üéØ',
        cost: 1000,
        attack: 30,
        defense: 8,
        hp: 150,
        maxHp: 150,
        moveRange: 2,
        attackRange: 2,
        description: 'Î≥ëÎ†•Ïùò 30% ÌîºÌï¥Î•º Ï£ºÎäî Ï†ïÏòà Ïú†Îãõ',
        isDefault: true,
        damagePercent: 30
      },
      military_engineer: {
        id: 'military_engineer',
        name: 'Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞Ä',
        icon: 'üîß',
        cost: 500,
        attack: 3,
        defense: 4,
        hp: 80,
        maxHp: 80,
        moveRange: 2,
        attackRange: 0,
        description: 'Î∞ïÍ≤©Ìè¨, ÌôúÏ£ºÎ°ú Îì± Íµ∞ÏÇ¨ ÏãúÏÑ§ÏùÑ Í±¥ÏÑ§',
        isDefault: true,
        canMilitaryBuild: true
      },
      recon_plane: {
        id: 'recon_plane',
        name: 'Ï†ïÏ∞∞Í∏∞',
        icon: '‚úàÔ∏è',
        cost: 8000,
        attack: 0,
        defense: 2,
        hp: 100,
        maxHp: 100,
        moveRange: 5,
        attackRange: 0,
        description: 'Ï†Å ÏßÑÏòÅ ÏßÑÏûÖ Ïãú Î™®Îì† ÏïàÍ∞ú Ï†úÍ±∞',
        isDefault: false,
        isAirUnit: true,
        canRevealAll: true
      },
      attack_ship: {
        id: 'attack_ship',
        name: 'Ï†ÑÌï®',
        icon: 'üö¢',
        cost: 3000,
        attack: 50,
        defense: 10,
        hp: 300,
        maxHp: 300,
        moveRange: 5,
        attackRange: 3,
        description: 'Î∞îÎã§ÏóêÏÑú Ïù¥ÎèôÌïòÎ©∞ Ï†Å Ìï≠Íµ¨Î•º Í≥µÍ≤©',
        isDefault: false,
        isNavalUnit: true,
        canAttackHarbor: true,
        damageToHarbor: 3000
      },
      missile_cruiser: {
        id: 'missile_cruiser',
        name: 'ÎØ∏ÏÇ¨Ïùº ÏàúÏñëÌï®',
        icon: 'üõ≥Ô∏è',
        cost: 5000,
        attack: 80,
        defense: 15,
        hp: 400,
        maxHp: 400,
        moveRange: 4,
        attackRange: 10,
        description: 'Ïû•Í±∞Î¶¨ ÎØ∏ÏÇ¨ÏùºÎ°ú Î∞îÎã§Ïùò Ï†Å Ìï®ÏÑ†ÏùÑ Í≥µÍ≤©',
        isDefault: false,
        isNavalUnit: true,
        canAttackShip: true,
        damageToShip: 150
      },
      transport_ship: {
        id: 'transport_ship',
        name: 'ÏàòÏÜ°Ìï®',
        icon: '‚õ¥Ô∏è',
        cost: 2000,
        attack: 0,
        defense: 5,
        hp: 200,
        maxHp: 200,
        moveRange: 4,
        attackRange: 0,
        description: 'Ïú†Îãõ 2Í∞úÎ•º ÏàòÏÜ°ÌïòÏó¨ Ï†Å Ìï¥ÏïàÏóê ÏÉÅÎ•ô',
        isDefault: false,
        isNavalUnit: true,
        canTransport: true,
        transportCapacity: 2
      },
      bomber: {
        id: 'bomber',
        name: 'Ìè≠Í≤©Í∏∞',
        icon: 'üí£',
        cost: 15000,
        attack: 100,
        defense: 5,
        hp: 150,
        maxHp: 150,
        moveRange: 6,
        attackRange: 0,
        description: 'Ï†Å Ïú°ÏßÄÏóê 2Îßå Îç∞ÎØ∏ÏßÄ Ìè≠Í≤©',
        isDefault: false,
        isAirUnit: true,
        canBomb: true,
        bombDamage: 20000
      },
      // === ÌÉ±ÌÅ¨ Ïú†Îãõ ===
      tank_basic: {
        id: 'tank_basic',
        name: 'Í∏∞Î≥∏ ÌÉ±ÌÅ¨',
        icon: 'üöú',
        cost: 10000,
        attack: 5000,
        defense: 50,
        hp: 1000,
        maxHp: 1000,
        moveRange: 2,
        attackRange: 3,
        description: 'Í∞ïÎ†•Ìïú ÌôîÎ†•Ïùò Í∏∞Í∞ë Ïú†Îãõ (Íµ¨Ï°∞Î¨º 5Î∞∞ ÌîºÌï¥)',
        isDefault: false,
        isTank: true,
        tankDamage: 5000,
        tankHp: 1000,
        structureMultiplier: 5
      },
      tank_medium: {
        id: 'tank_medium',
        name: 'Ï§ëÍ∏â ÌÉ±ÌÅ¨',
        icon: 'üõ°Ô∏èüöú',
        cost: 20000,
        attack: 7000,
        defense: 80,
        hp: 3000,
        maxHp: 3000,
        moveRange: 3,
        attackRange: 4,
        description: 'Í∞ïÌôîÎêú Ïû•Í∞ëÍ≥º ÌôîÎ†• (Íµ¨Ï°∞Î¨º 5Î∞∞ ÌîºÌï¥)',
        isDefault: false,
        isTank: true,
        tankDamage: 7000,
        tankHp: 3000,
        structureMultiplier: 5
      },
      tank_advanced: {
        id: 'tank_advanced',
        name: 'Í≥†Í∏â ÌÉ±ÌÅ¨',
        icon: '‚≠êüöú',
        cost: 50000,
        attack: 10000,
        defense: 120,
        hp: 5000,
        maxHp: 5000,
        moveRange: 5,
        attackRange: 5,
        description: 'ÏµúÍ∞ïÏùò Ï£ºÎ†• Ï†ÑÏ∞® (Íµ¨Ï°∞Î¨º 5Î∞∞ ÌîºÌï¥)',
        isDefault: false,
        isTank: true,
        tankDamage: 10000,
        tankHp: 5000,
        structureMultiplier: 5
      },
      // === ÎåÄÏ†ÑÏ∞® Ïú†Îãõ ===
      anti_tank: {
        id: 'anti_tank',
        name: 'ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë',
        icon: 'üöÄ',
        cost: 2000,  // 100Î™ÖÎãπ 2000Ïõê
        attack: 20,
        defense: 4,
        hp: 80,
        maxHp: 80,
        moveRange: 2,
        attackRange: 3,
        description: 'ÌÉ±ÌÅ¨Ïóê Í∞ïÌïú Î°úÏºìÎ≥ë (ÏßÄÎ¢∞ ÏÑ§Ïπò Í∞ÄÎä•)',
        isDefault: true,
        damagePercent: 10,  // ÏùºÎ∞ò Ïú†Îãõ ÏÉÅÎåÄ ÌîºÌï¥
        antiTankDamage: 20, // 1Î™ÖÎãπ ÌÉ±ÌÅ¨Ïóê 20 Îç∞ÎØ∏ÏßÄ (100Î™Ö = 2000)
        canPlaceMine: true
      }
    };
    
    // Í≤åÏûÑ ÏÉÅÌÉú
    let gameState = {
      player: null,
      opponent: null,
      map: [],
      isPlayerTurn: true,
      turnNumber: 1,
      turnTimeLeft: TURN_TIME_LIMIT,
      selectedTile: null,
      matchingInterval: null,
      turnInterval: null,
      matchingTime: 0,
      currency: {
        gold: 10000,
        gems: 100
      },
      // Í≤åÏûÑ ÎÇ¥ ÏûêÏõê
      resources: {
        player: 1000,
        enemy: 1000
      },
      // Ïú†Îãõ Î™©Î°ù
      units: [],
      // Í±¥Î¨º Î™©Î°ù
      buildings: [],
      // ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ Î™©Î°ù
      landmines: [],
      // Ï†êÎ†πÎêú ÌÉÄÏùº Î™©Î°ù
      capturedTiles: {
        player: [],  // [{x, y}, ...]
        enemy: []
      },
      // Í∏∞ÏßÄ ÎÇ¥Íµ¨ÎèÑ
      bases: {
        player: { main: 1000000, sub1: 500000, sub2: 500000 },
        enemy: { main: 1000000, sub1: 500000, sub2: 500000 }
      },
      // ÎØ∏ÏÇ¨Ïùº ÏãúÏä§ÌÖú
      missiles: {
        player: 0,  // ÏôÑÏÑ±Îêú ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥†
        enemy: 0
      },
      missileQueue: {
        player: [],  // [{turnsLeft: 3}, {turnsLeft: 2}, ...]
        enemy: []
      }
    };
    
    // DOM ÏöîÏÜå
    const screens = {
      login: document.getElementById('login-screen'),
      lobby: document.getElementById('lobby-screen'),
      matching: document.getElementById('matching-screen'),
      game: document.getElementById('game-screen')
    };
    
    // ÌôîÎ©¥ Ï†ÑÌôò
    function showScreen(screenName) {
      Object.values(screens).forEach(screen => screen.classList.remove('active'));
      screens[screenName].classList.add('active');
      
      // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ UI ÌëúÏãú/Ïà®Í∏∞Í∏∞
      const mpHeader = document.getElementById('mp-header');
      const mpChatBox = document.getElementById('mp-chat-box');
      
      if (screenName === 'game' && isMultiplayer) {
        if (mpHeader) mpHeader.style.display = 'flex';
        if (mpChatBox) mpChatBox.style.display = 'block';
      } else {
        if (mpHeader) mpHeader.style.display = 'none';
        if (mpChatBox) mpChatBox.style.display = 'none';
      }
      
      // Î°úÎπÑÎ°ú ÎèåÏïÑÍ∞à Îïå Î™®Îã¨ Ïà®Í∏∞Í∏∞
      if (screenName === 'lobby') {
        const modals = ['pvp-modal', 'match-found-modal', 'ai-select-modal'];
        modals.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
      }
    }
    
    // ÌÉ≠ Ï†ÑÌôò
    function switchTab(tabId) {
      document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
      
      document.getElementById(tabId).classList.add('active');
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
    }
    
    // Îßµ Ï¥àÍ∏∞Ìôî (4Í∞ú ÏÑ¨ + Ïã≠ÏûêÍ∞Ä Î∞îÎã§)
    function createMap() {
      const map = [];
      
      for (let y = 0; y < MAP_HEIGHT; y++) {
        const row = [];
        for (let x = 0; x < MAP_WIDTH; x++) {
          let type = 'empty';
          let terrain = 'land'; // 'land' ÎòêÎäî 'sea'
          let owner = null;
          let harborHp = null; // Ìï≠Íµ¨ ÎÇ¥Íµ¨ÎèÑ
          
          // Î∞îÎã§ ÏòÅÏó≠ Ï≤¥ÌÅ¨ (Ïã≠ÏûêÍ∞Ä Î™®Ïñë)
          const isVerticalSea = x >= SEA.VERTICAL.x1 && x <= SEA.VERTICAL.x2;
          const isHorizontalSea = y >= SEA.HORIZONTAL.y1 && y <= SEA.HORIZONTAL.y2;
          const isSea = isVerticalSea || isHorizontalSea;
          
          if (isSea) {
            type = 'sea';
            terrain = 'sea';
          }
          
          // ÏãúÏïº ÏÑ§Ï†ï: Î∞îÎã§Îäî Ìï≠ÏÉÅ Î≥¥ÏûÑ, Ïú°ÏßÄÎäî ÏïÑÍµ∞ ÏòÅÏó≠Îßå Î≥¥ÏûÑ
          let visible = isSea || y >= VISIBLE_FROM_ROW;
          
          // === Ï†Å Ï¢åÏÉÅÎã® ÏÑ¨ (Î≥∏Í∏∞ÏßÄ + Î∂ÄÍ∏∞ÏßÄ1) ===
          if (x >= ISLAND.ENEMY_LEFT.x1 && x <= ISLAND.ENEMY_LEFT.x2 && 
              y >= ISLAND.ENEMY_LEFT.y1 && y <= ISLAND.ENEMY_LEFT.y2) {
            // Ï†Å Î≥∏Í∏∞ÏßÄ (Ï§ëÏïô ÏÉÅÎã®)
            if (y === 1 && x === 7) {
              type = 'main_base';
              owner = 'enemy';
            }
            // Ï†Å Î∂ÄÍ∏∞ÏßÄ1 (Î≥∏Í∏∞ÏßÄ ÏïÑÎûò ÏôºÏ™Ω)
            else if (y === 3 && x === 4) {
              type = 'sub_base';
              owner = 'enemy';
            }
          }
          
          // === Ï†Å Ïö∞ÏÉÅÎã® ÏÑ¨ (Î∂ÄÍ∏∞ÏßÄ2 + Íµ∞Ìï≠) ===
          if (x >= ISLAND.ENEMY_RIGHT.x1 && x <= ISLAND.ENEMY_RIGHT.x2 && 
              y >= ISLAND.ENEMY_RIGHT.y1 && y <= ISLAND.ENEMY_RIGHT.y2) {
            // Ï†Å Î∂ÄÍ∏∞ÏßÄ2
            if (y === 3 && x === 32) {
              type = 'sub_base';
              owner = 'enemy';
            }
            // Ï†Å Íµ∞Ìï≠ (Ìï¥ÏïàÍ∞Ä)
            else if (y === 5 && x === 25) {
              type = 'harbor';
              owner = 'enemy';
              harborHp = 10000;
            }
          }
          
          // === ÏïÑÍµ∞ Ï¢åÌïòÎã® ÏÑ¨ (Î∂ÄÍ∏∞ÏßÄ2 + Íµ∞Ìï≠) ===
          if (x >= ISLAND.PLAYER_LEFT.x1 && x <= ISLAND.PLAYER_LEFT.x2 && 
              y >= ISLAND.PLAYER_LEFT.y1 && y <= ISLAND.PLAYER_LEFT.y2) {
            // ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄ2
            if (y === 26 && x === 4) {
              type = 'sub_base';
              owner = 'player';
            }
            // ÏïÑÍµ∞ Íµ∞Ìï≠ (Ìï¥ÏïàÍ∞Ä)
            else if (y === 24 && x === 14) {
              type = 'harbor';
              owner = 'player';
              harborHp = 10000;
            }
          }
          
          // === ÏïÑÍµ∞ Ïö∞ÌïòÎã® ÏÑ¨ (Î≥∏Í∏∞ÏßÄ + Î∂ÄÍ∏∞ÏßÄ1) ===
          if (x >= ISLAND.PLAYER_RIGHT.x1 && x <= ISLAND.PLAYER_RIGHT.x2 && 
              y >= ISLAND.PLAYER_RIGHT.y1 && y <= ISLAND.PLAYER_RIGHT.y2) {
            // ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄ (Ï§ëÏïô ÌïòÎã®)
            if (y === 28 && x === 32) {
              type = 'main_base';
              owner = 'player';
            }
            // ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄ1 (Î≥∏Í∏∞ÏßÄ ÏúÑ Ïò§Î•∏Ï™Ω)
            else if (y === 26 && x === 35) {
              type = 'sub_base';
              owner = 'player';
            }
          }
          
          row.push({ x, y, type, terrain, owner, visible, harborHp });
        }
        map.push(row);
      }
      return map;
    }
    
    // ÌÉÄÏùºÏù¥ ÏÑ¨(Ïú°ÏßÄ)Ïù∏ÏßÄ ÌôïÏù∏
    function isLandTile(x, y) {
      const isVerticalSea = x >= SEA.VERTICAL.x1 && x <= SEA.VERTICAL.x2;
      const isHorizontalSea = y >= SEA.HORIZONTAL.y1 && y <= SEA.HORIZONTAL.y2;
      return !isVerticalSea && !isHorizontalSea;
    }
    
    // ÌÉÄÏùºÏù¥ Î∞îÎã§Ïù∏ÏßÄ ÌôïÏù∏
    function isSeaTile(x, y) {
      return !isLandTile(x, y);
    }
    
    // ÌÉÄÏùºÏù¥ Ïñ¥Îäê ÏÑ¨Ïóê ÏÜçÌïòÎäîÏßÄ ÌôïÏù∏
    function getIslandAt(x, y) {
      if (x >= ISLAND.ENEMY_LEFT.x1 && x <= ISLAND.ENEMY_LEFT.x2 && 
          y >= ISLAND.ENEMY_LEFT.y1 && y <= ISLAND.ENEMY_LEFT.y2) {
        return 'enemy_left';
      }
      if (x >= ISLAND.ENEMY_RIGHT.x1 && x <= ISLAND.ENEMY_RIGHT.x2 && 
          y >= ISLAND.ENEMY_RIGHT.y1 && y <= ISLAND.ENEMY_RIGHT.y2) {
        return 'enemy_right';
      }
      if (x >= ISLAND.PLAYER_LEFT.x1 && x <= ISLAND.PLAYER_LEFT.x2 && 
          y >= ISLAND.PLAYER_LEFT.y1 && y <= ISLAND.PLAYER_LEFT.y2) {
        return 'player_left';
      }
      if (x >= ISLAND.PLAYER_RIGHT.x1 && x <= ISLAND.PLAYER_RIGHT.x2 && 
          y >= ISLAND.PLAYER_RIGHT.y1 && y <= ISLAND.PLAYER_RIGHT.y2) {
        return 'player_right';
      }
      return null; // Î∞îÎã§
    }
    
    // ÌÉÄÏùºÏóê Í±¥Î¨ºÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    function getBuildingAt(x, y) {
      return gameState.buildings.find(b => b.x === x && b.y === y);
    }
    
    // ÌÉÄÏùºÏóê Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    function getUnitAt(x, y, airOnly = null) {
      return gameState.units.find(u => {
        if (u.x !== x || u.y !== y) return false;
        if (airOnly === null) return true; // Î™®Îì† Ïú†Îãõ
        const isAir = UNITS[u.type]?.isAirUnit;
        return airOnly ? isAir : !isAir; // airOnly=trueÎ©¥ Í≥µÏ§ëÎßå, falseÎ©¥ ÏßÄÏÉÅÎßå
      });
    }
    
    // Í≥µÏ§ë Ïú†Îãõ Ï∞æÍ∏∞
    function getAirUnitAt(x, y) {
      return getUnitAt(x, y, true);
    }
    
    // ÏßÄÏÉÅ/Ìï¥ÏÉÅ Ïú†Îãõ Ï∞æÍ∏∞
    function getGroundUnitAt(x, y) {
      return getUnitAt(x, y, false);
    }
    
    // Îßµ Î∑∞ Ï†ÑÌôò (ÏßÄÏÉÅÎßµ/Í≥µÏ§ëÎßµ)
    function switchMapView(view) {
      currentMapView = view;
      document.querySelectorAll('.map-view-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === view);
      });
      renderMap();
      addLog(`${view === 'ground' ? 'ÏßÄÏÉÅÎßµ' : 'Í≥µÏ§ëÎßµ'}ÏúºÎ°ú Ï†ÑÌôò`, 'system');
    }
    
    // Îßµ Î†åÎçîÎßÅ
    function renderMap() {
      const mapGrid = document.getElementById('map-grid');
      mapGrid.innerHTML = '';
      
      // Í≥µÏ§ëÎßµ Î™®ÎìúÏóêÏÑúÎäî ÏßÄÌòïÏùÑ Î∞òÌà¨Î™ÖÌïòÍ≤å ÌëúÏãú
      const isAirView = currentMapView === 'air';
      
      // player2Ïùº ÎïåÎäî ÎßµÏùÑ Îí§ÏßëÏñ¥ÏÑú Î†åÎçîÎßÅ
      for (let viewY = 0; viewY < MAP_HEIGHT; viewY++) {
        const dataY = toDataY(viewY);
        const row = gameState.map[dataY];
        
        const rowEl = document.createElement('div');
        rowEl.className = 'map-row';
        
        for (let viewX = 0; viewX < MAP_WIDTH; viewX++) {
          const dataX = toDataX(viewX);
          const tile = row[dataX];
          const x = dataX;  // Îç∞Ïù¥ÌÑ∞ Ï¢åÌëú
          const y = dataY;  // Îç∞Ïù¥ÌÑ∞ Ï¢åÌëú
          
          const tileEl = document.createElement('div');
          tileEl.className = 'tile';
          tileEl.dataset.x = x;  // Îç∞Ïù¥ÌÑ∞ Ï¢åÌëú Ï†ÄÏû•
          tileEl.dataset.y = y;
          
          const building = getBuildingAt(x, y);
          // ÏßÄÏÉÅÎßµÏóêÏÑúÎäî ÏßÄÏÉÅ Ïú†ÎãõÎßå, Í≥µÏ§ëÎßµÏóêÏÑúÎäî Í≥µÏ§ë Ïú†ÎãõÎßå
          const unit = isAirView ? getAirUnitAt(x, y) : getGroundUnitAt(x, y);
          
          // ownerÎ•º ÌôîÎ©¥ ÌëúÏãúÏö©ÏúºÎ°ú Î≥ÄÌôò
          const displayTileOwner = tile.owner ? toDisplayOwner(tile.owner) : null;
          const displayBuildingOwner = building ? toDisplayOwner(building.owner) : null;
          const displayUnitOwner = unit ? toDisplayOwner(unit.owner) : null;
          
          // ÏïàÍ∞ú Ï≤òÎ¶¨ - Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏ†ê Í≥†Î†§
          const showFog = isMultiplayer ? shouldShowFog(y, tile) : !tile.visible;
          
          // Í≥µÏ§ëÎßµ Î™®Îìú
          if (isAirView) {
            // Í≥µÏ§ë Ïú†ÎãõÎßå ÌëúÏãú
            const airUnit = unit;
            
            // ÏïàÍ∞ú Ï≤òÎ¶¨ (Ï†Å ÏòÅÏó≠)
            if (showFog) {
              tileEl.classList.add('fog');
              tileEl.style.opacity = '0.7';
              tileEl.textContent = '‚òÅÔ∏è';
            } else {
              tileEl.style.opacity = '0.5';
              
              if (tile.terrain === 'sea') {
                tileEl.classList.add('sea');
              }
              
              if (airUnit) {
                tileEl.style.opacity = '1';
                tileEl.classList.add('has-unit');
                if (airUnit.moved) tileEl.classList.add('unit-moved');
                tileEl.innerHTML = `<span>${UNITS[airUnit.type].icon}</span>`;
              }
            }
            
            // ÏÑ†ÌÉùÎêú ÌÉÄÏùº ÌëúÏãú
            if (gameState.selectedTile && gameState.selectedTile.x === x && gameState.selectedTile.y === y) {
              tileEl.classList.add('selected');
            }
            
            tileEl.addEventListener('click', () => handleTileClick(tile));
            rowEl.appendChild(tileEl);
            continue;
          }
          
          // === ÏßÄÏÉÅÎßµ Î™®Îìú ===
          
          // ÏïàÍ∞ú Ï≤òÎ¶¨ (Ï†Å ÏòÅÏó≠)
          if (showFog) {
            tileEl.classList.add('fog');
            tileEl.textContent = '‚òÅÔ∏è';
          }
          // Î∞îÎã§ ÌÉÄÏùº
          else if (tile.terrain === 'sea' || tile.type === 'sea') {
            tileEl.classList.add('sea');
            if (unit) {
              // Î∞îÎã§ ÏúÑ Ïú†Îãõ
              tileEl.classList.add('has-unit');
              if (unit.moved) tileEl.classList.add('unit-moved');
              // ÏàòÏÜ°Ìï®Ïù¥Î©¥ ÌôîÎ¨º ÌëúÏãú
              if (unit.type === 'transport_ship' && unit.cargo && unit.cargo.length > 0) {
                tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.cargo.length}/2</span>`;
              } else {
                tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.count}</span>`;
              }
            } else {
              tileEl.textContent = 'üåä';
            }
          }
          // Íµ∞Ìï≠
          else if (tile.type === 'harbor') {
            tileEl.classList.add(displayTileOwner === 'player' ? 'harbor-player' : 'harbor-enemy');
            const hpPercent = Math.floor((tile.harborHp / 10000) * 100);
            if (unit) {
              tileEl.classList.add('has-unit');
              if (unit.moved) tileEl.classList.add('unit-moved');
              tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.count}</span><span class="building-icon-small">‚öì</span><span class="base-hp-indicator">${hpPercent}%</span>`;
            } else {
              tileEl.innerHTML = `<span>‚öì</span><span class="base-hp-indicator">${hpPercent}%</span>`;
            }
          }
          // ÌååÍ¥¥Îêú Ìï≠Íµ¨
          else if (tile.type === 'destroyed_harbor') {
            tileEl.classList.add('destroyed-harbor');
            tileEl.innerHTML = `<span>üî•</span>`;
          }
          // Î≥∏Í∏∞ÏßÄ
          else if (tile.type === 'main_base') {
            tileEl.classList.add(displayTileOwner === 'player' ? 'main-base-player' : 'main-base-enemy');
            const baseHp = displayTileOwner === 'player' ? gameState.bases.player.main : gameState.bases.enemy.main;
            const hpPercent = Math.floor((baseHp / BASE_HP.main_base) * 100);
            if (unit) {
              tileEl.classList.add('has-unit');
              if (unit.moved) tileEl.classList.add('unit-moved');
              tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.count}</span><span class="building-icon-small">üè∞</span><span class="base-hp-indicator">${hpPercent}%</span>`;
            } else {
              tileEl.innerHTML = `<span>üè∞</span><span class="base-hp-indicator">${hpPercent}%</span>`;
            }
          }
          // Î∂ÄÍ∏∞ÏßÄ
          else if (tile.type === 'sub_base') {
            tileEl.classList.add(displayTileOwner === 'player' ? 'sub-base-player' : 'sub-base-enemy');
            // ÏÑ¨ ÏúÑÏπòÏóê Îî∞Îùº sub1, sub2 Í≤∞Ï†ï
            const island = getIslandAt(x, y);
            let subKey = 'sub1';
            if (island === 'enemy_right' || island === 'player_left') {
              subKey = 'sub2';
            }
            const baseHp = displayTileOwner === 'player' ? gameState.bases.player[subKey] : gameState.bases.enemy[subKey];
            const hpPercent = Math.floor((baseHp / BASE_HP.sub_base) * 100);
            if (baseHp <= 0) {
              tileEl.classList.add('destroyed');
              tileEl.innerHTML = `<span>üí•</span>`;
            } else if (unit) {
              tileEl.classList.add('has-unit');
              if (unit.moved) tileEl.classList.add('unit-moved');
              tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.count}</span><span class="building-icon-small">üèïÔ∏è</span><span class="base-hp-indicator">${hpPercent}%</span>`;
            } else {
              tileEl.innerHTML = `<span>üèïÔ∏è</span><span class="base-hp-indicator">${hpPercent}%</span>`;
            }
          }
          // Í±¥Î¨º + Ïú†Îãõ
          else if (building && unit) {
            tileEl.classList.add(`building-${building.type}`);
            tileEl.classList.add('has-unit');
            if (unit.moved) tileEl.classList.add('unit-moved');
            if (building.fired) tileEl.classList.add('fired');
            const buildingDef = BUILDINGS[building.type];
            const hpPercent = Math.floor((building.hp / buildingDef.hp) * 100);
            tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.count}</span><span class="building-icon-small">${buildingDef.icon}</span><span class="building-hp-indicator">${hpPercent}%</span>`;
          }
          // Í±¥Î¨ºÎßå
          else if (building) {
            tileEl.classList.add(`building-${building.type}`);
            if (building.fired) tileEl.classList.add('fired');
            if (building.produced) tileEl.classList.add('produced');
            const buildingDef = BUILDINGS[building.type];
            const hpPercent = Math.floor((building.hp / buildingDef.hp) * 100);
            const level = building.level || 1;
            const levelText = buildingDef.upgradable && level > 1 ? `‚òÖ${level}` : '';
            const income = getBuildingIncome(building);
            const incomeText = income > 0 ? `+${income.toLocaleString()}` : '';
            tileEl.innerHTML = `<span>${buildingDef.icon}</span>${levelText ? `<span class="building-level-indicator">${levelText}</span>` : ''}${incomeText ? `<span class="building-income-indicator">${incomeText}</span>` : ''}<span class="building-hp-indicator">${hpPercent}%</span>`;
          }
          // Ïú†ÎãõÎßå
          else if (unit) {
            tileEl.classList.add('has-unit');
            if (unit.moved) tileEl.classList.add('unit-moved');
            tileEl.innerHTML = `<span>${UNITS[unit.type].icon}</span><span class="unit-indicator">${unit.count}</span>`;
          }
          // Îπà ÌÉÄÏùºÏù¥ÏßÄÎßå ÏïÑÍµ∞ ÏßÄÎ¢∞Í∞Ä ÏûàÏúºÎ©¥ ÌëúÏãú
          else {
            const mine = getMineAt(x, y);
            if (mine && toDisplayOwner(mine.owner) === 'player') {
              tileEl.innerHTML = `<span style="opacity:0.7;">üí£</span><span class="unit-indicator" style="color:#f55;">${mine.count}</span>`;
            }
          }
          
          // ÎπÑÌôúÏÑ±Ìôî Ï°∞Í±¥
          const hasScout = gameState.units.some(u => isMyUnit(u) && u.type === 'scout' && !u.moved);
          const hasAirUnit = gameState.units.some(u => isMyUnit(u) && UNITS[u.type].isAirUnit && !u.moved);
          const isFogClickable = showFog && (hasScout || hasAirUnit);
          
          if (!gameState.isPlayerTurn) {
            tileEl.classList.add('disabled');
          } else if (showFog && !isFogClickable) {
            tileEl.classList.add('disabled');
          }
          
          // Ï†ïÏ∞∞ Í∞ÄÎä•Ìïú ÏïàÍ∞ú ÌÉÄÏùº ÌëúÏãú
          if (isFogClickable && showFog) {
            tileEl.classList.add('scourable');
          }
          
          // Ï†êÎ†πÎêú ÌÉÄÏùº ÌëúÏãú (Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ ÏãúÏ†ê Í≥†Î†§)
          const myOwner = getMyOwner();
          const isPlayerCaptured = gameState.capturedTiles[myOwner].some(t => t.x === x && t.y === y);
          const isEnemyCaptured = gameState.capturedTiles[getOpponentOwner()].some(t => t.x === x && t.y === y);
          
          if (isPlayerCaptured && !building && !unit) {
            tileEl.classList.add('captured-player');
          } else if (isEnemyCaptured && !building && !unit) {
            tileEl.classList.add('captured-enemy');
          }
          
          // ÎÜçÎ∂Ä/Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞Ä Ïù∏Ï†ë Ïãú Í±¥ÏÑ§ Í∞ÄÎä• ÌëúÏãú (ÏïÑÍµ∞ Ïú°ÏßÄ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùºÏóêÏÑú)
          const canBuildHere = isMyZone(y) || isPlayerCaptured;
          if (tile.type === 'empty' && tile.terrain === 'land' && !building && !unit && canBuildHere && gameState.isPlayerTurn) {
            if (hasAdjacentFarmer(x, y)) {
              tileEl.classList.add('farmable');
            }
            if (hasAdjacentMilitaryEngineer(x, y)) {
              tileEl.classList.add('military-buildable');
            }
          }
          
          // ÏÑ†ÌÉùÎêú ÌÉÄÏùº
          if (gameState.selectedTile && gameState.selectedTile.x === x && gameState.selectedTile.y === y) {
            tileEl.classList.add('selected');
          }
          
          tileEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleTileClick(tile);
          });
          rowEl.appendChild(tileEl);
        }
        
        mapGrid.appendChild(rowEl);
      }
      
      // ÏûêÏõê ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
      updateResourceDisplay();
      
      // ÎØ∏ÎãàÎßµ ÏóÖÎç∞Ïù¥Ìä∏
    }
    
    // ÏòÅÏó≠ Ïù¥Îèô Ìï®Ïàò
    function goToArea(area) {
      const scrollArea = document.getElementById('map-scroll-area');
      if (!scrollArea) return;
      
      // ÌòÑÏû¨ Ï§å Î†àÎ≤®Ïóê Îî∞Î•∏ ÌÉÄÏùº ÌÅ¨Í∏∞
      const zoomPercent = ZOOM_LEVELS[currentZoomIndex];
      const tileSize = Math.floor(BASE_TILE_SIZE * zoomPercent / 100) + 2;
      
      // Í∞Å ÏòÅÏó≠Ïùò Ï§ëÏã¨ ÌÉÄÏùº Ï¢åÌëú (Îç∞Ïù¥ÌÑ∞ Ï¢åÌëú)
      let areas = {
        'enemy-sub': { x: 10, y: 7 },      // Ï¢åÏÉÅÎã® - Ï†Å Î∂ÄÍ∏∞ÏßÄ
        'enemy-main': { x: 30, y: 7 },     // Ïö∞ÏÉÅÎã® - Ï†Å Î≥∏Í∏∞ÏßÄ
        'player-sub': { x: 10, y: 22 },    // Ï¢åÌïòÎã® - ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄ
        'player-main': { x: 30, y: 22 },   // Ïö∞ÌïòÎã® - ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄ
        'sea': { x: 20, y: 15 }            // Ï§ëÏïô Î∞îÎã§
      };
      
      // player2Îäî playerÏôÄ enemy ÏòÅÏó≠ Î∞òÏ†Ñ
      if (isMultiplayer && !isPlayer1) {
        areas = {
          'player-sub': { x: 10, y: 7 },    // Ï¢åÏÉÅÎã® - ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄ (player2 Í∏∞Ï§Ä)
          'player-main': { x: 30, y: 7 },   // Ïö∞ÏÉÅÎã® - ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄ (player2 Í∏∞Ï§Ä)
          'enemy-sub': { x: 10, y: 22 },    // Ï¢åÌïòÎã® - Ï†Å Î∂ÄÍ∏∞ÏßÄ (player2 Í∏∞Ï§Ä)
          'enemy-main': { x: 30, y: 22 },   // Ïö∞ÌïòÎã® - Ï†Å Î≥∏Í∏∞ÏßÄ (player2 Í∏∞Ï§Ä)
          'sea': { x: 20, y: 15 }
        };
      }
      
      const target = areas[area];
      if (!target) return;
      
      // ÌôîÎ©¥ Ï¢åÌëúÎ°ú Î≥ÄÌôò
      const viewX = toViewX(target.x);
      const viewY = toViewY(target.y);
      
      // Ìï¥Îãπ ÌÉÄÏùºÏù¥ ÌôîÎ©¥ Ï§ëÏïôÏóê Ïò§ÎèÑÎ°ù Ïä§ÌÅ¨Î°§
      const targetX = viewX * tileSize - scrollArea.clientWidth / 2 + tileSize / 2;
      const targetY = viewY * tileSize - scrollArea.clientHeight / 2 + tileSize / 2;
      
      scrollArea.scrollLeft = Math.max(0, targetX);
      scrollArea.scrollTop = Math.max(0, targetY);
    }
    
    // ÏûêÏõê ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    function updateResourceDisplay() {
      const myOwner = getMyOwner();
      document.getElementById('game-resource-amount').textContent = gameState.resources[myOwner].toLocaleString();
    }
    
    // ÌÉÄÏùº ÌÅ¥Î¶≠ Ï≤òÎ¶¨
    function handleTileClick(tile) {
      if (!gameState.isPlayerTurn) return;
      
      // Í≥µÏ§ëÎßµ Î™®Îìú
      if (currentMapView === 'air') {
        const airUnit = getUnitAt(tile.x, tile.y);
        const hasAirUnit = gameState.units.some(u => 
          u.owner === 'player' && UNITS[u.type].isAirUnit && !u.moved
        );
        
        // Í≥µÏ§ë Ïú†ÎãõÏù¥ ÏûàÎäî ÌÉÄÏùºÏù¥Í±∞ÎÇò, Ïù¥Îèô Í∞ÄÎä•Ìïú Í≥µÏ§ë Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ ÌÅ¥Î¶≠ Í∞ÄÎä•
        if ((airUnit && UNITS[airUnit.type]?.isAirUnit) || hasAirUnit) {
          gameState.selectedTile = tile;
          renderMap();
          showActionMenu(tile);
        }
        return;
      }
      
      // ÎπÑÌñâ Ïú†Îãõ Î≥¥Ïú† Ïó¨Î∂Ä ÌôïÏù∏
      const hasAirUnit = gameState.units.some(u => 
        u.owner === 'player' && UNITS[u.type].isAirUnit && !u.moved
      );
      
      // Ìï¥Íµ∞ Ïú†Îãõ(Ï†ÑÌï®) Î≥¥Ïú† Ïó¨Î∂Ä ÌôïÏù∏
      const hasNavalUnit = gameState.units.some(u => 
        u.owner === 'player' && UNITS[u.type].isNavalUnit && !u.moved
      );
      
      // ÏïàÍ∞ú ÌÉÄÏùºÏùÄ Ï†ïÏ∞∞Î≥ë ÎòêÎäî ÎπÑÌñâ Ïú†ÎãõÏù¥ ÏûàÏùÑ ÎïåÎßå ÌÅ¥Î¶≠ Í∞ÄÎä•
      if (!tile.visible) {
        const hasScout = gameState.units.some(u => 
          u.owner === 'player' && u.type === 'scout' && !u.moved
        );
        if (!hasScout && !hasAirUnit) return;
      }
      
      // Î∞îÎã§ ÌÉÄÏùº - Ìï¥Íµ∞ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ ÌÅ¥Î¶≠ Í∞ÄÎä•
      if (tile.terrain === 'sea' || tile.type === 'sea') {
        if (!hasNavalUnit && !hasAirUnit) {
          // Ìï¥Íµ∞/Í≥µÏ§ë Ïú†ÎãõÏù¥ ÏóÜÏúºÎ©¥ ÌÅ¥Î¶≠ Î∂àÍ∞Ä
          return;
        }
        // Ìï¥Íµ∞ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ïï°ÏÖò Î©îÎâ¥ ÌëúÏãú
        gameState.selectedTile = tile;
        updateUpgradePanel(tile);
        renderMap();
        showActionMenu(tile);
        return;
      }
      
      gameState.selectedTile = tile;
      updateUpgradePanel(tile);
      renderMap();
      showActionMenu(tile);
    }
    
    // Ïù∏Ï†ë ÌÉÄÏùºÏóê Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    function hasAdjacentEngineer(x, y) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}  // ÎåÄÍ∞ÅÏÑ†
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const unit = getUnitAt(nx, ny);
          if (unit && unit.type === 'engineer' && unit.owner === 'player' && !unit.moved) {
            return unit;
          }
        }
      }
      return null;
    }
    
    // Ïù∏Ï†ë ÌÉÄÏùºÏóê ÎÜçÎ∂ÄÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    function hasAdjacentFarmer(x, y) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}  // ÎåÄÍ∞ÅÏÑ†
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const unit = getUnitAt(nx, ny);
          if (unit && unit.type === 'farmer' && unit.owner === 'player' && !unit.moved) {
            return unit;
          }
        }
      }
      return null;
    }
    
    // Ïù∏Ï†ë ÌÉÄÏùºÏóê Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
    function hasAdjacentMilitaryEngineer(x, y) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}  // ÎåÄÍ∞ÅÏÑ†
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const unit = getUnitAt(nx, ny);
          if (unit && unit.type === 'military_engineer' && unit.owner === 'player' && !unit.moved) {
            return unit;
          }
        }
      }
      return null;
    }
    
    // Ïù∏Ï†ë ÌÉÄÏùºÏóê ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
    function hasAdjacentAntiTank(x, y) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const unit = getUnitAt(nx, ny);
          if (unit && unit.type === 'anti_tank' && unit.owner === 'player' && !unit.moved) {
            return unit;
          }
        }
      }
      return null;
    }
    
    // Ìï¥Îãπ Ï¢åÌëúÏùò ÏßÄÎ¢∞ Í∞ÄÏ†∏Ïò§Í∏∞
    function getMineAt(x, y) {
      return gameState.landmines.find(m => m.x === x && m.y === y);
    }
    
    // Ïï°ÏÖò Î©îÎâ¥ ÌëúÏãú
    function showActionMenu(tile) {
      document.getElementById('tile-x').textContent = tile.x;
      document.getElementById('tile-y').textContent = tile.y;
      
      // Î™®Îì† Î≤ÑÌäº Ïà®Í∏∞Í∏∞ (Ï¥àÍ∏∞Ìôî)
      const allActionBtns = document.querySelectorAll('.action-btn');
      allActionBtns.forEach(btn => btn.style.display = 'none');
      
      // Í≥µÏ§ëÎßµ Î™®Îìú
      if (currentMapView === 'air') {
        document.querySelector('[data-action="march"]').style.display = 'flex';
        document.querySelector('[data-action="station"]').style.display = 'flex';
        
        // Í≥µÏ§ëÎßµÏóêÏÑú Ìè≠Í≤©Í∏∞Í∞Ä Ï†Å ÏòÅÏó≠Ïóê ÏûàÏúºÎ©¥ Ìè≠Í≤© Î≤ÑÌäº ÌëúÏãú
        const bombBtn = document.getElementById('bomb-btn');
        const airUnit = getAirUnitAt(tile.x, tile.y);
        if (airUnit && airUnit.owner === 'player' && airUnit.type === 'bomber' && !airUnit.moved) {
          // Ï†Å ÏòÅÏó≠Ïù¥Í≥† Î∞îÎã§Í∞Ä ÏïÑÎãåÏßÄ ÌôïÏù∏
          const isEnemyZone = tile.y <= ENEMY_ZONE_END;
          const isSea = tile.terrain === 'sea' || tile.type === 'sea';
          if (isEnemyZone && !isSea) {
            bombBtn.style.display = 'flex';
          }
        }
        
        document.getElementById('action-menu').classList.add('active');
        document.getElementById('action-overlay').classList.add('active');
        return;
      }
      
      // === ÏßÄÏÉÅÎßµ Î™®Îìú ===
      const building = getBuildingAt(tile.x, tile.y);
      const unit = getGroundUnitAt(tile.x, tile.y);
      const adjacentEngineer = hasAdjacentEngineer(tile.x, tile.y);
      const adjacentFarmer = hasAdjacentFarmer(tile.x, tile.y);
      const adjacentMilitaryEngineer = hasAdjacentMilitaryEngineer(tile.x, tile.y);
      const isEmptyTile = tile.type === 'empty' && !building && !unit;
      const isPlayerZone = tile.y >= PLAYER_ZONE_START;
      const isCapturedByPlayer = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      const canBuildHere = isPlayerZone || isCapturedByPlayer;
      
      // Í∏∞Î≥∏ Î≤ÑÌäºÎì§ ÌëúÏãú (ÌñâÍµ∞, Ï£ºÎëî, Í≥µÍ≤©)
      document.querySelector('[data-action="march"]').style.display = 'flex';
      document.querySelector('[data-action="station"]').style.display = 'flex';
      document.querySelector('[data-action="attack"]').style.display = 'flex';
      
      // Í±¥Ï∂ï Î≤ÑÌäº - Îπà ÌÉÄÏùºÏù¥Í≥† ÏïÑÍµ∞ ÏòÅÏó≠ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùºÏù¥Î©¥ ÌëúÏãú
      if (isEmptyTile && canBuildHere) {
        document.querySelector('[data-action="build"]').style.display = 'flex';
      }
      
      // Í∏∞ÏßÄÏóêÏÑú Ïú†Îãõ ÏÉùÏÇ∞ Î≤ÑÌäº
      if ((tile.type === 'main_base' || tile.type === 'sub_base') && tile.owner === 'player') {
        document.getElementById('recruit-action-btn').style.display = 'flex';
      }
      
      // ÏßïÎ≥ëÏÜåÍ∞Ä ÏûàÏúºÎ©¥ ÏßïÎ≥ë Î≤ÑÌäº ÌëúÏãú
      const recruitBtn = document.getElementById('recruit-action-btn');
      if (building && building.type === 'barracks' && building.owner === 'player') {
        recruitBtn.style.display = 'flex';
      }
      
      // Îπà ÌÉÄÏùºÏù¥Í≥† Ïù∏Ï†ëÌïú ÎÜçÎ∂ÄÍ∞Ä ÏûàÏúºÎ©¥ ÎÜçÏû•/Ïò®Ïã§ Í±¥ÏÑ§ Î≤ÑÌäº ÌëúÏãú
      const farmBtn = document.getElementById('farm-action-btn');
      const greenhouseBtn = document.getElementById('greenhouse-action-btn');
      
      if (isEmptyTile && adjacentFarmer && canBuildHere) {
        farmBtn.style.display = 'flex';
        greenhouseBtn.style.display = 'flex';
        farmBtn.disabled = gameState.resources.player < BUILDINGS.farm.cost;
        greenhouseBtn.disabled = gameState.resources.player < BUILDINGS.greenhouse.cost;
      }
      
      // Îπà ÌÉÄÏùºÏù¥Í≥† Ïù∏Ï†ëÌïú Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏûàÏúºÎ©¥ Íµ∞ÏÇ¨ Í±¥ÏÑ§ Î≤ÑÌäº ÌëúÏãú
      const militaryBuildBtn = document.getElementById('military-build-btn');
      
      if (isEmptyTile && adjacentMilitaryEngineer && canBuildHere) {
        militaryBuildBtn.style.display = 'flex';
      }
      
      // Î∞ïÍ≤©Ìè¨Í∞Ä ÏûàÏúºÎ©¥ Î∞úÏÇ¨ Î≤ÑÌäº ÌëúÏãú
      const fireMortarBtn = document.getElementById('fire-mortar-btn');
      if (building && building.type === 'mortar' && building.owner === 'player' && !building.fired) {
        fireMortarBtn.style.display = gameState.resources.player >= BUILDINGS.mortar.fireCost ? 'flex' : 'none';
      }
      
      // ÌôúÏ£ºÎ°úÍ∞Ä ÏûàÏúºÎ©¥ ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Î≤ÑÌäº ÌëúÏãú
      const produceAircraftBtn = document.getElementById('produce-aircraft-btn');
      if (building && building.type === 'runway' && building.owner === 'player' && !building.produced) {
        produceAircraftBtn.style.display = 'flex';
      }
      
      // Íµ∞Ïàò Í≥µÏû•Ïù¥ ÏûàÏúºÎ©¥ ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î≤ÑÌäº ÌëúÏãú
      const produceMissileBtn = document.getElementById('produce-missile-btn');
      const produceTankBtn = document.getElementById('produce-tank-btn');
      if (building && building.type === 'arms_factory' && building.owner === 'player' && !building.produced) {
        produceMissileBtn.style.display = 'flex';
        produceTankBtn.style.display = 'flex';
      }
      
      // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ÎåÄÍ∞Ä ÏûàÏúºÎ©¥ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Î≤ÑÌäº ÌëúÏãú
      const launchMissileBtn = document.getElementById('launch-missile-btn');
      if (building && building.type === 'missile_silo' && building.owner === 'player' && !building.fired) {
        // ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥†Í∞Ä ÏûàÍ≥† ÏûêÏõêÏù¥ Ï∂©Î∂ÑÌï† ÎïåÎßå ÌôúÏÑ±Ìôî
        if (gameState.missiles.player > 0 && gameState.resources.player >= BUILDINGS.missile_silo.launchCost) {
          launchMissileBtn.style.display = 'flex';
        }
      }
      
      // ÏóÖÍ∑∏Î†àÏù¥Îìú Í∞ÄÎä•Ìïú Í±¥Î¨ºÏù¥Î©¥ ÏóÖÍ∑∏Î†àÏù¥Îìú Î≤ÑÌäº ÌëúÏãú
      const upgradeBtn = document.getElementById('upgrade-btn');
      const upgradeBtnDesc = document.getElementById('upgrade-btn-desc');
      if (building && building.owner === 'player') {
        const buildingDef = BUILDINGS[building.type];
        if (buildingDef.upgradable) {
          const currentLevel = building.level || 1;
          if (currentLevel < buildingDef.maxLevel) {
            const upgradeCost = getUpgradeCost(building.type, currentLevel);
            upgradeBtn.style.display = 'flex';
            upgradeBtnDesc.textContent = `Lv.${currentLevel}‚Üí${currentLevel+1} (üí∞${upgradeCost.toLocaleString()})`;
            
            // ÏûêÏõê Î∂ÄÏ°± Ïãú ÎπÑÌôúÏÑ±Ìôî Ïä§ÌÉÄÏùº
            if (gameState.resources.player < upgradeCost) {
              upgradeBtn.classList.add('disabled-visual');
            } else {
              upgradeBtn.classList.remove('disabled-visual');
            }
          }
        }
      }
      
      // ÏïÑÍµ∞ Ìï≠Íµ¨Î©¥ Î∞∞ ÏÉùÏÇ∞ Î≤ÑÌäº ÌëúÏãú
      const produceShipBtn = document.getElementById('produce-ship-btn');
      if (tile.type === 'harbor' && tile.owner === 'player' && tile.harborHp > 0) {
        produceShipBtn.style.display = 'flex';
        produceShipBtn.disabled = gameState.resources.player < UNITS.attack_ship.cost;
      }
      
      // Ï†Å Ìï≠Íµ¨Ïù¥Í≥† Ïù∏Ï†ëÌïú Ï†ÑÌï®Ïù¥ ÏûàÏúºÎ©¥ Í≥µÍ≤© Î≤ÑÌäº ÌëúÏãú
      const attackHarborBtn = document.getElementById('attack-harbor-btn');
      if (tile.type === 'harbor' && tile.owner === 'enemy' && tile.harborHp > 0) {
        const hasAdjacentShip = gameState.units.some(u => 
          u.owner === 'player' && 
          u.type === 'attack_ship' && 
          !u.moved &&
          Math.abs(u.x - tile.x) <= UNITS.attack_ship.attackRange &&
          Math.abs(u.y - tile.y) <= UNITS.attack_ship.attackRange
        );
        if (hasAdjacentShip) attackHarborBtn.style.display = 'flex';
      }
      
      // ÌååÍ¥¥Îêú Ìï≠Íµ¨Ïù¥Í≥† Ïù∏Ï†ëÌïú Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏûàÏúºÎ©¥ Ïû¨Í±¥ Î≤ÑÌäº ÌëúÏãú
      const rebuildHarborBtn = document.getElementById('rebuild-harbor-btn');
      if (tile.type === 'destroyed_harbor' && adjacentEngineer) {
        rebuildHarborBtn.style.display = 'flex';
        rebuildHarborBtn.disabled = gameState.resources.player < 5000;
      }
      
      // Î∞îÎã§Ïóê Ï†Å Ìï®ÏÑ†Ïù¥ ÏûàÍ≥† ÎØ∏ÏÇ¨Ïùº ÏàúÏñëÌï®Ïù¥ ÏÇ¨Í±∞Î¶¨ ÎÇ¥Ïóê ÏûàÏúºÎ©¥ Ìï®ÏÑ† Í≥µÍ≤© Î≤ÑÌäº ÌëúÏãú
      const attackShipBtn = document.getElementById('attack-ship-btn');
      const targetUnit = getUnitAt(tile.x, tile.y);
      if (targetUnit && targetUnit.owner === 'enemy' && UNITS[targetUnit.type]?.isNavalUnit) {
        const hasCruiserInRange = gameState.units.some(u => 
          u.owner === 'player' && 
          u.type === 'missile_cruiser' && 
          !u.moved &&
          Math.abs(u.x - tile.x) <= UNITS.missile_cruiser.attackRange &&
          Math.abs(u.y - tile.y) <= UNITS.missile_cruiser.attackRange
        );
        if (hasCruiserInRange) attackShipBtn.style.display = 'flex';
      }
      
      // Îπà ÌÉÄÏùºÏù¥Í≥† Ïù∏Ï†ëÌïú ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏù¥ ÏûàÏúºÎ©¥ ÏßÄÎ¢∞ ÏÑ§Ïπò Î≤ÑÌäº ÌëúÏãú
      const placeMineBtn = document.getElementById('place-mine-btn');
      const adjacentAntiTank = hasAdjacentAntiTank(tile.x, tile.y);
      const hasExistingMine = getMineAt(tile.x, tile.y);
      if (isEmptyTile && adjacentAntiTank && !building && !hasExistingMine && tile.terrain !== 'sea') {
        placeMineBtn.style.display = 'flex';
        // ÏûêÏõê Î∂ÄÏ°± Ïãú ÎπÑÌôúÏÑ±Ìôî
        if (gameState.resources.player < MINE_COST) {
          placeMineBtn.classList.add('disabled-visual');
        } else {
          placeMineBtn.classList.remove('disabled-visual');
        }
      }
      
      // Îπà ÌÉÄÏùºÏù¥Í≥† Ïù∏Ï†ëÌïú Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏûàÏúºÎ©¥ Ï†ÑÎ¨∏ Í±¥Ï∂ï Î≤ÑÌäº ÌëúÏãú (ÏïÑÍµ∞ ÏòÅÏó≠ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùº)
      const engineerBuildBtn = document.getElementById('engineer-build-btn');
      if (isEmptyTile && adjacentEngineer && !building && canBuildHere && tile.terrain !== 'sea') {
        engineerBuildBtn.style.display = 'flex';
      }
      
      // Ï†Å ÏòÅÏó≠ÏóêÏÑú ÏïÑÍµ∞ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ï†êÎ†π Î≤ÑÌäº ÌëúÏãú
      const captureBtn = document.getElementById('capture-btn');
      const isEnemyZone = tile.y <= ENEMY_ZONE_END;
      const playerUnitHere = gameState.units.find(u => 
        u.owner === 'player' && u.x === tile.x && u.y === tile.y && !u.moved
      );
      const alreadyCaptured = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      
      if (isEnemyZone && tile.terrain === 'land' && tile.type === 'empty' && 
          !building && playerUnitHere && !alreadyCaptured) {
        captureBtn.style.display = 'flex';
      }
      
      // ÏàòÏÜ°Ìï®Ïù¥ ÏûàÏúºÎ©¥ ÏàòÏÜ° Î≤ÑÌäº ÌëúÏãú
      const transportBtn = document.getElementById('transport-btn');
      const unitOnTile = getUnitAt(tile.x, tile.y);
      if (unitOnTile && unitOnTile.owner === 'player' && unitOnTile.type === 'transport_ship' && !unitOnTile.moved) {
        // ÏàòÏÜ° Í∞ÄÎä•Ìïú Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        const transportableUnits = gameState.units.filter(u => 
          u.owner === 'player' && 
          !UNITS[u.type].isNavalUnit && 
          !UNITS[u.type].isAirUnit &&
          !u.transported
        );
        if (transportableUnits.length > 0 && (!unitOnTile.cargo || unitOnTile.cargo.length < 2)) {
          transportBtn.style.display = 'flex';
        }
      }
      
      // ÏàòÏÜ°Ìï®Ïù¥ Ïú°ÏßÄ Ïù∏Ï†ëÌïòÎ©¥ ÏÉÅÎ•ô Î≤ÑÌäº ÌëúÏãú
      const landBtn = document.getElementById('land-btn');
      if (unitOnTile && unitOnTile.owner === 'player' && unitOnTile.type === 'transport_ship' && 
          unitOnTile.cargo && unitOnTile.cargo.length > 0 && !unitOnTile.moved) {
        // Ïù∏Ï†ë Ïú°ÏßÄ ÌôïÏù∏
        const hasAdjacentLand = checkAdjacentLand(tile.x, tile.y);
        if (hasAdjacentLand) {
          landBtn.style.display = 'flex';
        }
      }
      
      document.getElementById('action-menu').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Ïï°ÏÖò Î©îÎâ¥ Îã´Í∏∞
    function hideActionMenu(clearSelection = false) {
      document.getElementById('action-menu').classList.remove('active');
      if (clearSelection) {
        document.getElementById('action-overlay').classList.remove('active');
        gameState.selectedTile = null;
        updateUpgradePanel(null);
        renderMap();
      }
    }
    
    // Ïï°ÏÖò Ï≤òÎ¶¨
    function handleAction(action) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      if (action === 'build') {
        // Í±¥Ï∂ï Î™®Îã¨ Ïó¥Í∏∞
        showBuildModal();
        return;
      }
      
      if (action === 'recruit') {
        // ÏßïÎ≥ë Î™®Îã¨ Ïó¥Í∏∞
        showRecruitModal();
        return;
      }
      
      if (action === 'march') {
        // ÌñâÍµ∞ Î™®Îã¨ Ïó¥Í∏∞
        showDeployModal('march');
        return;
      }
      
      if (action === 'station') {
        // Ï£ºÎëî Î™®Îã¨ Ïó¥Í∏∞
        showDeployModal('station');
        return;
      }
      
      if (action === 'build-bridge') {
        // Îã§Î¶¨ Í±¥ÏÑ§
        buildBridge(tile);
        return;
      }
      
      if (action === 'attack') {
        // Í≥µÍ≤© Î™®Îã¨ Ïó¥Í∏∞
        showAttackModal();
        return;
      }
      
      if (action === 'build-farm') {
        // ÎÜçÏû• Í±¥ÏÑ§
        buildFarmStructure('farm');
        return;
      }
      
      if (action === 'build-greenhouse') {
        // Ïò®Ïã§ Í±¥ÏÑ§
        buildFarmStructure('greenhouse');
        return;
      }
      
      if (action === 'build-mortar') {
        // Î∞ïÍ≤©Ìè¨ Í±¥ÏÑ§
        buildMilitaryStructure('mortar');
        return;
      }
      
      if (action === 'military-build') {
        // Íµ∞ÏÇ¨ Í±¥ÏÑ§ Î™®Îã¨ Ïó¥Í∏∞
        showMilitaryBuildModal();
        return;
      }
      
      if (action === 'fire-mortar') {
        // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ Î™®Îã¨ Ïó¥Í∏∞
        showMortarFireModal();
        return;
      }
      
      if (action === 'produce-aircraft') {
        // ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Î™®Îã¨ Ïó¥Í∏∞
        showAircraftModal();
        return;
      }
      
      if (action === 'produce-ship') {
        // Ìï®ÏÑ† ÏÉùÏÇ∞ Î™®Îã¨ Ïó¥Í∏∞
        showShipModal();
        return;
      }
      
      if (action === 'attack-harbor') {
        // Ìï≠Íµ¨ Í≥µÍ≤©
        attackHarbor(tile);
        return;
      }
      
      if (action === 'attack-ship') {
        // Ìï®ÏÑ† Í≥µÍ≤©
        showAttackShipModal();
        return;
      }
      
      if (action === 'rebuild-harbor') {
        // Ìï≠Íµ¨ Ïû¨Í±¥
        rebuildHarbor(tile);
        return;
      }
      
      if (action === 'transport') {
        // ÏàòÏÜ° Î™®Îã¨ Ïó¥Í∏∞
        showTransportModal();
        return;
      }
      
      if (action === 'land') {
        // ÏÉÅÎ•ô Î™®Îã¨ Ïó¥Í∏∞
        showLandModal();
        return;
      }
      
      if (action === 'bomb') {
        // Ìè≠Í≤© Ïã§Ìñâ
        executeBomb(tile);
        return;
      }
      
      if (action === 'produce-missile') {
        // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î™®Îã¨ Ïó¥Í∏∞
        showMissileProduceModal();
        return;
      }
      
      if (action === 'produce-tank') {
        // ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ Î™®Îã¨ Ïó¥Í∏∞
        showTankProduceModal();
        return;
      }
      
      if (action === 'launch-missile') {
        // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Î™®Îã¨ Ïó¥Í∏∞
        showMissileLaunchModal();
        return;
      }
      
      if (action === 'upgrade') {
        // Í±¥Î¨º ÏóÖÍ∑∏Î†àÏù¥Îìú Ïã§Ìñâ
        executeUpgrade(tile.x, tile.y);
        hideActionMenu(true);
        return;
      }
      
      if (action === 'place-mine') {
        // ÏßÄÎ¢∞ ÏÑ§Ïπò Î™®Îã¨ Ïó¥Í∏∞
        showMinePlaceModal(tile);
        return;
      }
      
      if (action === 'engineer-build') {
        // Ï†ÑÎ¨∏ Í±¥Ï∂ï Î™®Îã¨ Ïó¥Í∏∞
        showEngineerBuildModal();
        return;
      }
      
      if (action === 'capture') {
        // ÌÉÄÏùº Ï†êÎ†π
        captureTile(tile);
        return;
      }
      
      addLog(`Ïïå Ïàò ÏóÜÎäî Î™ÖÎ†π: ${action}`, 'system');
      hideActionMenu(true);
    }
    
    // ==================== Ï†êÎ†π ÏãúÏä§ÌÖú ====================
    
    // ÌÉÄÏùº Ï†êÎ†π
    function captureTile(tile) {
      // Ï†êÎ†π Ïú†Îãõ Ï∞æÍ∏∞
      const captureUnit = gameState.units.find(u => 
        u.owner === 'player' && u.x === tile.x && u.y === tile.y && !u.moved
      );
      
      if (!captureUnit) {
        addLog('Ï†êÎ†πÌï† Ïú†ÎãõÏù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ïù¥ÎØ∏ Ï†êÎ†πÎêú ÌÉÄÏùºÏù∏ÏßÄ ÌôïÏù∏
      const alreadyCaptured = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      if (alreadyCaptured) {
        addLog('Ïù¥ÎØ∏ Ï†êÎ†πÎêú ÌÉÄÏùºÏûÖÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ï†êÎ†π Ïã§Ìñâ
      gameState.capturedTiles.player.push({ x: tile.x, y: tile.y });
      captureUnit.moved = true;  // Ï†êÎ†π ÌõÑ ÌñâÎèô Ï¢ÖÎ£å
      
      addLog(`üö© (${tile.x}, ${tile.y}) ÌÉÄÏùºÏùÑ Ï†êÎ†πÌñàÏäµÎãàÎã§! Ïù¥Ï†ú Í±¥Ï∂ïÏù¥ Í∞ÄÎä•Ìï©ÎãàÎã§.`, 'action');
      
      hideActionMenu(true);
      renderMap();
    }
    
    // Ï†êÎ†πÎêú ÌÉÄÏùºÏù∏ÏßÄ ÌôïÏù∏
    function isCapturedTile(x, y, owner) {
      return gameState.capturedTiles[owner].some(t => t.x === x && t.y === y);
    }
    
    // ==================== Ï†êÎ†π ÏãúÏä§ÌÖú ÎÅù ====================
    
    // Îã§Î¶¨ Í±¥ÏÑ§
    function buildBridge(tile) {
      const bridgeCost = BUILDINGS.bridge.cost;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < bridgeCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ïù∏Ï†ë Í±¥Ï∂ïÍ∞Ä ÌôïÏù∏
      const engineer = hasAdjacentEngineer(tile.x, tile.y);
      if (!engineer) {
        addLog('Ïù∏Ï†ëÌïú Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ïù¥ÎØ∏ Îã§Î¶¨Í∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
      if (getBuildingAt(tile.x, tile.y)) {
        addLog('Ïù¥ÎØ∏ Í±¥Î¨ºÏù¥ ÏûàÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= bridgeCost;
      
      // Í±¥Ï∂ïÍ∞Ä ÌñâÎèô ÏôÑÎ£å Ï≤òÎ¶¨
      engineer.moved = true;
      
      // Îã§Î¶¨ Í±¥ÏÑ§
      gameState.buildings.push({
        type: 'bridge',
        x: tile.x,
        y: tile.y,
        owner: 'player',
        hp: BUILDINGS.bridge.hp,
        level: 1
      });
      
      addLog(`(${tile.x}, ${tile.y})Ïóê Îã§Î¶¨ Í±¥ÏÑ§ ÏôÑÎ£å! (-${bridgeCost} ÏûêÏõê)`, 'action');
      hideActionMenu(true);
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // Ìï®ÏÑ† ÏÉùÏÇ∞ Î™®Îã¨ ÌëúÏãú
    function showShipModal() {
      hideActionMenu();
      
      // ÏòµÏÖò ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
      const attackShipOption = document.getElementById('build-attack-ship');
      const cruiserOption = document.getElementById('build-missile-cruiser');
      const transportOption = document.getElementById('build-transport-ship');
      
      if (gameState.resources.player < UNITS.attack_ship.cost) {
        attackShipOption.classList.add('disabled');
      } else {
        attackShipOption.classList.remove('disabled');
      }
      
      if (gameState.resources.player < UNITS.missile_cruiser.cost) {
        cruiserOption.classList.add('disabled');
      } else {
        cruiserOption.classList.remove('disabled');
      }
      
      if (gameState.resources.player < UNITS.transport_ship.cost) {
        transportOption.classList.add('disabled');
      } else {
        transportOption.classList.remove('disabled');
      }
      
      document.getElementById('ship-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Ìï®ÏÑ† ÏÉùÏÇ∞ Î™®Îã¨ Îã´Í∏∞
    function hideShipModal() {
      document.getElementById('ship-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // Ìï®ÏÑ† ÏÉùÏÇ∞
    function produceShip(shipType) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const shipDef = UNITS[shipType];
      if (!shipDef) return;
      
      const shipCost = shipDef.cost;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < shipCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        hideShipModal();
        return;
      }
      
      // Ìï≠Íµ¨Ïù∏ÏßÄ ÌôïÏù∏
      if (tile.type !== 'harbor' || tile.owner !== 'player') {
        addLog('ÏïÑÍµ∞ Ìï≠Íµ¨ÏóêÏÑúÎßå Î∞∞Î•º ÏÉùÏÇ∞Ìï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
        hideShipModal();
        return;
      }
      
      // Ìï≠Íµ¨ Ï£ºÎ≥Ä Î∞îÎã§Ïóê Î∞∞ÏπòÌï† ÏúÑÏπò Ï∞æÍ∏∞
      const seaPositions = [];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          const nx = tile.x + dx;
          const ny = tile.y + dy;
          if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
            const targetTile = gameState.map[ny][nx];
            if (targetTile.terrain === 'sea' && !getUnitAt(nx, ny)) {
              seaPositions.push({ x: nx, y: ny });
            }
          }
        }
      }
      
      if (seaPositions.length === 0) {
        addLog('Î∞∞Î•º Î∞∞ÏπòÌï† Í≥µÍ∞ÑÏù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        hideShipModal();
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= shipCost;
      
      // Ï≤´ Î≤àÏß∏ Îπà Î∞îÎã§ ÏúÑÏπòÏóê Î∞∞ Î∞∞Ïπò
      const spawnPos = seaPositions[0];
      gameState.units.push({
        id: Date.now(),
        type: shipType,
        x: spawnPos.x,
        y: spawnPos.y,
        owner: 'player',
        hp: shipDef.hp,
        count: 1,
        moved: true // ÏÉùÏÇ∞ ÌÑ¥ÏóêÎäî Ïù¥Îèô Î∂àÍ∞Ä
      });
      
      addLog(`${shipDef.icon} ${shipDef.name} ÏÉùÏÇ∞! (${spawnPos.x}, ${spawnPos.y}) (-${shipCost} ÏûêÏõê)`, 'action');
      hideShipModal();
      renderMap();
    }
    
    // Ìï®ÏÑ† Í≥µÍ≤© Î™®Îã¨ ÌëúÏãú
    function showAttackShipModal() {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      // Í≥µÍ≤© ÎåÄÏÉÅ Ï†Å Ìï®ÏÑ† ÌôïÏù∏
      const targetShip = getUnitAt(tile.x, tile.y);
      if (!targetShip || targetShip.owner !== 'enemy' || !UNITS[targetShip.type].isNavalUnit) {
        addLog('Í≥µÍ≤©Ìï† Ï†Å Ìï®ÏÑ†Ïù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Í≥µÍ≤© Í∞ÄÎä•Ìïú ÎØ∏ÏÇ¨Ïùº ÏàúÏñëÌï® Ï∞æÍ∏∞
      const attackingCruiser = gameState.units.find(u => 
        u.owner === 'player' && 
        u.type === 'missile_cruiser' && 
        !u.moved &&
        Math.abs(u.x - tile.x) <= UNITS.missile_cruiser.attackRange &&
        Math.abs(u.y - tile.y) <= UNITS.missile_cruiser.attackRange
      );
      
      if (!attackingCruiser) {
        addLog('Í≥µÍ≤© Í∞ÄÎä•Ìïú ÎØ∏ÏÇ¨Ïùº ÏàúÏñëÌï®Ïù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Í≥µÍ≤© Ïã§Ìñâ
      attackingCruiser.moved = true;
      const damage = UNITS.missile_cruiser.damageToShip;
      targetShip.hp -= damage;
      
      if (targetShip.hp <= 0) {
        // Ï†Å Ìï®ÏÑ† ÌååÍ¥¥
        const index = gameState.units.findIndex(u => u.id === targetShip.id);
        if (index > -1) gameState.units.splice(index, 1);
        addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Í≥µÍ≤©! Ï†Å ${UNITS[targetShip.type].name} Í≤©Ïπ®!`, 'action');
      } else {
        addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Í≥µÍ≤©! Ï†Å ${UNITS[targetShip.type].name}Ïóê ${damage} ÌîºÌï¥ (ÎÇ®ÏùÄ HP: ${targetShip.hp})`, 'action');
      }
      
      hideActionMenu(true);
      renderMap();
    }
    
    // Ìï≠Íµ¨ Í≥µÍ≤©
    function attackHarbor(tile) {
      if (tile.type !== 'harbor' || tile.owner !== 'enemy') {
        addLog('Ï†Å Ìï≠Íµ¨Í∞Ä ÏïÑÎãôÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Í≥µÍ≤© Í∞ÄÎä•Ìïú Ï†ÑÌï® Ï∞æÍ∏∞
      const attackingShip = gameState.units.find(u => 
        u.owner === 'player' && 
        u.type === 'attack_ship' && 
        !u.moved &&
        Math.abs(u.x - tile.x) <= UNITS.attack_ship.attackRange &&
        Math.abs(u.y - tile.y) <= UNITS.attack_ship.attackRange
      );
      
      if (!attackingShip) {
        addLog('Í≥µÍ≤© Í∞ÄÎä•Ìïú Ï†ÑÌï®Ïù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ï†ÑÌï® ÌñâÎèô ÏôÑÎ£å
      attackingShip.moved = true;
      
      // Ìï≠Íµ¨Ïóê Îç∞ÎØ∏ÏßÄ
      const damage = UNITS.attack_ship.damageToHarbor;
      tile.harborHp -= damage;
      
      if (tile.harborHp <= 0) {
        tile.harborHp = 0;
        tile.type = 'destroyed_harbor';
        addLog(`üí• Ï†Å Ìï≠Íµ¨ ÌååÍ¥¥! (${tile.x}, ${tile.y})`, 'action');
      } else {
        addLog(`üí• Ï†Å Ìï≠Íµ¨ Í≥µÍ≤©! ${damage} ÌîºÌï¥ (ÎÇ®ÏùÄ HP: ${tile.harborHp})`, 'action');
      }
      
      hideActionMenu(true);
      renderMap();
    }
    
    // Ìï≠Íµ¨ Ïû¨Í±¥
    function rebuildHarbor(tile) {
      const rebuildCost = 5000;
      
      if (tile.type !== 'destroyed_harbor') {
        addLog('ÌååÍ¥¥Îêú Ìï≠Íµ¨Í∞Ä ÏïÑÎãôÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < rebuildCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ïù∏Ï†ë Í±¥Ï∂ïÍ∞Ä ÌôïÏù∏
      const engineer = hasAdjacentEngineer(tile.x, tile.y);
      if (!engineer) {
        addLog('Ïù∏Ï†ëÌïú Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= rebuildCost;
      
      // Í±¥Ï∂ïÍ∞Ä ÌñâÎèô ÏôÑÎ£å
      engineer.moved = true;
      
      // Ìï≠Íµ¨ Ïû¨Í±¥
      tile.type = 'harbor';
      tile.owner = 'player';
      tile.harborHp = 10000;
      
      addLog(`üîß Ìï≠Íµ¨ Ïû¨Í±¥ ÏôÑÎ£å! (${tile.x}, ${tile.y}) (-${rebuildCost} ÏûêÏõê)`, 'action');
      hideActionMenu(true);
      renderMap();
    }
    
    // ÎÜçÏû•/Ïò®Ïã§ Í±¥ÏÑ§
    function buildFarmStructure(buildingType) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const building = BUILDINGS[buildingType];
      if (!building) return;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < building.cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ïù∏Ï†ë ÎÜçÎ∂Ä ÌôïÏù∏
      const farmer = hasAdjacentFarmer(tile.x, tile.y);
      if (!farmer) {
        addLog('Ïù∏Ï†ëÌïú ÎÜçÎ∂ÄÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÌÉÄÏùº Ï≤¥ÌÅ¨
      if (tile.type !== 'empty' || getBuildingAt(tile.x, tile.y) || getUnitAt(tile.x, tile.y)) {
        addLog('Ïù¥ ÏúÑÏπòÏóêÎäî Í±¥ÏÑ§Ìï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùº Ï≤¥ÌÅ¨
      const isCaptured = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      if (tile.y < PLAYER_ZONE_START && !isCaptured) {
        addLog('ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùºÏóêÎßå Í±¥ÏÑ§Ìï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= building.cost;
      
      // ÎÜçÎ∂Ä ÌñâÎèô ÏôÑÎ£å Ï≤òÎ¶¨
      farmer.moved = true;
      
      // Í±¥Î¨º Í±¥ÏÑ§
      gameState.buildings.push({
        type: buildingType,
        x: tile.x,
        y: tile.y,
        owner: 'player',
        hp: building.hp,
        level: 1
      });
      
      addLog(`(${tile.x}, ${tile.y})Ïóê ${building.name} Í±¥ÏÑ§ ÏôÑÎ£å! (-${building.cost} ÏûêÏõê, ÌÑ¥Îãπ +${building.income} ÏàòÏûÖ)`, 'action');
      hideActionMenu(true);
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // Íµ∞ÏÇ¨ ÏãúÏÑ§ Í±¥ÏÑ§ (Î∞ïÍ≤©Ìè¨ Îì±)
    function buildMilitaryStructure(buildingType) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const building = BUILDINGS[buildingType];
      if (!building) return;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < building.cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ïù∏Ï†ë Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞Ä ÌôïÏù∏
      const militaryEngineer = hasAdjacentMilitaryEngineer(tile.x, tile.y);
      if (!militaryEngineer) {
        addLog('Ïù∏Ï†ëÌïú Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÌÉÄÏùº Ï≤¥ÌÅ¨
      if (tile.type !== 'empty' || getBuildingAt(tile.x, tile.y) || getUnitAt(tile.x, tile.y)) {
        addLog('Ïù¥ ÏúÑÏπòÏóêÎäî Í±¥ÏÑ§Ìï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùº Ï≤¥ÌÅ¨
      const isCapturedTile = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      if (tile.y < PLAYER_ZONE_START && !isCapturedTile) {
        addLog('ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùºÏóêÎßå Í±¥ÏÑ§Ìï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= building.cost;
      
      // Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞Ä ÌñâÎèô ÏôÑÎ£å Ï≤òÎ¶¨
      militaryEngineer.moved = true;
      
      // Í±¥Î¨º Í±¥ÏÑ§
      gameState.buildings.push({
        type: buildingType,
        x: tile.x,
        y: tile.y,
        owner: 'player',
        hp: building.hp,
        fired: false,
        level: 1
      });
      
      addLog(`(${tile.x}, ${tile.y})Ïóê ${building.name} Í±¥ÏÑ§ ÏôÑÎ£å! (-${building.cost.toLocaleString()} ÏûêÏõê)`, 'action');
      hideActionMenu(true);
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ ÏÉÅÌÉú
    let mortarState = {
      mortarX: 0,
      mortarY: 0,
      mortar: null
    };
    
    // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ Î™®Îã¨ ÌëúÏãú
    function showMortarFireModal() {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const mortar = getBuildingAt(tile.x, tile.y);
      if (!mortar || mortar.type !== 'mortar') return;
      
      hideActionMenu();
      
      mortarState.mortarX = tile.x;
      mortarState.mortarY = tile.y;
      mortarState.mortar = mortar;
      
      // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÌÉÄÍ≤ü Î™©Î°ù ÌëúÏãú
      renderMortarTargets();
      
      document.getElementById('mortar-fire-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ Î™®Îã¨ Îã´Í∏∞
    function hideMortarFireModal() {
      document.getElementById('mortar-fire-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // Î∞ïÍ≤©Ìè¨ ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÌÉÄÍ≤ü Î†åÎçîÎßÅ
    function renderMortarTargets() {
      const listEl = document.getElementById('mortar-target-list');
      listEl.innerHTML = '';
      
      const mortarDef = BUILDINGS.mortar;
      const range = getBuildingRange(mortarState.mortar); // Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÇ¨Í±∞Î¶¨
      const targets = [];
      
      // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ Î™®Îì† ÌÉÄÏùº ÌôïÏù∏
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          const distance = Math.abs(x - mortarState.mortarX) + Math.abs(y - mortarState.mortarY);
          if (distance > 0 && distance <= range) {
            const tile = gameState.map[y][x];
            if (!tile.visible) continue; // ÏïàÍ∞úÎäî Í≥µÍ≤© Î∂àÍ∞Ä
            
            // Ï†Å Ïú†Îãõ Ï≤¥ÌÅ¨ (ÎπÑÌñâ Ïú†Îãõ Ï†úÏô∏)
            const enemyUnit = gameState.units.find(u => u.x === x && u.y === y && u.owner === 'enemy');
            if (enemyUnit) {
              const enemyUnitDef = UNITS[enemyUnit.type];
              // ÎπÑÌñâ Ïú†ÎãõÏùÄ Î∞ïÍ≤©Ìè¨Î°ú Í≥µÍ≤© Î∂àÍ∞Ä
              if (!enemyUnitDef.isAirUnit) {
                targets.push({
                  type: 'unit',
                  x, y, distance,
                  data: enemyUnit,
                  name: `Ï†Å ${UNITS[enemyUnit.type].name} (${enemyUnit.count}Î™Ö)`
                });
              }
            }
            
            // Ï†Å Í±¥Î¨º Ï≤¥ÌÅ¨
            const building = getBuildingAt(x, y);
            if (building && building.owner === 'enemy') {
              targets.push({
                type: 'building',
                x, y, distance,
                data: building,
                name: `Ï†Å ${BUILDINGS[building.type].name} (HP: ${building.hp})`
              });
            }
            
            // Ï†Å Í∏∞ÏßÄ Ï≤¥ÌÅ¨
            if (tile.type === 'main_base' && tile.owner === 'enemy') {
              targets.push({
                type: 'base',
                x, y, distance,
                data: { key: 'main' },
                name: `Ï†Å Î≥∏Í∏∞ÏßÄ (HP: ${gameState.bases.enemy.main.toLocaleString()})`
              });
            } else if (tile.type === 'sub_base' && tile.owner === 'enemy') {
              const subKey = x < MAP_WIDTH / 2 ? 'sub1' : 'sub2';
              if (gameState.bases.enemy[subKey] > 0) {
                targets.push({
                  type: 'base',
                  x, y, distance,
                  data: { key: subKey },
                  name: `Ï†Å Î∂ÄÍ∏∞ÏßÄ (HP: ${gameState.bases.enemy[subKey].toLocaleString()})`
                });
              }
            }
          }
        }
      }
      
      if (targets.length === 0) {
        listEl.innerHTML = '<div class="no-units-message">ÏÇ¨Í±∞Î¶¨ ÎÇ¥ Í≥µÍ≤© Í∞ÄÎä•Ìïú ÎåÄÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§.</div>';
        return;
      }
      
      // Í±∞Î¶¨Ïàú Ï†ïÎ†¨
      targets.sort((a, b) => a.distance - b.distance);
      
      targets.forEach(target => {
        const item = document.createElement('div');
        item.className = 'deploy-unit-item';
        item.innerHTML = `
          <div class="unit-icon">üéØ</div>
          <div class="unit-info">
            <div class="unit-name">${target.name}</div>
            <div class="unit-location">Ï¢åÌëú: (${target.x}, ${target.y}) | Í±∞Î¶¨: ${target.distance}Ïπ∏</div>
          </div>
          <div class="unit-count" style="color: #f77;">-${mortarDef.damage.toLocaleString()}</div>
        `;
        
        item.addEventListener('click', () => fireMortar(target));
        listEl.appendChild(item);
      });
    }
    
    // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ Ïã§Ìñâ
    function fireMortar(target) {
      const mortarDef = BUILDINGS.mortar;
      const damage = mortarDef.damage;
      const fireCost = mortarDef.fireCost;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < fireCost) {
        addLog('Î∞úÏÇ¨ ÎπÑÏö©Ïù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= fireCost;
      
      // ÌîºÌï¥ Ï†ÅÏö©
      if (target.type === 'unit') {
        const enemyUnit = target.data;
        const targetDef = UNITS[enemyUnit.type];
        
        // ÌÉ±ÌÅ¨/Ï∞®Îüâ Ïú†ÎãõÏùÄ ÎåÄÏàò Í∏∞Î∞ò Ï≤òÎ¶¨
        if (targetDef.isTank || targetDef.isVehicle) {
          const tankHp = targetDef.tankHp || 1000;
          const destroyedCount = Math.floor(damage / tankHp);
          enemyUnit.count -= destroyedCount;
          
          if (enemyUnit.count <= 0) {
            const idx = gameState.units.findIndex(u => u.id === enemyUnit.id);
            if (idx > -1) {
              gameState.units.splice(idx, 1);
            }
            addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å ${targetDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§! (${destroyedCount}ÎåÄ ÌååÍ¥¥)`, 'action');
          } else {
            addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å ${targetDef.name} ${destroyedCount}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${enemyUnit.count}ÎåÄ)`, 'action');
          }
        } else {
          // ÏùºÎ∞ò Ïú†ÎãõÏùÄ HP Í∏∞Î∞ò Ï≤òÎ¶¨
          enemyUnit.hp -= damage;
          
          if (enemyUnit.hp <= 0) {
            const idx = gameState.units.findIndex(u => u.id === enemyUnit.id);
            if (idx > -1) {
              gameState.units.splice(idx, 1);
            }
            addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å Ïú†ÎãõÏùÑ Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§! (ÌîºÌï¥: ${damage.toLocaleString()}, Î∞úÏÇ¨ÎπÑÏö©: ${fireCost.toLocaleString()})`, 'action');
          } else {
            const hpRatio = enemyUnit.hp / targetDef.maxHp;
            enemyUnit.count = Math.max(1, Math.floor(enemyUnit.count * hpRatio));
            addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†ÅÏóêÍ≤å ${damage.toLocaleString()} ÌîºÌï¥! (ÎÇ®ÏùÄ HP: ${enemyUnit.hp})`, 'action');
          }
        }
      } else if (target.type === 'building') {
        const building = target.data;
        building.hp -= damage;
        
        if (building.hp <= 0) {
          const idx = gameState.buildings.findIndex(b => b.x === building.x && b.y === building.y);
          if (idx > -1) {
            gameState.buildings.splice(idx, 1);
          }
          addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å ${BUILDINGS[building.type].name}ÏùÑ(Î•º) ÌååÍ¥¥ÌñàÏäµÎãàÎã§!`, 'action');
        } else {
          addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å Í±¥Î¨ºÏóê ${damage.toLocaleString()} ÌîºÌï¥! (ÎÇ®ÏùÄ HP: ${building.hp})`, 'action');
        }
      } else if (target.type === 'base') {
        const baseKey = target.data.key;
        gameState.bases.enemy[baseKey] -= damage;
        
        if (gameState.bases.enemy[baseKey] <= 0) {
          gameState.bases.enemy[baseKey] = 0;
          
          if (baseKey === 'main') {
            addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å Î≥∏Í∏∞ÏßÄÎ•º ÌååÍ¥¥! ÏäπÎ¶¨!`, 'action');
            hideMortarFireModal();
            setTimeout(() => {
              handleVictory();
            }, 500);
            return;
          } else {
            addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å Î∂ÄÍ∏∞ÏßÄÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§!`, 'action');
          }
        } else {
          const baseName = baseKey === 'main' ? 'Î≥∏Í∏∞ÏßÄ' : 'Î∂ÄÍ∏∞ÏßÄ';
          addLog(`üí£ Î∞ïÍ≤©Ìè¨Í∞Ä Ï†Å ${baseName}Ïóê ${damage.toLocaleString()} ÌîºÌï¥! (ÎÇ®ÏùÄ HP: ${gameState.bases.enemy[baseKey].toLocaleString()})`, 'action');
        }
      }
      
      // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ ÏôÑÎ£å ÌëúÏãú
      mortarState.mortar.fired = true;
      
      hideMortarFireModal();
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // Íµ∞ÏÇ¨ Í±¥ÏÑ§ Î™®Îã¨ ÌëúÏãú
    function showMilitaryBuildModal() {
      hideActionMenu();
      
      // Í±¥ÏÑ§ Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
      const mortarOption = document.getElementById('build-mortar-option');
      const runwayOption = document.getElementById('build-runway-option');
      const armsFactoryOption = document.getElementById('build-arms-factory-option');
      const missileSiloOption = document.getElementById('build-missile-silo-option');
      
      if (gameState.resources.player < BUILDINGS.mortar.cost) {
        mortarOption.classList.add('disabled');
      } else {
        mortarOption.classList.remove('disabled');
      }
      
      if (gameState.resources.player < BUILDINGS.runway.cost) {
        runwayOption.classList.add('disabled');
      } else {
        runwayOption.classList.remove('disabled');
      }
      
      if (gameState.resources.player < BUILDINGS.arms_factory.cost) {
        armsFactoryOption.classList.add('disabled');
      } else {
        armsFactoryOption.classList.remove('disabled');
      }
      
      if (gameState.resources.player < BUILDINGS.missile_silo.cost) {
        missileSiloOption.classList.add('disabled');
      } else {
        missileSiloOption.classList.remove('disabled');
      }
      
      document.getElementById('military-build-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Íµ∞ÏÇ¨ Í±¥ÏÑ§ Î™®Îã¨ Îã´Í∏∞
    function hideMilitaryBuildModal(clearTile = true) {
      document.getElementById('military-build-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      if (clearTile) {
        gameState.selectedTile = null;
        renderMap();
      }
    }
    
    // Íµ∞ÏÇ¨ Í±¥ÏÑ§ ÌôïÏ†ï
    function confirmMilitaryBuild(buildingType) {
      const building = BUILDINGS[buildingType];
      if (!building) return;
      
      if (gameState.resources.player < building.cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // Î™®Îã¨Îßå Îã´Í≥† ÌÉÄÏùº Ï†ïÎ≥¥Îäî Ïú†ÏßÄ
      hideMilitaryBuildModal(false);
      buildMilitaryStructure(buildingType);
    }
    
    // ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Î™®Îã¨ ÌëúÏãú
    function showAircraftModal() {
      hideActionMenu();
      
      // ÏÉùÏÇ∞ Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
      const reconPlaneOption = document.getElementById('build-recon-plane');
      const bomberOption = document.getElementById('build-bomber');
      
      if (gameState.resources.player < UNITS.recon_plane.cost) {
        reconPlaneOption.classList.add('disabled');
      } else {
        reconPlaneOption.classList.remove('disabled');
      }
      
      if (gameState.resources.player < UNITS.bomber.cost) {
        bomberOption.classList.add('disabled');
      } else {
        bomberOption.classList.remove('disabled');
      }
      
      document.getElementById('aircraft-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Î™®Îã¨ Îã´Í∏∞
    function hideAircraftModal() {
      document.getElementById('aircraft-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ ÌôïÏ†ï
    function confirmProduceAircraft(unitType) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const unitDef = UNITS[unitType];
      if (!unitDef) return;
      
      if (gameState.resources.player < unitDef.cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      const runway = getBuildingAt(tile.x, tile.y);
      if (!runway || runway.type !== 'runway') return;
      
      // ÌôúÏ£ºÎ°ú ÏúÑÏóê Ïù¥ÎØ∏ Í∞ôÏùÄ ÌÉÄÏûÖ Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const existingUnit = gameState.units.find(u => 
        u.x === tile.x && u.y === tile.y && 
        u.type === unitType && u.owner === 'player'
      );
      
      // ÌôúÏ£ºÎ°ú ÏúÑÏóê Îã§Î•∏ Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const otherUnit = gameState.units.find(u => 
        u.x === tile.x && u.y === tile.y && u.owner === 'player' && u.type !== unitType
      );
      
      if (otherUnit) {
        // Îã§Î•∏ ÌÉÄÏûÖ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ï£ºÎ≥Ä ÌÉÄÏùºÏóê ÏÉùÏÇ∞
        const spawnTile = findSpawnTile(tile.x, tile.y);
        if (!spawnTile) {
          addLog('ÎπÑÌñâÍ∏∞Î•º Î∞∞ÏπòÌï† Í≥µÍ∞ÑÏù¥ ÏóÜÏäµÎãàÎã§!', 'system');
          return;
        }
        
        // ÏûêÏõê Ï∞®Í∞ê
        gameState.resources.player -= unitDef.cost;
        
        gameState.units.push({
          id: `unit_${Date.now()}`,
          type: unitType,
          x: spawnTile.x,
          y: spawnTile.y,
          owner: 'player',
          count: 1,
          hp: unitDef.hp,
          moved: true
        });
        
        addLog(`‚úàÔ∏è ${unitDef.name} ÏÉùÏÇ∞ ÏôÑÎ£å! (${spawnTile.x}, ${spawnTile.y}) (-${unitDef.cost.toLocaleString()} ÏûêÏõê)`, 'action');
      } else if (existingUnit) {
        // Í∞ôÏùÄ ÌÉÄÏûÖ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ìï©Î•ò
        gameState.resources.player -= unitDef.cost;
        existingUnit.count += 1;
        addLog(`‚úàÔ∏è ${unitDef.name} Ï∂îÍ∞Ä ÏÉùÏÇ∞! (Ï¥ù ${existingUnit.count}ÎåÄ, -${unitDef.cost.toLocaleString()} ÏûêÏõê)`, 'action');
      } else {
        // ÏûêÏõê Ï∞®Í∞ê
        gameState.resources.player -= unitDef.cost;
        
        // ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞
        const newUnit = {
          id: `unit_${Date.now()}`,
          type: unitType,
          x: tile.x,
          y: tile.y,
          owner: 'player',
          count: 1,
          hp: unitDef.hp,
          moved: true // ÏÉùÏÇ∞ ÏßÅÌõÑÏóêÎäî ÌñâÎèô Î∂àÍ∞Ä
        };
        
        gameState.units.push(newUnit);
        addLog(`‚úàÔ∏è ${unitDef.name} ÏÉùÏÇ∞ ÏôÑÎ£å! (-${unitDef.cost.toLocaleString()} ÏûêÏõê)`, 'action');
      }
      
      // ÌôúÏ£ºÎ°ú ÏÉùÏÇ∞ ÏôÑÎ£å ÌëúÏãú
      runway.produced = true;
      
      hideAircraftModal();
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // Í±¥Ï∂ï Î™®Îã¨ ÌëúÏãú
    function showBuildModal() {
      hideActionMenu();
      
      // Í±¥Ï∂ï Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
      const barracksOption = document.getElementById('build-barracks');
      if (gameState.resources.player < BUILDINGS.barracks.cost) {
        barracksOption.classList.add('disabled');
      } else {
        barracksOption.classList.remove('disabled');
      }
      
      document.getElementById('build-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Í±¥Ï∂ï Î™®Îã¨ Îã´Í∏∞
    function hideBuildModal() {
      document.getElementById('build-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ==================== Ï†ÑÎ¨∏ Í±¥Ï∂ï ÏãúÏä§ÌÖú (Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö©) ====================
    
    // Ï†ÑÎ¨∏ Í±¥Ï∂ï Î™®Îã¨ ÌëúÏãú
    function showEngineerBuildModal() {
      hideActionMenu();
      
      // Í±¥Ï∂ï Í∞ÄÎä• Ïó¨Î∂Ä Ï≤¥ÌÅ¨
      const cityOption = document.getElementById('build-city');
      if (gameState.resources.player < BUILDINGS.city.cost) {
        cityOption.classList.add('disabled');
      } else {
        cityOption.classList.remove('disabled');
      }
      
      document.getElementById('engineer-build-modal').classList.add('active');
    }
    
    // Ï†ÑÎ¨∏ Í±¥Ï∂ï Î™®Îã¨ Îã´Í∏∞
    function hideEngineerBuildModal() {
      document.getElementById('engineer-build-modal').classList.remove('active');
    }
    
    // Ï†ÑÎ¨∏ Í±¥Ï∂ï Ïã§Ìñâ
    function buildEngineerStructure(buildingType) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const building = BUILDINGS[buildingType];
      if (!building) return;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < building.cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // Ïù∏Ï†ë Í±¥Ï∂ïÍ∞Ä ÌôïÏù∏
      const engineer = hasAdjacentEngineer(tile.x, tile.y);
      if (!engineer) {
        addLog('Ïù∏Ï†ëÌïú Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // ÌÉÄÏùº Ï≤¥ÌÅ¨ (Îπà ÌÉÄÏùºÏù∏ÏßÄ)
      if (tile.type !== 'empty' || getBuildingAt(tile.x, tile.y)) {
        addLog('Ïù¥ ÏúÑÏπòÏóêÎäî Í±¥Ï∂ïÌï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùº Ï≤¥ÌÅ¨
      const isCaptured = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      if (tile.y < PLAYER_ZONE_START && !isCaptured) {
        addLog('ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùºÏóêÎßå Í±¥Ï∂ïÌï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= building.cost;
      
      // Í±¥Ï∂ïÍ∞Ä ÌñâÎèô ÏôÑÎ£å Ï≤òÎ¶¨
      engineer.moved = true;
      
      // Í±¥Î¨º Ï∂îÍ∞Ä
      gameState.buildings.push({
        type: buildingType,
        x: tile.x,
        y: tile.y,
        owner: 'player',
        hp: building.hp,
        level: 1
      });
      
      addLog(`üèóÔ∏è ${building.name} Í±¥ÏÑ§ ÏôÑÎ£å! (üí∞ -${building.cost.toLocaleString()})`, 'action');
      
      hideEngineerBuildModal();
      updateResourceDisplay();
      renderMap();
    }
    
    // ==================== Ï†ÑÎ¨∏ Í±¥Ï∂ï ÏãúÏä§ÌÖú ÎÅù ====================
    
    // Í±¥Î¨º Í±¥Ï∂ï
    function buildStructure(buildingType) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const building = BUILDINGS[buildingType];
      if (!building) return;
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      if (gameState.resources.player < building.cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // ÌÉÄÏùº Ï≤¥ÌÅ¨ (Îπà ÌÉÄÏùºÏù∏ÏßÄ)
      if (tile.type !== 'empty' || getBuildingAt(tile.x, tile.y) || getUnitAt(tile.x, tile.y)) {
        addLog('Ïù¥ ÏúÑÏπòÏóêÎäî Í±¥Ï∂ïÌï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùº Ï≤¥ÌÅ¨
      const isCaptured = gameState.capturedTiles.player.some(t => t.x === tile.x && t.y === tile.y);
      if (tile.y < PLAYER_ZONE_START && !isCaptured) {
        addLog('ÏïÑÍµ∞ ÏßÑÏòÅ ÎòêÎäî Ï†êÎ†πÎêú ÌÉÄÏùºÏóêÎßå Í±¥Ï∂ïÌï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= building.cost;
      
      // Í±¥Î¨º Ï∂îÍ∞Ä
      gameState.buildings.push({
        type: buildingType,
        x: tile.x,
        y: tile.y,
        owner: 'player',
        hp: building.hp,
        level: 1
      });
      
      addLog(`(${tile.x}, ${tile.y})Ïóê ${building.name} Í±¥Ï∂ï ÏôÑÎ£å! (-${building.cost} ÏûêÏõê)`, 'action');
      hideBuildModal();
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // ÏßïÎ≥ë ÏÉÅÌÉú
    let recruitState = {
      quantity: 100,
      unitType: 'soldier',
      step: 'select' // 'select' or 'quantity'
    };
    
    // ÏßïÎ≥ë Î™®Îã¨ ÌëúÏãú
    function showRecruitModal() {
      hideActionMenu();
      recruitState.step = 'select';
      recruitState.quantity = 100;
      recruitState.unitType = 'soldier';
      
      document.getElementById('recruit-type-select').style.display = 'block';
      document.getElementById('recruit-control').style.display = 'none';
      
      // Ïú†Îãõ ÏòµÏÖò ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
      document.querySelectorAll('#recruit-type-select .build-option').forEach(opt => {
        const unitType = opt.dataset.unit;
        const unit = UNITS[unitType];
        if (gameState.resources.player < unit.cost) {
          opt.classList.add('disabled');
        } else {
          opt.classList.remove('disabled');
        }
      });
      
      document.getElementById('recruit-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÏßïÎ≥ë Ïú†Îãõ ÌÉÄÏûÖ ÏÑ†ÌÉù
    function selectRecruitUnit(unitType) {
      const unit = UNITS[unitType];
      if (!unit || gameState.resources.player < unit.cost) return;
      
      recruitState.unitType = unitType;
      recruitState.step = 'quantity';
      // Î≥ëÏÇ¨, ÌäπÍ≥µÎåÄÎäî 100Î™Ö Îã®ÏúÑ
      const isBulkUnit = unitType === 'soldier' || unitType === 'commando';
      recruitState.quantity = isBulkUnit ? 100 : 1;
      
      // UI ÏóÖÎç∞Ïù¥Ìä∏
      document.getElementById('recruit-type-select').style.display = 'none';
      document.getElementById('recruit-control').style.display = 'block';
      
      document.getElementById('recruit-unit-icon').textContent = unit.icon;
      document.getElementById('recruit-unit-name').textContent = unit.name;
      document.getElementById('recruit-stat-atk').textContent = unit.attack;
      document.getElementById('recruit-stat-def').textContent = unit.defense;
      document.getElementById('recruit-stat-hp').textContent = unit.hp;
      
      updateRecruitModal();
    }
    
    // ÏßïÎ≥ë Î™®Îã¨ Îã´Í∏∞
    function hideRecruitModal() {
      document.getElementById('recruit-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ÏßïÎ≥ë Î™®Îã¨ ÏóÖÎç∞Ïù¥Ìä∏
    function updateRecruitModal() {
      const unit = UNITS[recruitState.unitType];
      const isBulkUnit = recruitState.unitType === 'soldier' || recruitState.unitType === 'commando' || recruitState.unitType === 'anti_tank';
      const multiplier = isBulkUnit ? (recruitState.quantity / 100) : recruitState.quantity;
      const cost = Math.floor(multiplier * unit.cost);
      
      document.getElementById('recruit-quantity').textContent = recruitState.quantity;
      document.getElementById('recruit-preview-count').textContent = recruitState.quantity + 'Î™Ö';
      document.getElementById('recruit-total-cost').textContent = cost.toLocaleString();
      
      // Î≤ÑÌäº ÌôúÏÑ±Ìôî/ÎπÑÌôúÏÑ±Ìôî
      const minQty = isBulkUnit ? 100 : 1;
      const step = isBulkUnit ? 100 : 1;
      const nextCost = Math.floor(((recruitState.quantity + step) / (isBulkUnit ? 100 : 1)) * unit.cost);
      
      document.getElementById('recruit-minus').disabled = recruitState.quantity <= minQty;
      document.getElementById('recruit-plus').disabled = gameState.resources.player < nextCost;
      document.getElementById('confirm-recruit').disabled = gameState.resources.player < cost;
      document.getElementById('recruit-available').textContent = gameState.resources.player.toLocaleString();
    }
    
    // ÏßïÎ≥ë ÏàòÎüâ Î≥ÄÍ≤Ω
    function changeRecruitQuantity(delta) {
      const unit = UNITS[recruitState.unitType];
      const isBulkUnit = recruitState.unitType === 'soldier' || recruitState.unitType === 'commando' || recruitState.unitType === 'anti_tank';
      const step = isBulkUnit ? 100 : 1;
      const actualDelta = delta > 0 ? step : -step;
      
      const newQuantity = recruitState.quantity + actualDelta;
      const multiplier = isBulkUnit ? (newQuantity / 100) : newQuantity;
      const newCost = Math.floor(multiplier * unit.cost);
      
      const minQty = isBulkUnit ? 100 : 1;
      if (newQuantity >= minQty && gameState.resources.player >= newCost) {
        recruitState.quantity = newQuantity;
        updateRecruitModal();
      }
    }
    
    // ÏµúÎåÄ Íµ¨Îß§
    function maxRecruit() {
      const unit = UNITS[recruitState.unitType];
      const isBulkUnit = recruitState.unitType === 'soldier' || recruitState.unitType === 'commando' || recruitState.unitType === 'anti_tank';
      const step = isBulkUnit ? 100 : 1;
      
      // Íµ¨Îß§ Í∞ÄÎä•Ìïú ÏµúÎåÄ ÏàòÎüâ Í≥ÑÏÇ∞
      const costPerUnit = isBulkUnit ? (unit.cost / 100) : unit.cost;
      const maxAffordable = Math.floor(gameState.resources.player / costPerUnit);
      const maxQuantity = Math.floor(maxAffordable / step) * step;
      
      const minQty = isBulkUnit ? 100 : 1;
      if (maxQuantity >= minQty) {
        recruitState.quantity = maxQuantity;
        updateRecruitModal();
      }
    }
    
    // ÏßïÎ≥ë ÌôïÏ†ï
    function confirmRecruit() {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      const unit = UNITS[recruitState.unitType];
      const isBulkUnit = recruitState.unitType === 'soldier' || recruitState.unitType === 'commando' || recruitState.unitType === 'anti_tank';
      const multiplier = isBulkUnit ? (recruitState.quantity / 100) : recruitState.quantity;
      const cost = Math.floor(multiplier * unit.cost);
      
      if (gameState.resources.player < cost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= cost;
      
      // Î®ºÏ†Ä ÏßïÎ≥ëÏÜå ÏúÑÏóê Í∞ôÏùÄ ÌÉÄÏûÖ Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const unitOnBarracks = gameState.units.find(u => 
        u.x === tile.x && u.y === tile.y && 
        u.type === recruitState.unitType && u.owner === 'player'
      );
      
      if (unitOnBarracks) {
        // ÏßïÎ≥ëÏÜå ÏúÑÏóê Í∞ôÏùÄ ÌÉÄÏûÖ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ìï©Î•ò
        unitOnBarracks.count += recruitState.quantity;
        addLog(`${unit.name} ${recruitState.quantity}Î™Ö Ï∂îÍ∞Ä ÏßïÎ≥ë! (Ï¥ù ${unitOnBarracks.count}Î™Ö, -${cost} ÏûêÏõê)`, 'action');
      } else {
        // Ïú†Îãõ Î∞∞Ïπò ÏúÑÏπò Ï∞æÍ∏∞
        const spawnTile = findSpawnTile(tile.x, tile.y);
        if (spawnTile) {
          // Í∞ôÏùÄ ÏúÑÏπòÏóê Í∞ôÏùÄ ÌÉÄÏûÖ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ìï©Î•ò
          const existingUnit = gameState.units.find(u => 
            u.x === spawnTile.x && u.y === spawnTile.y && 
            u.type === recruitState.unitType && u.owner === 'player'
          );
          
          if (existingUnit) {
            existingUnit.count += recruitState.quantity;
            addLog(`${unit.name} ${recruitState.quantity}Î™Ö Ï∂îÍ∞Ä ÏßïÎ≥ë! (Ï¥ù ${existingUnit.count}Î™Ö, -${cost} ÏûêÏõê)`, 'action');
          } else {
            gameState.units.push({
              id: Date.now(),
              type: recruitState.unitType,
              x: spawnTile.x,
              y: spawnTile.y,
              owner: 'player',
              count: recruitState.quantity,
              hp: unit.hp,
              moved: true // ÏÉàÎ°ú ÏßïÎ≥ëÎêú Ïú†ÎãõÏùÄ Ïù¥Î≤à ÌÑ¥Ïóê ÌñâÎèô Î∂àÍ∞Ä
            });
            addLog(`(${spawnTile.x}, ${spawnTile.y})Ïóê ${unit.name} ${recruitState.quantity}Î™Ö ÏßïÎ≥ë! (-${cost} ÏûêÏõê)`, 'action');
          }
        } else {
          addLog('Ïú†ÎãõÏùÑ Î∞∞ÏπòÌï† Í≥µÍ∞ÑÏù¥ ÏóÜÏäµÎãàÎã§!', 'system');
          gameState.resources.player += cost; // ÏûêÏõê ÌôòÎ∂à
          hideRecruitModal();
          return;
        }
      }
      
      hideRecruitModal();
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // ÌñâÍµ∞/Ï£ºÎëî ÏÉÅÌÉú
    let deployState = {
      mode: 'march', // 'march' or 'station'
      targetX: 0,
      targetY: 0
    };
    
    // ÌñâÍµ∞/Ï£ºÎëî Î™®Îã¨ ÌëúÏãú
    function showDeployModal(mode) {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      hideActionMenu();
      
      deployState.mode = mode;
      deployState.targetX = tile.x;
      deployState.targetY = tile.y;
      
      // Î™®Îã¨ ÌÉÄÏù¥ÌãÄ ÏÑ§Ï†ï
      const titleIcon = mode === 'march' ? 'üö∂' : 'üèïÔ∏è';
      const titleText = mode === 'march' ? 'ÌñâÍµ∞' : 'Ï£ºÎëî';
      document.getElementById('deploy-modal-title').textContent = `${titleIcon} ${titleText}`;
      document.getElementById('deploy-target-coords').textContent = `${tile.x}, ${tile.y}`;
      
      // Ïù¥Îèô Í∞ÄÎä•Ìïú Ïú†Îãõ Î™©Î°ù ÌëúÏãú
      renderDeployUnitList();
      
      document.getElementById('deploy-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÌñâÍµ∞/Ï£ºÎëî Î™®Îã¨ Îã´Í∏∞
    function hideDeployModal() {
      document.getElementById('deploy-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // Ïù¥Îèô Í∞ÄÎä•Ìïú Ïú†Îãõ Î™©Î°ù Î†åÎçîÎßÅ
    function renderDeployUnitList() {
      const listEl = document.getElementById('deploy-unit-list');
      listEl.innerHTML = '';
      
      // ÌîåÎ†àÏù¥Ïñ¥ Ïú†Îãõ Ï§ë Ïù¥Îèô Í∞ÄÎä•Ìïú Ïú†Îãõ ÌïÑÌÑ∞ÎßÅ
      // Í≥µÏ§ëÎßµÏù¥Î©¥ Í≥µÏ§ë Ïú†ÎãõÎßå, ÏßÄÏÉÅÎßµÏù¥Î©¥ ÎπÑÍ≥µÏ§ë Ïú†ÎãõÎßå
      let availableUnits;
      if (currentMapView === 'air') {
        availableUnits = gameState.units.filter(u => 
          u.owner === 'player' && UNITS[u.type].isAirUnit
        );
      } else {
        availableUnits = gameState.units.filter(u => 
          u.owner === 'player' && !UNITS[u.type].isAirUnit
        );
      }
      
      if (availableUnits.length === 0) {
        const msg = currentMapView === 'air' 
          ? 'Í≥µÏ§ë Ïú†ÎãõÏù¥ ÏóÜÏäµÎãàÎã§.<br>ÌôúÏ£ºÎ°úÏóêÏÑú Ï†ïÏ∞∞Í∏∞Î•º ÏÉùÏÇ∞ÌïòÏÑ∏Ïöî.'
          : 'Ïù¥Îèô Í∞ÄÎä•Ìïú Ïú†ÎãõÏù¥ ÏóÜÏäµÎãàÎã§.<br>ÏßïÎ≥ëÏÜåÏóêÏÑú Ïú†ÎãõÏùÑ ÏßïÎ≥ëÌïòÏÑ∏Ïöî.';
        listEl.innerHTML = `<div class="no-units-message">${msg}</div>`;
        return;
      }
      
      availableUnits.forEach(unit => {
        const unitDef = UNITS[unit.type];
        const distance = Math.abs(unit.x - deployState.targetX) + Math.abs(unit.y - deployState.targetY);
        const canMove = !unit.moved && distance <= unitDef.moveRange && distance > 0;
        
        // Î™©Ìëú ÌÉÄÏùºÏóê Ïù¥ÎØ∏ Îã§Î•∏ Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨
        const targetUnit = getUnitAt(deployState.targetX, deployState.targetY);
        const canMerge = targetUnit && targetUnit.type === unit.type && targetUnit.owner === 'player' && targetUnit.id !== unit.id;
        
        // Í≥µÏ§ë Ïú†ÎãõÏùÄ Í≥µÏ§ë Ïú†ÎãõÎÅºÎ¶¨Îßå Ï∂©Îèå, ÏßÄÏÉÅ/Ìï¥ÏÉÅ Ïú†ÎãõÏùÄ ÏßÄÏÉÅ/Ìï¥ÏÉÅÎÅºÎ¶¨Îßå Ï∂©Îèå
        let targetOccupied = false;
        if (targetUnit && !canMerge) {
          const targetUnitDef = UNITS[targetUnit.type];
          if (unitDef.isAirUnit) {
            // Í≥µÏ§ë Ïú†ÎãõÏùÄ Í≥µÏ§ë Ïú†ÎãõÎßå Ï∂©Îèå
            targetOccupied = targetUnitDef.isAirUnit;
          } else {
            // ÏßÄÏÉÅ/Ìï¥ÏÉÅ Ïú†ÎãõÏùÄ ÏßÄÏÉÅ/Ìï¥ÏÉÅ Ïú†ÎãõÎßå Ï∂©Îèå
            targetOccupied = !targetUnitDef.isAirUnit;
          }
        }
        
        // Î™©Ìëú ÌÉÄÏùº Ï†ïÎ≥¥
        const targetTile = gameState.map[deployState.targetY][deployState.targetX];
        
        // ÏïàÍ∞ú ÏßÄÏó≠ Ï≤¥ÌÅ¨ (Ï†ïÏ∞∞Î≥ë, ÎπÑÌñâ Ïú†Îãõ Ïù¥Îèô Í∞ÄÎä•)
        const isFog = !targetTile.visible;
        const canEnterFog = !isFog || unitDef.canScout || unitDef.isAirUnit;
        
        // Î∞îÎã§ Ï≤¥ÌÅ¨ - Ìï¥Íµ∞ Ïú†ÎãõÏùÄ Î∞îÎã§Îßå, ÏùºÎ∞ò Ïú†ÎãõÏùÄ Î∞îÎã§ Î∂àÍ∞Ä, Í≥µÏ§ë Ïú†ÎãõÏùÄ Ïñ¥ÎîîÎì† Í∞ÄÎä•
        const isSea = targetTile.terrain === 'sea';
        let canMoveTerrain = true;
        if (unitDef.isNavalUnit) {
          canMoveTerrain = isSea; // Ìï¥Íµ∞ÏùÄ Î∞îÎã§Îßå Í∞ÄÎä•
        } else if (!unitDef.isAirUnit) {
          canMoveTerrain = !isSea; // ÏùºÎ∞ò Ïú†ÎãõÏùÄ Î∞îÎã§ Î∂àÍ∞Ä
        }
        // Í≥µÏ§ë Ïú†ÎãõÏùÄ Ïñ¥ÎîîÎì† Í∞ÄÎä• (canMoveTerrain = true Ïú†ÏßÄ)
        
        const isAvailable = canMove && !targetOccupied && canEnterFog && canMoveTerrain;
        
        let statusText = 'ÎåÄÍ∏∞Ï§ë';
        let statusClass = '';
        if (unit.moved) {
          statusText = 'ÌñâÎèôÏôÑÎ£å';
          statusClass = 'moved';
        } else if (distance === 0) {
          statusText = 'Í∞ôÏùÄÏúÑÏπò';
          statusClass = 'moved';
        } else if (distance > unitDef.moveRange) {
          statusText = 'Î≤îÏúÑÏ¥àÍ≥º';
          statusClass = 'moved';
        } else if (targetOccupied) {
          statusText = 'Ï†êÎ†πÎê®';
          statusClass = 'moved';
        } else if (isFog && !unitDef.canScout && !unitDef.isAirUnit) {
          statusText = 'Ï†ïÏ∞∞ÌïÑÏöî';
          statusClass = 'moved';
        } else if (unitDef.isNavalUnit && !isSea) {
          statusText = 'Î∞îÎã§ÎßåÍ∞ÄÎä•';
          statusClass = 'moved';
        } else if (!unitDef.isNavalUnit && !unitDef.isAirUnit && isSea) {
          statusText = 'Î∞îÎã§Î∂àÍ∞Ä';
          statusClass = 'moved';
        }
        
        const item = document.createElement('div');
        item.className = 'deploy-unit-item' + (isAvailable ? '' : ' disabled');
        const unitCountText = unitDef.isTank ? `${unit.count}ÎåÄ` : `${unit.count}Î™Ö`;
        item.innerHTML = `
          <div class="unit-icon">${unitDef.icon}</div>
          <div class="unit-info">
            <div class="unit-name">${unitDef.name}</div>
            <div class="unit-location">ÏúÑÏπò: (${unit.x}, ${unit.y}) | Í±∞Î¶¨: ${distance}Ïπ∏</div>
          </div>
          <div class="unit-count">${unitCountText}</div>
          <div class="unit-status ${statusClass}">${statusText}</div>
        `;
        
        if (isAvailable) {
          item.addEventListener('click', () => deployUnit(unit));
        }
        
        listEl.appendChild(item);
      });
    }
    
    // Ïú†Îãõ Ïù¥Îèô/Ï£ºÎëî Ïã§Ìñâ
    function deployUnit(unit) {
      const unitDef = UNITS[unit.type];
      const targetX = deployState.targetX;
      const targetY = deployState.targetY;
      
      // Í±∞Î¶¨ Ï≤¥ÌÅ¨
      const distance = Math.abs(unit.x - targetX) + Math.abs(unit.y - targetY);
      if (distance > unitDef.moveRange || distance === 0) {
        addLog('Ïù¥ÎèôÌï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // Ïù¥ÎØ∏ Ïù¥ÎèôÌïú Ïú†Îãõ Ï≤¥ÌÅ¨
      if (unit.moved) {
        addLog('Ïù¥ Ïú†ÎãõÏùÄ Ïù¥ÎØ∏ ÌñâÎèôÌñàÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // Î™©Ìëú ÌÉÄÏùº Ï≤¥ÌÅ¨
      const targetTile = gameState.map[targetY][targetX];
      const hasBridge = getBuildingAt(targetX, targetY)?.type === 'bridge';
      
      // Ìï¥Íµ∞ Ïú†Îãõ(Ï†ÑÌï®)ÏùÄ Î∞îÎã§ÏóêÏÑúÎßå Ïù¥Îèô Í∞ÄÎä•
      if (unitDef.isNavalUnit) {
        if (targetTile.terrain !== 'sea') {
          addLog('Ï†ÑÌï®ÏùÄ Î∞îÎã§ÏóêÏÑúÎßå Ïù¥ÎèôÌï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
          return;
        }
      } else {
        // ÏùºÎ∞ò Ïú†ÎãõÏùÄ Î∞îÎã§Î°ú Ïù¥Îèô Î∂àÍ∞Ä (ÎπÑÌñâ Ïú†Îãõ Ï†úÏô∏)
        if (targetTile.terrain === 'sea' && !unitDef.isAirUnit) {
          addLog('Î∞îÎã§Î°ú Ïù¥ÎèôÌï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
          return;
        }
      }
      
      // ÏïàÍ∞ú ÏßÄÏó≠ Ï≤¥ÌÅ¨ (Ï†ïÏ∞∞Î≥ë, ÎπÑÌñâ Ïú†ÎãõÎßå Ïù¥Îèô Í∞ÄÎä•)
      if (!targetTile.visible && !unitDef.canScout && !unitDef.isAirUnit) {
        addLog('ÏïàÍ∞ú ÏßÄÏó≠ÏûÖÎãàÎã§! Ï†ïÏ∞∞Î≥ëÎßå Ïù¥ÎèôÌï† Ïàò ÏûàÏäµÎãàÎã§.', 'system');
        return;
      }
      
      // Î™©Ìëú ÏúÑÏπòÏóê Í∞ôÏùÄ ÌÉÄÏûÖ ÏïÑÍµ∞ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ìï©Î•ò
      const existingUnit = gameState.units.find(u => 
        u.x === targetX && u.y === targetY && 
        u.type === unit.type && u.owner === 'player' && u.id !== unit.id
      );
      
      if (existingUnit) {
        existingUnit.count += unit.count;
        // Í∏∞Ï°¥ Ïú†Îãõ Ï†úÍ±∞
        const unitIndex = gameState.units.findIndex(u => u.id === unit.id);
        if (unitIndex > -1) {
          gameState.units.splice(unitIndex, 1);
        }
        existingUnit.moved = true;
        addLog(`${unitDef.name}Í∞Ä (${targetX}, ${targetY})Ïùò Î∂ÄÎåÄÏóê Ìï©Î•ò! (Ï¥ù ${existingUnit.count}Î™Ö)`, 'action');
      } else {
        // Îã§Î•∏ Ïú†ÎãõÏù¥ ÏûàÎäîÏßÄ Ï≤¥ÌÅ¨ (Í≥µÏ§ë Ïú†ÎãõÏùÄ Í≥µÏ§ëÎÅºÎ¶¨Îßå, ÏßÄÏÉÅ/Ìï¥ÏÉÅÏùÄ ÏßÄÏÉÅ/Ìï¥ÏÉÅÎÅºÎ¶¨Îßå Ï∂©Îèå)
        const otherUnit = getUnitAt(targetX, targetY);
        if (otherUnit) {
          const otherUnitDef = UNITS[otherUnit.type];
          // Í≥µÏ§ë Ïú†ÎãõÎÅºÎ¶¨ ÎòêÎäî ÏßÄÏÉÅ/Ìï¥ÏÉÅ Ïú†ÎãõÎÅºÎ¶¨Îßå Ï∂©Îèå
          const bothAir = unitDef.isAirUnit && otherUnitDef.isAirUnit;
          const bothGround = !unitDef.isAirUnit && !otherUnitDef.isAirUnit;
          
          if (bothAir || bothGround) {
            addLog('Ìï¥Îãπ ÏúÑÏπòÏóê Îã§Î•∏ Ïú†ÎãõÏù¥ ÏûàÏäµÎãàÎã§!', 'system');
            return;
          }
        }
        
        // Ïú†Îãõ Ïù¥Îèô
        const oldX = unit.x;
        const oldY = unit.y;
        unit.x = targetX;
        unit.y = targetY;
        unit.moved = true;
        
        const modeText = deployState.mode === 'march' ? 'ÌñâÍµ∞' : 'Ï£ºÎëî';
        addLog(`${unitDef.name} (${oldX}, ${oldY}) ‚Üí (${targetX}, ${targetY}) ${modeText}`, 'action');
        
        // ÌÉ±ÌÅ¨/Ï∞®ÎüâÏù¥Î©¥ ÏßÄÎ¢∞ Ï≤¥ÌÅ¨
        if (unitDef.isTank || unitDef.isVehicle) {
          const destroyed = checkMineOnPath(unit, oldX, oldY, targetX, targetY);
          if (destroyed) {
            hideDeployModal();
            renderMap();
            setTimeout(() => endTurn(), 100);
            return;
          }
        }
      }
      
      // Ï†ïÏ∞∞Î≥ëÏù¥ ÏïàÍ∞ú ÏßÄÏó≠Ïóê Ïù¥ÎèôÌïòÎ©¥ ÏïàÍ∞ú Ï†úÍ±∞ (ÏòÅÍµ¨Ï†Å)
      if (unitDef.canScout && !targetTile.visible) {
        targetTile.visible = true;
        addLog(`Ï†ïÏ∞∞Î≥ëÏù¥ (${targetX}, ${targetY}) ÏßÄÏó≠ÏùÑ Ï†ïÏ∞∞ÌñàÏäµÎãàÎã§! ÏïàÍ∞úÍ∞Ä Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§.`, 'action');
      }
      
      // Ï†ïÏ∞∞Í∏∞Í∞Ä Ï†Å ÏßÑÏòÅ(y <= ENEMY_ZONE_END)Ïóê ÏßÑÏûÖÌïòÎ©¥ Î™®Îì† ÏïàÍ∞ú Ï†úÍ±∞
      if (unitDef.canRevealAll && targetY <= ENEMY_ZONE_END) {
        let revealedCount = 0;
        for (let y = 0; y <= ENEMY_ZONE_END; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            if (!gameState.map[y][x].visible) {
              gameState.map[y][x].visible = true;
              revealedCount++;
            }
          }
        }
        addLog(`‚úàÔ∏è Ï†ïÏ∞∞Í∏∞Í∞Ä Ï†Å ÏßÑÏòÅ ÏÉÅÍ≥µÏóê ÏßÑÏûÖ! Î™®Îì† ÏïàÍ∞úÍ∞Ä Ï†úÍ±∞ÎêòÏóàÏäµÎãàÎã§! (${revealedCount}Í∞ú ÌÉÄÏùº)`, 'action');
      }
      
      hideDeployModal();
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // Ïú†Îãõ Î∞∞Ïπò ÏúÑÏπò Ï∞æÍ∏∞ (Í±¥Î¨º Ï£ºÎ≥Ä)
    function findSpawnTile(centerX, centerY) {
      // Î®ºÏ†Ä ÏßïÎ≥ëÏÜå ÏúÑÏóê Ïú†ÎãõÏù¥ ÏóÜÏúºÎ©¥ Í∑∏ ÏúÑÏóê Î∞∞Ïπò
      if (!getUnitAt(centerX, centerY)) {
        return {x: centerX, y: centerY};
      }
      
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
      ];
      
      for (const dir of directions) {
        const nx = centerX + dir.x;
        const ny = centerY + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const tile = gameState.map[ny][nx];
          const building = getBuildingAt(nx, ny);
          const unit = getUnitAt(nx, ny);
          
          // Ïú†ÎãõÏù¥ ÏóÜÍ≥†, (Îπà ÌÉÄÏùºÏù¥Í±∞ÎÇò Í∏∞ÏßÄ ÌÉÄÏùºÏù¥Í±∞ÎÇò ÌÜµÍ≥º Í∞ÄÎä•Ìïú Í±¥Î¨º)
          const isPassableTile = tile.type === 'empty' || tile.type === 'main_base' || tile.type === 'sub_base';
          const isPassableBuilding = !building || building.type === 'bridge';
          
          if (!unit && isPassableTile && isPassableBuilding) {
            return {x: nx, y: ny};
          }
        }
      }
      return null;
    }
    
    // Í≥µÍ≤© ÏÉÅÌÉú
    let attackState = {
      targetX: 0,
      targetY: 0,
      targetType: null, // 'unit', 'building', 'base'
      targetData: null
    };
    
    // Í≥µÍ≤© Î™®Îã¨ ÌëúÏãú
    function showAttackModal() {
      const tile = gameState.selectedTile;
      if (!tile) return;
      
      hideActionMenu();
      
      attackState.targetX = tile.x;
      attackState.targetY = tile.y;
      
      // Í≥µÍ≤© ÎåÄÏÉÅ ÌôïÏù∏
      const targetUnit = gameState.units.find(u => u.x === tile.x && u.y === tile.y && u.owner === 'enemy');
      const targetBuilding = getBuildingAt(tile.x, tile.y);
      const targetTile = gameState.map[tile.y][tile.x];
      
      // ÎπÑÌñâ Ïú†ÎãõÏùÄ ÏßÄÏÉÅ Ïú†ÎãõÏúºÎ°ú Í≥µÍ≤© Î∂àÍ∞Ä
      if (targetUnit) {
        const targetUnitDef = UNITS[targetUnit.type];
        if (targetUnitDef.isAirUnit) {
          addLog('‚úàÔ∏è ÎπÑÌñâ Ïú†ÎãõÏùÄ ÏßÄÏÉÅ Ïú†ÎãõÏúºÎ°ú Í≥µÍ≤©Ìï† Ïàò ÏóÜÏäµÎãàÎã§!', 'system');
          hideActionMenu(true);
          return;
        }
      }
      
      let targetInfo = '';
      if (targetUnit) {
        attackState.targetType = 'unit';
        attackState.targetData = targetUnit;
        const unitDef = UNITS[targetUnit.type];
        targetInfo = `Ï†Å ${unitDef.name} (${targetUnit.count}Î™Ö, HP: ${targetUnit.hp})`;
      } else if (targetBuilding && targetBuilding.owner === 'enemy') {
        attackState.targetType = 'building';
        attackState.targetData = targetBuilding;
        const buildingDef = BUILDINGS[targetBuilding.type];
        targetInfo = `Ï†Å ${buildingDef.name} (HP: ${targetBuilding.hp}/${buildingDef.hp})`;
      } else if (targetTile.type === 'main_base' && targetTile.owner === 'enemy') {
        attackState.targetType = 'base';
        attackState.targetData = { type: 'main', key: 'main' };
        targetInfo = `Ï†Å Î≥∏Í∏∞ÏßÄ (HP: ${gameState.bases.enemy.main.toLocaleString()}/${BASE_HP.main_base.toLocaleString()})`;
      } else if (targetTile.type === 'sub_base' && targetTile.owner === 'enemy') {
        attackState.targetType = 'base';
        // Î∂ÄÍ∏∞ÏßÄ Íµ¨Î∂Ñ (x Ï¢åÌëúÎ°ú)
        const subKey = tile.x < MAP_WIDTH / 2 ? 'sub1' : 'sub2';
        attackState.targetData = { type: 'sub', key: subKey };
        targetInfo = `Ï†Å Î∂ÄÍ∏∞ÏßÄ (HP: ${gameState.bases.enemy[subKey].toLocaleString()}/${BASE_HP.sub_base.toLocaleString()})`;
      } else {
        addLog('Í≥µÍ≤©Ìï† ÎåÄÏÉÅÏù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      document.getElementById('attack-target-info').textContent = targetInfo;
      
      // Í≥µÍ≤© Í∞ÄÎä•Ìïú Ïú†Îãõ Î™©Î°ù ÌëúÏãú
      renderAttackUnitList();
      
      document.getElementById('attack-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Í≥µÍ≤© Î™®Îã¨ Îã´Í∏∞
    function hideAttackModal() {
      document.getElementById('attack-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // Í≥µÍ≤© Í∞ÄÎä•Ìïú Ïú†Îãõ Î™©Î°ù Î†åÎçîÎßÅ
    function renderAttackUnitList() {
      const listEl = document.getElementById('attack-unit-list');
      listEl.innerHTML = '';
      
      // ÌîåÎ†àÏù¥Ïñ¥Ïùò Î≥ëÏÇ¨, ÌäπÍ≥µÎåÄ, ÌÉ±ÌÅ¨, ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏù¥ Í≥µÍ≤© Í∞ÄÎä•
      const attackableUnits = gameState.units.filter(u => 
        u.owner === 'player' && (u.type === 'soldier' || u.type === 'commando' || u.type === 'anti_tank' || UNITS[u.type].isTank)
      );
      
      if (attackableUnits.length === 0) {
        listEl.innerHTML = '<div class="no-units-message">Í≥µÍ≤© Í∞ÄÎä•Ìïú Ïú†ÎãõÏù¥ ÏóÜÏäµÎãàÎã§.<br>Î≥ëÏÇ¨, ÌäπÍ≥µÎåÄ, ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë ÎòêÎäî ÌÉ±ÌÅ¨Î•º ÏÉùÏÇ∞ÌïòÏÑ∏Ïöî.</div>';
        document.getElementById('attack-damage-preview').textContent = '0';
        return;
      }
      
      // ÎåÄÏÉÅÏù¥ ÌÉ±ÌÅ¨Ïù∏ÏßÄ ÌôïÏù∏
      const target = attackState.targetData;
      const targetDef = target ? UNITS[target.type] : null;
      const targetIsTank = targetDef?.isTank;
      
      attackableUnits.forEach(unit => {
        const unitDef = UNITS[unit.type];
        const distance = Math.abs(unit.x - attackState.targetX) + Math.abs(unit.y - attackState.targetY);
        const attackRange = unitDef.attackRange || 2;
        const canAttack = !unit.moved && distance <= attackRange;
        
        // ÌÉ±ÌÅ¨Îäî tankDamage, ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏùÄ antiTankDamage (ÎåÄ ÌÉ±ÌÅ¨), ÏùºÎ∞ò Ïú†ÎãõÏùÄ damagePercent Í∏∞Î∞ò
        let damage, damageText;
        if (unitDef.isTank) {
          damage = unitDef.tankDamage * unit.count;
          damageText = `${damage.toLocaleString()} (ÎåÄÎãπ ${unitDef.tankDamage.toLocaleString()})`;
        } else if (unitDef.antiTankDamage && targetIsTank) {
          // ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏù¥ ÌÉ±ÌÅ¨ Í≥µÍ≤© Ïãú
          damage = unit.count * unitDef.antiTankDamage;
          damageText = `${damage.toLocaleString()} (ÎåÄÏ†ÑÏ∞®)`;
        } else {
          const damagePercent = unitDef.damagePercent || 10;
          damage = Math.floor(unit.count * (damagePercent / 100));
          damageText = `${damage} (${damagePercent}%)`;
        }
        
        const unitCountText = unitDef.isTank ? `${unit.count}ÎåÄ` : `${unit.count}Î™Ö`;
        
        let statusText = 'ÎåÄÍ∏∞Ï§ë';
        let statusClass = '';
        if (unit.moved) {
          statusText = 'ÌñâÎèôÏôÑÎ£å';
          statusClass = 'moved';
        } else if (distance > attackRange) {
          statusText = 'ÏÇ¨Í±∞Î¶¨Ï¥àÍ≥º';
          statusClass = 'moved';
        }
        
        const item = document.createElement('div');
        item.className = 'deploy-unit-item' + (canAttack ? '' : ' disabled');
        item.innerHTML = `
          <div class="unit-icon">${unitDef.icon}</div>
          <div class="unit-info">
            <div class="unit-name">${unitDef.name}</div>
            <div class="unit-location">ÏúÑÏπò: (${unit.x}, ${unit.y}) | Í±∞Î¶¨: ${distance}Ïπ∏ | ÌîºÌï¥: ${damageText}</div>
          </div>
          <div class="unit-count">${unitCountText}</div>
          <div class="unit-status ${statusClass}">${statusText}</div>
        `;
        
        if (canAttack) {
          item.addEventListener('click', () => executeAttack(unit));
          item.addEventListener('mouseenter', () => {
            document.getElementById('attack-damage-preview').textContent = damage.toLocaleString();
          });
        }
        
        listEl.appendChild(item);
      });
      
      // Ï≤´ Î≤àÏß∏ Í≥µÍ≤© Í∞ÄÎä•Ìïú Ïú†ÎãõÏùò ÌîºÌï¥Îüâ ÌëúÏãú
      const firstAttackable = attackableUnits.find(u => {
        const unitDef = UNITS[u.type];
        const attackRange = unitDef.attackRange || 2;
        const distance = Math.abs(u.x - attackState.targetX) + Math.abs(u.y - attackState.targetY);
        return !u.moved && distance <= attackRange;
      });
      if (firstAttackable) {
        const unitDef = UNITS[firstAttackable.type];
        let damage;
        if (unitDef.isTank) {
          damage = unitDef.tankDamage * firstAttackable.count;
        } else {
          const damagePercent = unitDef.damagePercent || 10;
          damage = Math.floor(firstAttackable.count * (damagePercent / 100));
        }
        document.getElementById('attack-damage-preview').textContent = damage.toLocaleString();
      } else {
        document.getElementById('attack-damage-preview').textContent = '0';
      }
    }
    
    // Í≥µÍ≤© Ïã§Ìñâ
    function executeAttack(unit) {
      const unitDef = UNITS[unit.type];
      const isTank = unitDef.isTank;
      
      // === ÌÉ±ÌÅ¨ Í≥µÍ≤© Î°úÏßÅ ===
      if (isTank) {
        const tankDamage = unitDef.tankDamage * unit.count; // Ï¥ù Îç∞ÎØ∏ÏßÄ = ÎåÄÎãπ Îç∞ÎØ∏ÏßÄ * ÎåÄÏàò
        
        if (attackState.targetType === 'unit') {
          const target = attackState.targetData;
          const targetDef = UNITS[target.type];
          
          if (targetDef.isTank) {
            // ÌÉ±ÌÅ¨ vs ÌÉ±ÌÅ¨: HP Í∏∞Î∞ò Ï†ÑÌà¨
            const destroyedTanks = Math.floor(tankDamage / targetDef.tankHp);
            target.count -= destroyedTanks;
            
            if (target.count <= 0) {
              const idx = gameState.units.findIndex(u => u.id === target.id);
              if (idx > -1) gameState.units.splice(idx, 1);
              addLog(`üöú ${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}Î•º Ï†ÑÎ©∏! (${destroyedTanks}ÎåÄ ÌååÍ¥¥)`, 'action');
            } else {
              addLog(`üöú ${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}Ïóê ${destroyedTanks}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${target.count}ÎåÄ)`, 'action');
              
              // Î∞òÍ≤©: Ï†Å ÌÉ±ÌÅ¨ ‚Üí ÏïÑÍµ∞ ÌÉ±ÌÅ¨
              const counterDamage = targetDef.tankDamage * target.count;
              const counterDestroyed = Math.floor(counterDamage / unitDef.tankHp);
              unit.count -= counterDestroyed;
              
              if (unit.count <= 0) {
                const idx = gameState.units.findIndex(u => u.id === unit.id);
                if (idx > -1) gameState.units.splice(idx, 1);
                addLog(`üí• Ï†Å ${targetDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú ${unitDef.name} Ï†ÑÎ©∏!`, 'enemy');
              } else {
                addLog(`üí• Ï†Å Î∞òÍ≤©! ${counterDestroyed}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${unit.count}ÎåÄ)`, 'enemy');
              }
            }
          } else {
            // ÌÉ±ÌÅ¨ vs ÏùºÎ∞ò Ïú†Îãõ: Îç∞ÎØ∏ÏßÄ = Î≥ëÎ†• ÌîºÌï¥
            target.count -= tankDamage;
            
            if (target.count <= 0) {
              const idx = gameState.units.findIndex(u => u.id === target.id);
              if (idx > -1) gameState.units.splice(idx, 1);
              addLog(`üöú ${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏! (${tankDamage.toLocaleString()}Î™Ö ÌîºÌï¥)`, 'action');
            } else {
              addLog(`üöú ${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}Ïóê ${tankDamage.toLocaleString()}Î™Ö ÌîºÌï¥! (ÎÇ®ÏùÄ: ${target.count}Î™Ö)`, 'action');
              
              // Î∞òÍ≤©: ÏùºÎ∞ò Ïú†ÎãõÏùÄ ÌÉ±ÌÅ¨Ïóê ÏïΩÌïú ÌîºÌï¥
              const counterDamagePercent = targetDef.damagePercent || 10;
              const counterDamage = Math.floor(target.count * counterDamagePercent / 100);
              const counterDestroyed = Math.floor(counterDamage / unitDef.tankHp);
              
              if (counterDestroyed > 0) {
                unit.count -= counterDestroyed;
                if (unit.count <= 0) {
                  const idx = gameState.units.findIndex(u => u.id === unit.id);
                  if (idx > -1) gameState.units.splice(idx, 1);
                  addLog(`üí• Ï†Å Î∞òÍ≤©ÏúºÎ°ú ${unitDef.name} Ï†ÑÎ©∏!`, 'enemy');
                } else {
                  addLog(`üí• Ï†Å Î∞òÍ≤©! ${counterDestroyed}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${unit.count}ÎåÄ)`, 'enemy');
                }
              }
            }
          }
        } else if (attackState.targetType === 'building') {
          // ÌÉ±ÌÅ¨ ‚Üí Í±¥Î¨º: 5Î∞∞ ÌîºÌï¥
          const target = attackState.targetData;
          const buildingDef = BUILDINGS[target.type];
          const structureDamage = tankDamage * unitDef.structureMultiplier;
          
          target.hp -= structureDamage;
          
          if (target.hp <= 0) {
            const idx = gameState.buildings.findIndex(b => b.x === target.x && b.y === target.y);
            if (idx > -1) gameState.buildings.splice(idx, 1);
            addLog(`üöúüí• ${unitDef.name}Í∞Ä Ï†Å ${buildingDef.name}ÏùÑ(Î•º) ÌååÍ¥¥! (${structureDamage.toLocaleString()} ÌîºÌï¥)`, 'action');
          } else {
            addLog(`üöú ${unitDef.name}Í∞Ä Ï†Å ${buildingDef.name}Ïóê ${structureDamage.toLocaleString()} ÌîºÌï¥! (ÎÇ®ÏùÄ HP: ${target.hp})`, 'action');
          }
        } else if (attackState.targetType === 'base') {
          // ÌÉ±ÌÅ¨ ‚Üí Í∏∞ÏßÄ: 5Î∞∞ ÌîºÌï¥
          const baseKey = attackState.targetData.key;
          const structureDamage = tankDamage * unitDef.structureMultiplier;
          
          gameState.bases.enemy[baseKey] -= structureDamage;
          
          if (gameState.bases.enemy[baseKey] <= 0) {
            gameState.bases.enemy[baseKey] = 0;
            
            if (baseKey === 'main') {
              addLog(`üöúüí• Ï†Å Î≥∏Í∏∞ÏßÄÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§! ÏäπÎ¶¨!`, 'action');
              hideAttackModal();
              setTimeout(() => handleVictory(), 500);
              return;
            } else {
              addLog(`üöúüí• Ï†Å Î∂ÄÍ∏∞ÏßÄÎ•º ÌååÍ¥¥! (${structureDamage.toLocaleString()} ÌîºÌï¥)`, 'action');
            }
          } else {
            const baseName = baseKey === 'main' ? 'Î≥∏Í∏∞ÏßÄ' : 'Î∂ÄÍ∏∞ÏßÄ';
            addLog(`üöú ${unitDef.name}Í∞Ä Ï†Å ${baseName}Ïóê ${structureDamage.toLocaleString()} ÌîºÌï¥! (ÎÇ®ÏùÄ HP: ${gameState.bases.enemy[baseKey].toLocaleString()})`, 'action');
          }
        }
      }
      // === ÏùºÎ∞ò Ïú†Îãõ Í≥µÍ≤© Î°úÏßÅ ===
      else {
        const damagePercent = unitDef.damagePercent || 10;
        const damage = Math.floor(unit.count * damagePercent / 100);
        
        if (attackState.targetType === 'unit') {
          const target = attackState.targetData;
          const targetDef = UNITS[target.type];
          
          if (targetDef.isTank) {
            // ÏùºÎ∞ò Ïú†Îãõ ‚Üí ÌÉ±ÌÅ¨: Îç∞ÎØ∏ÏßÄÎ•º HPÎ°ú ÎÇòÎà†ÏÑú ÌÉ±ÌÅ¨ ÌååÍ¥¥
            // ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏùÄ antiTankDamage ÏÇ¨Ïö©
            let antiTankDamage;
            if (unitDef.antiTankDamage) {
              antiTankDamage = unit.count * unitDef.antiTankDamage;  // 100Î™Ö * 20 = 2000
            } else {
              antiTankDamage = damage;  // ÏùºÎ∞ò Ïú†ÎãõÏùÄ Í∏∞Ï°¥ Îç∞ÎØ∏ÏßÄ
            }
            
            const destroyedTanks = Math.floor(antiTankDamage / targetDef.tankHp);
            target.count -= destroyedTanks;
            
            if (target.count <= 0) {
              const idx = gameState.units.findIndex(u => u.id === target.id);
              if (idx > -1) gameState.units.splice(idx, 1);
              addLog(`${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏! (${destroyedTanks}ÎåÄ ÌååÍ¥¥)`, 'action');
            } else {
              addLog(`${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}Ïóê ${destroyedTanks}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${target.count}ÎåÄ)`, 'action');
              
              // ÌÉ±ÌÅ¨Ïùò Î∞òÍ≤©
              const counterDamage = targetDef.tankDamage * target.count;
              unit.count -= counterDamage;
              
              if (unit.count <= 0) {
                const idx = gameState.units.findIndex(u => u.id === unit.id);
                if (idx > -1) gameState.units.splice(idx, 1);
                addLog(`üí• Ï†Å ${targetDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú ${unitDef.name} Ï†ÑÎ©∏!`, 'enemy');
              } else {
                addLog(`üí• Ï†Å Î∞òÍ≤©! ${counterDamage.toLocaleString()}Î™Ö ÌîºÌï¥! (ÎÇ®ÏùÄ: ${unit.count}Î™Ö)`, 'enemy');
              }
            }
          } else {
            // ÏùºÎ∞ò Ïú†Îãõ vs ÏùºÎ∞ò Ïú†Îãõ (Í∏∞Ï°¥ Î°úÏßÅ)
            target.count -= damage;
            
            if (target.count <= 0) {
              const idx = gameState.units.findIndex(u => u.id === target.id);
              if (idx > -1) gameState.units.splice(idx, 1);
              addLog(`${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§! (ÌîºÌï¥: ${damage}Î™Ö)`, 'action');
            } else {
              addLog(`${unitDef.name}Í∞Ä Ï†Å ${targetDef.name}ÏóêÍ≤å ${damage}Î™Ö ÌîºÌï¥! (ÎÇ®ÏùÄ Î≥ëÎ†•: ${target.count}Î™Ö)`, 'action');
              
              const counterDamagePercent = targetDef.damagePercent || 10;
              const counterDamage = Math.floor(target.count * counterDamagePercent / 100);
              unit.count -= counterDamage;
              
              if (unit.count <= 0) {
                const idx = gameState.units.findIndex(u => u.id === unit.id);
                if (idx > -1) gameState.units.splice(idx, 1);
                addLog(`Ï†Å ${targetDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú ${unitDef.name} Ï†ÑÎ©∏!`, 'enemy');
              } else {
                addLog(`Ï†Å ${targetDef.name}Ïùò Î∞òÍ≤©! ${counterDamage}Î™Ö ÌîºÌï¥! (ÎÇ®ÏùÄ Î≥ëÎ†•: ${unit.count}Î™Ö)`, 'enemy');
              }
            }
          }
        } else if (attackState.targetType === 'building') {
          const target = attackState.targetData;
          target.hp -= damage;
          
          if (target.hp <= 0) {
            const idx = gameState.buildings.findIndex(b => b.x === target.x && b.y === target.y);
            if (idx > -1) gameState.buildings.splice(idx, 1);
            const buildingDef = BUILDINGS[target.type];
            addLog(`${unitDef.name}Í∞Ä Ï†Å ${buildingDef.name}ÏùÑ(Î•º) ÌååÍ¥¥ÌñàÏäµÎãàÎã§!`, 'action');
          } else {
            const buildingDef = BUILDINGS[target.type];
            addLog(`${unitDef.name}Í∞Ä Ï†Å ${buildingDef.name}Ïóê ${damage} ÌîºÌï¥Î•º ÏûÖÌòîÏäµÎãàÎã§! (ÎÇ®ÏùÄ HP: ${target.hp})`, 'action');
          }
        } else if (attackState.targetType === 'base') {
          const baseKey = attackState.targetData.key;
          gameState.bases.enemy[baseKey] -= damage;
          
          if (gameState.bases.enemy[baseKey] <= 0) {
            gameState.bases.enemy[baseKey] = 0;
            
            if (baseKey === 'main') {
              addLog(`Ï†Å Î≥∏Í∏∞ÏßÄÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§! ÏäπÎ¶¨!`, 'action');
              hideAttackModal();
              setTimeout(() => handleVictory(), 500);
              return;
            } else {
              addLog(`Ï†Å Î∂ÄÍ∏∞ÏßÄÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§! (ÌîºÌï¥: ${damage})`, 'action');
            }
          } else {
            const baseName = baseKey === 'main' ? 'Î≥∏Í∏∞ÏßÄ' : 'Î∂ÄÍ∏∞ÏßÄ';
            addLog(`${unitDef.name}Í∞Ä Ï†Å ${baseName}Ïóê ${damage} ÌîºÌï¥Î•º ÏûÖÌòîÏäµÎãàÎã§! (ÎÇ®ÏùÄ HP: ${gameState.bases.enemy[baseKey].toLocaleString()})`, 'action');
          }
        }
      }
      
      unit.moved = true;
      hideAttackModal();
      
      // ÌñâÎèô ÌõÑ ÏûêÎèôÏúºÎ°ú ÌÑ¥ Ï¢ÖÎ£å
      setTimeout(() => {
        endTurn();
      }, 100);
    }
    
    // ÏäπÎ¶¨ Ï≤òÎ¶¨
    function handleVictory() {
      if (gameState.turnInterval) clearInterval(gameState.turnInterval);
      
      gameState.player.wins++;
      
      alert(`Ï∂ïÌïòÌï©ÎãàÎã§! ÏäπÎ¶¨!\n\nÎãπÏã†Ïùò Ï†ÑÏ†Å: ${gameState.player.wins}Ïäπ ${gameState.player.losses}Ìå®`);
      updateLobbyStats();
      showScreen('lobby');
    }
    
    // Î°úÍ∑∏ Ï∂îÍ∞Ä
    function addLog(text, type = 'system') {
      const logContainer = document.getElementById('log-container');
      const time = new Date().toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });
      
      const logEntry = document.createElement('div');
      logEntry.className = `log-entry ${type}`;
      logEntry.innerHTML = `<span class="time">${time}</span>${text}`;
      
      logContainer.appendChild(logEntry);
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    // ==================== ÏàòÏÜ°Ìï® ÏãúÏä§ÌÖú ====================
    
    // ÏàòÏÜ° ÏÉÅÌÉú
    let transportState = {
      selectedUnits: [],
      transportShip: null
    };
    
    // Ïù∏Ï†ë Ïú°ÏßÄ ÌôïÏù∏
    function checkAdjacentLand(x, y) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0}
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const tile = gameState.map[ny][nx];
          if (tile.terrain === 'land' && !getUnitAt(nx, ny)) {
            return true;
          }
        }
      }
      return false;
    }
    
    // Ïù∏Ï†ë Ïú°ÏßÄ ÏúÑÏπò Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
    function getAdjacentLandPositions(x, y) {
      const positions = [];
      const directions = [
        {x: 0, y: 1, name: 'ÎÇ®Ï™Ω'}, 
        {x: 1, y: 0, name: 'ÎèôÏ™Ω'}, 
        {x: 0, y: -1, name: 'Î∂ÅÏ™Ω'}, 
        {x: -1, y: 0, name: 'ÏÑúÏ™Ω'}
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const tile = gameState.map[ny][nx];
          if (tile.terrain === 'land' && !getUnitAt(nx, ny)) {
            positions.push({ x: nx, y: ny, name: dir.name });
          }
        }
      }
      return positions;
    }
    
    // ÏàòÏÜ° Î™®Îã¨ ÌëúÏãú
    function showTransportModal() {
      hideActionMenu();
      
      const tile = gameState.selectedTile;
      const transportShip = getUnitAt(tile.x, tile.y);
      
      if (!transportShip || transportShip.type !== 'transport_ship') return;
      
      transportState.transportShip = transportShip;
      transportState.selectedUnits = [];
      
      // ÏàòÏÜ° Í∞ÄÎä•Ìïú Ïú†Îãõ Î™©Î°ù Î†åÎçîÎßÅ
      const listEl = document.getElementById('transport-unit-list');
      listEl.innerHTML = '';
      
      const transportableUnits = gameState.units.filter(u => 
        u.owner === 'player' && 
        !UNITS[u.type].isNavalUnit && 
        !UNITS[u.type].isAirUnit &&
        !u.transported
      );
      
      transportableUnits.forEach(unit => {
        const unitDef = UNITS[unit.type];
        const div = document.createElement('div');
        div.className = 'unit-card';
        div.dataset.unitId = unit.id;
        div.innerHTML = `
          <span class="unit-icon">${unitDef.icon}</span>
          <div class="unit-info">
            <strong>${unitDef.name}</strong>
            <span>${unit.count}Î™Ö (${unit.x}, ${unit.y})</span>
          </div>
        `;
        div.addEventListener('click', () => toggleTransportUnit(unit, div));
        listEl.appendChild(div);
      });
      
      updateTransportButton();
      
      document.getElementById('transport-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÏàòÏÜ° Ïú†Îãõ ÏÑ†ÌÉù/Ìï¥Ï†ú
    function toggleTransportUnit(unit, element) {
      const index = transportState.selectedUnits.findIndex(u => u.id === unit.id);
      
      if (index > -1) {
        // ÏÑ†ÌÉù Ìï¥Ï†ú
        transportState.selectedUnits.splice(index, 1);
        element.classList.remove('selected');
      } else {
        // ÏÑ†ÌÉù (ÏµúÎåÄ 2Í∞ú)
        if (transportState.selectedUnits.length < 2) {
          transportState.selectedUnits.push(unit);
          element.classList.add('selected');
        }
      }
      
      updateTransportButton();
    }
    
    // ÏàòÏÜ° Î≤ÑÌäº ÏóÖÎç∞Ïù¥Ìä∏
    function updateTransportButton() {
      const btn = document.getElementById('confirm-transport-btn');
      const count = transportState.selectedUnits.length;
      btn.textContent = `ÏàòÏÜ° ÌôïÏ†ï (${count}/2)`;
      btn.disabled = count === 0;
    }
    
    // ÏàòÏÜ° Î™®Îã¨ Îã´Í∏∞
    function hideTransportModal() {
      document.getElementById('transport-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      transportState.selectedUnits = [];
      transportState.transportShip = null;
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ÏàòÏÜ° ÌôïÏ†ï
    function confirmTransport() {
      const ship = transportState.transportShip;
      if (!ship || transportState.selectedUnits.length === 0) return;
      
      // ÏàòÏÜ°Ìï®Ïóê Ïú†Îãõ ÌÉëÏäπ
      if (!ship.cargo) ship.cargo = [];
      
      transportState.selectedUnits.forEach(unit => {
        // Ïú†ÎãõÏùÑ ÏàòÏÜ°Ìï®Ïóê ÌÉëÏäπ
        ship.cargo.push({
          type: unit.type,
          count: unit.count,
          hp: unit.hp
        });
        
        // ÏõêÎûò Ïú†Îãõ Ï†úÍ±∞
        const index = gameState.units.findIndex(u => u.id === unit.id);
        if (index > -1) {
          gameState.units.splice(index, 1);
        }
        
        addLog(`‚õ¥Ô∏è ${UNITS[unit.type].name} ${unit.count}Î™ÖÏù¥ ÏàòÏÜ°Ìï®Ïóê ÌÉëÏäπ!`, 'action');
      });
      
      hideTransportModal();
      renderMap();
    }
    
    // ÏÉÅÎ•ô Î™®Îã¨ ÌëúÏãú
    function showLandModal() {
      hideActionMenu();
      
      const tile = gameState.selectedTile;
      const transportShip = getUnitAt(tile.x, tile.y);
      
      if (!transportShip || transportShip.type !== 'transport_ship') return;
      if (!transportShip.cargo || transportShip.cargo.length === 0) return;
      
      transportState.transportShip = transportShip;
      
      // ÏÉÅÎ•ô Í∞ÄÎä• ÏúÑÏπò Î†åÎçîÎßÅ
      const positionsEl = document.getElementById('land-positions');
      positionsEl.innerHTML = '';
      
      const positions = getAdjacentLandPositions(tile.x, tile.y);
      
      positions.forEach(pos => {
        const div = document.createElement('div');
        div.className = 'build-option';
        div.innerHTML = `
          <span class="option-icon">üèñÔ∏è</span>
          <div class="option-info">
            <div class="option-name">${pos.name} (${pos.x}, ${pos.y})</div>
            <div class="option-desc">Ïù¥ ÏúÑÏπòÏóê Ïú†Îãõ ÏÉÅÎ•ô</div>
          </div>
        `;
        div.addEventListener('click', () => executeLanding(pos.x, pos.y));
        positionsEl.appendChild(div);
      });
      
      document.getElementById('land-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÏÉÅÎ•ô Î™®Îã¨ Îã´Í∏∞
    function hideLandModal() {
      document.getElementById('land-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      transportState.transportShip = null;
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ÏÉÅÎ•ô Ïã§Ìñâ
    function executeLanding(targetX, targetY) {
      const ship = transportState.transportShip;
      if (!ship || !ship.cargo || ship.cargo.length === 0) return;
      
      // Ïú†Îãõ ÏÉÅÎ•ô
      ship.cargo.forEach((cargo, index) => {
        // Ï≤´ Î≤àÏß∏ Ïú†ÎãõÏùÄ ÏßÄÏ†ï ÏúÑÏπòÏóê, Îëê Î≤àÏß∏Îäî Ï£ºÎ≥ÄÏóê
        let landX = targetX;
        let landY = targetY;
        
        if (index > 0) {
          // Ï£ºÎ≥Ä Îπà ÌÉÄÏùº Ï∞æÍ∏∞
          const spawnTile = findSpawnTile(targetX, targetY);
          if (spawnTile) {
            landX = spawnTile.x;
            landY = spawnTile.y;
          }
        }
        
        // Í∏∞Ï°¥ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ìï©Î•ò
        const existingUnit = gameState.units.find(u => 
          u.x === landX && u.y === landY && 
          u.type === cargo.type && u.owner === 'player'
        );
        
        if (existingUnit) {
          existingUnit.count += cargo.count;
        } else {
          gameState.units.push({
            id: `unit_${Date.now()}_${index}`,
            type: cargo.type,
            x: landX,
            y: landY,
            owner: 'player',
            hp: cargo.hp,
            count: cargo.count,
            moved: true // ÏÉÅÎ•ô ÌÑ¥ÏóêÎäî Ïù¥Îèô Î∂àÍ∞Ä
          });
        }
        
        addLog(`üèñÔ∏è ${UNITS[cargo.type].name} ${cargo.count}Î™ÖÏù¥ (${landX}, ${landY})Ïóê ÏÉÅÎ•ô!`, 'action');
      });
      
      // ÏàòÏÜ°Ìï® ÌôîÎ¨º ÎπÑÏö∞Í∏∞
      ship.cargo = [];
      ship.moved = true;
      
      hideLandModal();
      renderMap();
    }
    
    // ==================== Ìè≠Í≤©Í∏∞ ÏãúÏä§ÌÖú ====================
    
    // Ìè≠Í≤© Ïã§Ìñâ
    function executeBomb(tile) {
      const bomber = getAirUnitAt(tile.x, tile.y);
      
      if (!bomber || bomber.type !== 'bomber' || bomber.owner !== 'player') {
        addLog('Ìè≠Í≤©Í∏∞Í∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      if (bomber.moved) {
        addLog('Ïù¥ÎØ∏ ÌñâÎèôÌïú Ìè≠Í≤©Í∏∞ÏûÖÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      // Ï†Å ÏòÅÏó≠Ïù¥Í≥† Î∞îÎã§Í∞Ä ÏïÑÎãåÏßÄ ÌôïÏù∏
      const isSea = tile.terrain === 'sea' || tile.type === 'sea';
      if (tile.y > ENEMY_ZONE_END || isSea) {
        addLog('Ï†Å Ïú°ÏßÄÏóêÏÑúÎßå Ìè≠Í≤©Ìï† Ïàò ÏûàÏäµÎãàÎã§!', 'system');
        hideActionMenu(true);
        return;
      }
      
      const damage = UNITS.bomber.bombDamage;
      
      // Ìï¥Îãπ ÏúÑÏπòÏùò Ï†Å ÏßÄÏÉÅ Ïú†ÎãõÏóê ÌîºÌï¥
      const enemyUnit = getGroundUnitAt(tile.x, tile.y);
      
      if (enemyUnit && enemyUnit.owner === 'enemy') {
        enemyUnit.count -= Math.floor(damage / 10); // Ïú†ÎãõÏóêÎäî Îç∞ÎØ∏ÏßÄ/10 ÌîºÌï¥
        if (enemyUnit.count <= 0) {
          const index = gameState.units.findIndex(u => u.id === enemyUnit.id);
          if (index > -1) gameState.units.splice(index, 1);
          addLog(`üí£ Ìè≠Í≤©! Ï†Å ${UNITS[enemyUnit.type].name} Ï†ÑÎ©∏!`, 'action');
        } else {
          addLog(`üí£ Ìè≠Í≤©! Ï†Å ${UNITS[enemyUnit.type].name}Ïóê ÌîºÌï¥!`, 'action');
        }
      }
      
      // Ìï¥Îãπ ÏúÑÏπòÏùò Í±¥Î¨º/Í∏∞ÏßÄÏóê ÌîºÌï¥
      const building = getBuildingAt(tile.x, tile.y);
      if (building && building.owner === 'enemy') {
        building.hp -= damage;
        if (building.hp <= 0) {
          const index = gameState.buildings.findIndex(b => b.x === tile.x && b.y === tile.y);
          if (index > -1) gameState.buildings.splice(index, 1);
          addLog(`üí£ Ìè≠Í≤©! Ï†Å ${BUILDINGS[building.type].name} ÌååÍ¥¥!`, 'action');
        } else {
          addLog(`üí£ Ìè≠Í≤©! Ï†Å ${BUILDINGS[building.type].name}Ïóê ${damage} ÌîºÌï¥!`, 'action');
        }
      }
      
      // Í∏∞ÏßÄÏóê ÌîºÌï¥
      if (tile.type === 'main_base' && tile.owner === 'enemy') {
        gameState.bases.enemy.main -= damage;
        addLog(`üí£ Ìè≠Í≤©! Ï†Å Î≥∏Í∏∞ÏßÄÏóê ${damage} ÌîºÌï¥! (HP: ${Math.max(0, gameState.bases.enemy.main)})`, 'action');
        
        if (gameState.bases.enemy.main <= 0) {
          gameState.bases.enemy.main = 0;
          setTimeout(() => {
            alert('ÏäπÎ¶¨! Ï†Å Î≥∏Í∏∞ÏßÄÎ•º ÌååÍ¥¥ÌñàÏäµÎãàÎã§!');
            showScreen('lobby');
          }, 500);
        }
      } else if (tile.type === 'sub_base' && tile.owner === 'enemy') {
        const island = getIslandAt(tile.x, tile.y);
        const subKey = (island === 'enemy_right') ? 'sub2' : 'sub1';
        gameState.bases.enemy[subKey] -= damage;
        addLog(`üí£ Ìè≠Í≤©! Ï†Å Î∂ÄÍ∏∞ÏßÄÏóê ${damage} ÌîºÌï¥!`, 'action');
        
        if (gameState.bases.enemy[subKey] <= 0) {
          gameState.bases.enemy[subKey] = 0;
          tile.type = 'empty';
          addLog(`üí• Ï†Å Î∂ÄÍ∏∞ÏßÄ ÌååÍ¥¥!`, 'action');
        }
      }
      
      // Ìè≠Í≤©Í∏∞ ÌñâÎèô ÏôÑÎ£å
      bomber.moved = true;
      
      hideActionMenu(true);
      renderMap();
    }
    
    // ==================== ÎØ∏ÏÇ¨Ïùº ÏãúÏä§ÌÖú ====================
    
    // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î™®Îã¨ ÌëúÏãú
    function showMissileProduceModal() {
      hideActionMenu();
      
      // Íµ∞ÏàòÍ≥µÏû• Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÉùÏÇ∞ ÌÑ¥ ÌôïÏù∏
      const tile = gameState.selectedTile;
      const factory = tile ? getBuildingAt(tile.x, tile.y) : null;
      const buildTurns = factory ? getFactoryBuildTurns(factory) : MISSILE_BUILD_TURNS;
      const level = factory ? (factory.level || 1) : 1;
      
      // Î™®Îã¨ ÎÇ¥Ïö© ÏóÖÎç∞Ïù¥Ìä∏
      const optionDesc = document.querySelector('#produce-missile-option .option-desc');
      if (optionDesc) {
        optionDesc.textContent = `${buildTurns}ÌÑ¥ ÌõÑ ÏôÑÏÑ± (Lv.${level} Í≥µÏû•)`;
      }
      
      // ÌòÑÏû¨ Ïû¨Í≥† Î∞è ÏÉùÏÇ∞ ÌÅê ÏóÖÎç∞Ïù¥Ìä∏
      document.getElementById('missile-stock-display').textContent = gameState.missiles.player;
      
      const queue = gameState.missileQueue.player;
      if (queue.length > 0) {
        const queueText = queue.map((m, i) => `ÎØ∏ÏÇ¨Ïùº ${i+1}: ${m.turnsLeft}ÌÑ¥ ÎÇ®Ïùå`).join(', ');
        document.getElementById('missile-queue-display').textContent = queueText;
      } else {
        document.getElementById('missile-queue-display').textContent = 'ÏóÜÏùå';
      }
      
      // ÏûêÏõê Ï≤¥ÌÅ¨
      const option = document.getElementById('produce-missile-option');
      if (gameState.resources.player < MISSILE_COST) {
        option.classList.add('disabled');
      } else {
        option.classList.remove('disabled');
      }
      
      document.getElementById('missile-produce-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î™®Îã¨ Îã´Í∏∞
    function hideMissileProduceModal() {
      document.getElementById('missile-produce-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÌôïÏ†ï
    function confirmMissileProduce() {
      if (gameState.resources.player < MISSILE_COST) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // Íµ∞Ïàò Í≥µÏû• Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÉùÏÇ∞ ÌÑ¥ Ïàò
      const tile = gameState.selectedTile;
      const factory = tile ? getBuildingAt(tile.x, tile.y) : null;
      const buildTurns = factory ? getFactoryBuildTurns(factory) : MISSILE_BUILD_TURNS;
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= MISSILE_COST;
      
      // ÏÉùÏÇ∞ ÌÅêÏóê Ï∂îÍ∞Ä
      gameState.missileQueue.player.push({ turnsLeft: buildTurns });
      
      // Íµ∞Ïàò Í≥µÏû• produced Ï≤òÎ¶¨
      if (factory) factory.produced = true;
      
      addLog(`üè≠ ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÏãúÏûë! ${buildTurns}ÌÑ¥ ÌõÑ ÏôÑÏÑ± (üí∞ -${MISSILE_COST.toLocaleString()})`, 'action');
      
      updateMissileQueueDisplay();
      hideMissileProduceModal();
      updateResourceDisplay();
    }
    
    // ==================== ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ ÏãúÏä§ÌÖú ====================
    
    let selectedTankType = null;
    
    // ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ Î™®Îã¨ ÌëúÏãú
    function showTankProduceModal() {
      hideActionMenu();
      selectedTankType = null;
      
      // ÏàòÎüâ ÏÑπÏÖò Ï¥àÍ∏∞Ìôî
      document.getElementById('tank-quantity-section').style.display = 'none';
      document.getElementById('tank-quantity').value = 1;
      document.getElementById('tank-player-resources').textContent = gameState.resources.player.toLocaleString();
      
      // ÏòµÏÖò ÏÑ†ÌÉù Ìï¥Ï†ú
      document.querySelectorAll('.tank-option').forEach(opt => opt.classList.remove('selected'));
      
      document.getElementById('tank-produce-modal').classList.add('active');
    }
    
    // ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ Î™®Îã¨ Îã´Í∏∞
    function hideTankProduceModal() {
      document.getElementById('tank-produce-modal').classList.remove('active');
      selectedTankType = null;
    }
    
    // ÌÉ±ÌÅ¨ ÌÉÄÏûÖ ÏÑ†ÌÉù
    function selectTankType(tankType) {
      selectedTankType = tankType;
      const tankDef = UNITS[tankType];
      
      // ÏÑ†ÌÉù ÌëúÏãú
      document.querySelectorAll('.tank-option').forEach(opt => {
        opt.classList.toggle('selected', opt.dataset.tankType === tankType);
      });
      
      // ÏàòÎüâ ÏÑπÏÖò ÌëúÏãú
      document.getElementById('tank-quantity-section').style.display = 'block';
      document.getElementById('selected-tank-name').textContent = tankDef.name;
      document.getElementById('selected-tank-price').textContent = tankDef.cost.toLocaleString();
      document.getElementById('tank-quantity').value = 1;
      
      updateTankTotalCost();
    }
    
    // ÌÉ±ÌÅ¨ Ï¥ù ÎπÑÏö© ÏóÖÎç∞Ïù¥Ìä∏
    function updateTankTotalCost() {
      if (!selectedTankType) return;
      
      const tankDef = UNITS[selectedTankType];
      const quantity = parseInt(document.getElementById('tank-quantity').value) || 1;
      const totalCost = tankDef.cost * quantity;
      
      document.getElementById('tank-total-cost').textContent = totalCost.toLocaleString();
      document.getElementById('tank-player-resources').textContent = gameState.resources.player.toLocaleString();
      
      // ÏûêÏõê Î∂ÄÏ°± Ïãú Ïä§ÌÉÄÏùº Î≥ÄÍ≤Ω
      const confirmBtn = document.getElementById('confirm-tank-produce');
      if (gameState.resources.player < totalCost) {
        confirmBtn.style.background = '#555';
        confirmBtn.style.cursor = 'not-allowed';
      } else {
        confirmBtn.style.background = '#4a9';
        confirmBtn.style.cursor = 'pointer';
      }
    }
    
    // ÌÉ±ÌÅ¨ ÏàòÎüâ Ï°∞Ï†à
    function adjustTankQuantity(delta) {
      const input = document.getElementById('tank-quantity');
      let value = parseInt(input.value) || 1;
      value = Math.max(1, value + delta);
      input.value = value;
      updateTankTotalCost();
    }
    
    // ÌÉ±ÌÅ¨ ÏµúÎåÄ Íµ¨Îß§
    function setMaxTankQuantity() {
      if (!selectedTankType) return;
      
      const tankDef = UNITS[selectedTankType];
      const maxQty = Math.floor(gameState.resources.player / tankDef.cost);
      document.getElementById('tank-quantity').value = Math.max(1, maxQty);
      updateTankTotalCost();
    }
    
    // ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ ÌôïÏ†ï
    function confirmTankProduce() {
      if (!selectedTankType) {
        addLog('ÌÉ±ÌÅ¨ Ï¢ÖÎ•òÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî!', 'system');
        return;
      }
      
      const tankDef = UNITS[selectedTankType];
      const quantity = parseInt(document.getElementById('tank-quantity').value) || 1;
      const totalCost = tankDef.cost * quantity;
      
      if (gameState.resources.player < totalCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // Íµ∞Ïàò Í≥µÏû• ÏúÑÏπòÏóêÏÑú Ïä§Ìè∞ ÏúÑÏπò Ï∞æÍ∏∞
      const tile = gameState.selectedTile;
      const factory = getBuildingAt(tile.x, tile.y);
      
      // Ïä§Ìè∞ Í∞ÄÎä•Ìïú Ïù∏Ï†ë ÌÉÄÏùº Ï∞æÍ∏∞
      const spawnTile = findSpawnTile(tile.x, tile.y);
      if (!spawnTile) {
        addLog('ÏÉùÏÇ∞Ìï† Í≥µÍ∞ÑÏù¥ ÏóÜÏäµÎãàÎã§! Ï£ºÎ≥ÄÏóê Îπà ÌÉÄÏùºÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.', 'system');
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= totalCost;
      
      // ÌÉ±ÌÅ¨ Ïú†Îãõ ÏÉùÏÑ±
      gameState.units.push({
        id: Date.now() + Math.random(),
        type: selectedTankType,
        x: spawnTile.x,
        y: spawnTile.y,
        owner: 'player',
        count: quantity,
        moved: true  // ÏÉùÏÇ∞Îêú ÌÑ¥ÏóêÎäî ÌñâÎèô Î∂àÍ∞Ä
      });
      
      // Íµ∞Ïàò Í≥µÏû• ÏÇ¨Ïö© Ï≤òÎ¶¨
      if (factory) factory.produced = true;
      
      addLog(`üöú ${tankDef.name} ${quantity}ÎåÄ ÏÉùÏÇ∞ ÏôÑÎ£å! (üí∞ -${totalCost.toLocaleString()})`, 'action');
      
      hideTankProduceModal();
      renderMap();
      updateResourceDisplay();
    }
    
    // Ïä§Ìè∞ Í∞ÄÎä•Ìïú ÌÉÄÏùº Ï∞æÍ∏∞ (ÌîåÎ†àÏù¥Ïñ¥Ïö©)
    function findSpawnTile(centerX, centerY) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
      ];
      
      for (const dir of directions) {
        const nx = centerX + dir.x;
        const ny = centerY + dir.y;
        
        if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
        
        const tile = gameState.map[ny][nx];
        if (tile.terrain !== 'land') continue;
        if (getGroundUnitAt(nx, ny)) continue;
        
        return { x: nx, y: ny };
      }
      return null;
    }
    
    // ==================== ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ ÏãúÏä§ÌÖú ÎÅù ====================
    
    // ==================== ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ ÏãúÏä§ÌÖú ====================
    
    let minePlaceState = { targetX: 0, targetY: 0 };
    
    // ÏßÄÎ¢∞ ÏÑ§Ïπò Î™®Îã¨ ÌëúÏãú
    function showMinePlaceModal(tile) {
      hideActionMenu();
      
      minePlaceState.targetX = tile.x;
      minePlaceState.targetY = tile.y;
      
      document.getElementById('mine-target-x').textContent = tile.x;
      document.getElementById('mine-target-y').textContent = tile.y;
      document.getElementById('mine-player-resources').textContent = gameState.resources.player.toLocaleString();
      document.getElementById('mine-quantity').value = 1;
      updateMineTotalCost();
      
      document.getElementById('mine-place-modal').classList.add('active');
    }
    
    // ÏßÄÎ¢∞ ÏÑ§Ïπò Î™®Îã¨ Îã´Í∏∞
    function hideMinePlaceModal() {
      document.getElementById('mine-place-modal').classList.remove('active');
    }
    
    // ÏßÄÎ¢∞ Ï¥ù ÎπÑÏö© ÏóÖÎç∞Ïù¥Ìä∏
    function updateMineTotalCost() {
      const quantity = parseInt(document.getElementById('mine-quantity').value) || 1;
      const totalCost = MINE_COST * quantity;
      
      document.getElementById('mine-total-cost').textContent = totalCost.toLocaleString();
      
      const confirmBtn = document.getElementById('confirm-mine-place');
      if (gameState.resources.player < totalCost) {
        confirmBtn.style.background = '#555';
        confirmBtn.style.cursor = 'not-allowed';
      } else {
        confirmBtn.style.background = '#c55';
        confirmBtn.style.cursor = 'pointer';
      }
    }
    
    // ÏßÄÎ¢∞ ÏàòÎüâ Ï°∞Ï†à
    function adjustMineQuantity(delta) {
      const input = document.getElementById('mine-quantity');
      let value = parseInt(input.value) || 1;
      value = Math.max(1, value + delta);
      input.value = value;
      updateMineTotalCost();
    }
    
    // ÏßÄÎ¢∞ ÏµúÎåÄ Íµ¨Îß§
    function setMaxMineQuantity() {
      const maxQty = Math.floor(gameState.resources.player / MINE_COST);
      document.getElementById('mine-quantity').value = Math.max(1, maxQty);
      updateMineTotalCost();
    }
    
    // ÏßÄÎ¢∞ ÏÑ§Ïπò ÌôïÏ†ï
    function confirmMinePlacement() {
      const quantity = parseInt(document.getElementById('mine-quantity').value) || 1;
      const totalCost = MINE_COST * quantity;
      
      if (gameState.resources.player < totalCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // Ïù∏Ï†ë ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë ÌôïÏù∏
      const antiTank = hasAdjacentAntiTank(minePlaceState.targetX, minePlaceState.targetY);
      if (!antiTank) {
        addLog('Ïù∏Ï†ëÌïú ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ëÏù¥ ÏóÜÏäµÎãàÎã§!', 'system');
        return;
      }
      
      // ÏûêÏõê Ï∞®Í∞ê
      gameState.resources.player -= totalCost;
      
      // ÏßÄÎ¢∞ ÏÑ§Ïπò
      const existingMine = getMineAt(minePlaceState.targetX, minePlaceState.targetY);
      if (existingMine) {
        existingMine.count += quantity;
      } else {
        gameState.landmines.push({
          x: minePlaceState.targetX,
          y: minePlaceState.targetY,
          owner: 'player',
          count: quantity
        });
      }
      
      // ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë ÌñâÎèô ÏôÑÎ£å Ï≤òÎ¶¨
      antiTank.moved = true;
      
      addLog(`üí£ ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ ${quantity}Í∞ú ÏÑ§Ïπò ÏôÑÎ£å! (${minePlaceState.targetX}, ${minePlaceState.targetY})`, 'action');
      
      hideMinePlaceModal();
      renderMap();
      updateResourceDisplay();
    }
    
    // ÌÉ±ÌÅ¨/Ï∞®Îüâ Ïù¥Îèô Ïãú ÏßÄÎ¢∞ Ï≤¥ÌÅ¨
    function checkMineOnPath(unit, fromX, fromY, toX, toY) {
      const unitDef = UNITS[unit.type];
      
      // ÌÉ±ÌÅ¨ÎÇò Ï∞®ÎüâÎßå ÏßÄÎ¢∞Ïóê ÌîºÌï¥Î•º Î∞õÏùå
      if (!unitDef.isTank && !unitDef.isVehicle) return;
      
      // Î™©Ìëú ÏßÄÏ†ê ÏßÄÎ¢∞ ÌôïÏù∏
      const mine = getMineAt(toX, toY);
      
      // Ï†ÅÏùò ÏßÄÎ¢∞Îßå Î∞úÎèô (ÌîåÎ†àÏù¥Ïñ¥ Ïú†ÎãõÏù¥Î©¥ Ï†Å ÏßÄÎ¢∞, Ï†Å Ïú†ÎãõÏù¥Î©¥ ÌîåÎ†àÏù¥Ïñ¥ ÏßÄÎ¢∞)
      if (!mine || mine.owner === unit.owner) return;
      
      // ÏßÄÎ¢∞ Ìè≠Î∞ú!
      const destroyedTanks = Math.min(unit.count, mine.count * MINE_DAMAGE);
      
      addLog(`üí• ÏßÄÎ¢∞ Ìè≠Î∞ú! ${UNITS[unit.type].name} ${destroyedTanks}ÎåÄ ÌååÍ¥¥!`, unit.owner === 'player' ? 'enemy' : 'action');
      
      unit.count -= destroyedTanks;
      
      // ÏÇ¨Ïö©Îêú ÏßÄÎ¢∞ Ï†úÍ±∞ (ÌÉ±ÌÅ¨ Ïàò / MINE_DAMAGE ÎßåÌÅº ÏÜåÎ™®)
      const usedMines = Math.ceil(destroyedTanks / MINE_DAMAGE);
      mine.count -= usedMines;
      
      if (mine.count <= 0) {
        const mineIdx = gameState.landmines.findIndex(m => m.x === toX && m.y === toY);
        if (mineIdx > -1) gameState.landmines.splice(mineIdx, 1);
      }
      
      // Ïú†Îãõ Ï†ÑÎ©∏ Ï≤¥ÌÅ¨
      if (unit.count <= 0) {
        const unitIdx = gameState.units.findIndex(u => u.id === unit.id);
        if (unitIdx > -1) gameState.units.splice(unitIdx, 1);
        addLog(`${UNITS[unit.type].name} Ï†ÑÎ©∏!`, unit.owner === 'player' ? 'enemy' : 'action');
        return true; // Ï†ÑÎ©∏
      }
      
      return false; // ÏÉùÏ°¥
    }
    
    // ==================== ÎåÄÏ†ÑÏ∞® ÏßÄÎ¢∞ ÏãúÏä§ÌÖú ÎÅù ====================
    
    // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Î™®Îã¨ ÌëúÏãú
    function showMissileLaunchModal() {
      hideActionMenu();
      
      const tile = gameState.selectedTile;
      const silo = getBuildingAt(tile.x, tile.y);
      
      if (!silo || silo.type !== 'missile_silo') return;
      
      // Ïû¨Í≥† ÌëúÏãú
      document.getElementById('launch-missile-stock').textContent = gameState.missiles.player;
      
      // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÌÉÄÍ≤ü Î™©Î°ù ÏÉùÏÑ±
      const targetList = document.getElementById('missile-target-list');
      targetList.innerHTML = '';
      
      const range = getBuildingRange(silo); // Î†àÎ≤®Ïóê Îî∞Î•∏ ÏÇ¨Í±∞Î¶¨
      const targets = [];
      
      // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ Ï†Å Ïú†Îãõ, Í±¥Î¨º, Í∏∞ÏßÄ Ï∞æÍ∏∞
      for (let y = 0; y < MAP_HEIGHT; y++) {
        for (let x = 0; x < MAP_WIDTH; x++) {
          const distance = Math.abs(x - tile.x) + Math.abs(y - tile.y);
          if (distance > range || distance === 0) continue;
          
          const mapTile = gameState.map[y][x];
          const unit = getGroundUnitAt(x, y);
          const building = getBuildingAt(x, y);
          
          // Ï†Å ÏßÄÏÉÅ Ïú†Îãõ
          if (unit && unit.owner === 'enemy') {
            targets.push({
              type: 'unit',
              x, y, distance,
              name: `Ï†Å ${UNITS[unit.type].name} (${unit.count}Î™Ö)`,
              icon: UNITS[unit.type].icon,
              data: unit
            });
          }
          
          // Ï†Å Í±¥Î¨º
          if (building && building.owner === 'enemy') {
            targets.push({
              type: 'building',
              x, y, distance,
              name: `Ï†Å ${BUILDINGS[building.type].name}`,
              icon: BUILDINGS[building.type].icon,
              data: building
            });
          }
          
          // Ï†Å Í∏∞ÏßÄ
          if ((mapTile.type === 'main_base' || mapTile.type === 'sub_base') && mapTile.owner === 'enemy') {
            const baseName = mapTile.type === 'main_base' ? 'Î≥∏Í∏∞ÏßÄ' : 'Î∂ÄÍ∏∞ÏßÄ';
            targets.push({
              type: 'base',
              x, y, distance,
              name: `Ï†Å ${baseName}`,
              icon: mapTile.type === 'main_base' ? 'üè∞' : 'üèØ',
              data: mapTile
            });
          }
        }
      }
      
      // Í±∞Î¶¨Ïàú Ï†ïÎ†¨
      targets.sort((a, b) => a.distance - b.distance);
      
      if (targets.length === 0) {
        targetList.innerHTML = '<div style="color:#aaa;text-align:center;padding:20px;">ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÌÉÄÍ≤ü ÏóÜÏùå</div>';
      } else {
        targets.forEach(target => {
          const div = document.createElement('div');
          div.className = 'build-option';
          div.innerHTML = `
            <span class="option-icon">${target.icon}</span>
            <div class="option-info">
              <div class="option-name">${target.name}</div>
              <div class="option-desc">ÏúÑÏπò: (${target.x}, ${target.y}) | Í±∞Î¶¨: ${target.distance}Ïπ∏</div>
            </div>
          `;
          div.addEventListener('click', () => launchMissile(target));
          targetList.appendChild(div);
        });
      }
      
      document.getElementById('missile-launch-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Î™®Îã¨ Îã´Í∏∞
    function hideMissileLaunchModal() {
      document.getElementById('missile-launch-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
      gameState.selectedTile = null;
      renderMap();
    }
    
    // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨
    function launchMissile(target) {
      const launchCost = BUILDINGS.missile_silo.launchCost;
      const damage = BUILDINGS.missile_silo.damage;
      
      // Ï≤¥ÌÅ¨
      if (gameState.missiles.player <= 0) {
        addLog('ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥†Í∞Ä ÏóÜÏäµÎãàÎã§!', 'system');
        return;
      }
      
      if (gameState.resources.player < launchCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // ÏûêÏõê Î∞è Ïû¨Í≥† Ï∞®Í∞ê
      gameState.resources.player -= launchCost;
      gameState.missiles.player--;
      
      // Î∞úÏÇ¨ÎåÄ ÏÇ¨Ïö© Ï≤òÎ¶¨
      const tile = gameState.selectedTile;
      const silo = getBuildingAt(tile.x, tile.y);
      if (silo) silo.fired = true;
      
      // ÌÉÄÍ≤üÏóê ÌîºÌï¥
      if (target.type === 'unit') {
        const unit = target.data;
        const unitDef = UNITS[unit.type];
        
        // ÌÉ±ÌÅ¨/Ï∞®ÎüâÏùÄ ÎåÄÏàò Í∏∞Î∞ò, ÏùºÎ∞ò Ïú†ÎãõÏùÄ Î™ÖÏàò Í∏∞Î∞ò
        if (unitDef.isTank || unitDef.isVehicle) {
          const tankHp = unitDef.tankHp || 1000;
          const destroyedCount = Math.floor(damage / tankHp);
          unit.count -= destroyedCount;
          
          if (unit.count <= 0) {
            const idx = gameState.units.findIndex(u => u.id === unit.id);
            if (idx > -1) gameState.units.splice(idx, 1);
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${unitDef.name} Ï†ÑÎ©∏! (${destroyedCount}ÎåÄ ÌååÍ¥¥)`, 'action');
          } else {
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${unitDef.name} ${destroyedCount}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${unit.count}ÎåÄ)`, 'action');
          }
        } else {
          unit.count -= Math.floor(damage / 10);
          if (unit.count <= 0) {
            const idx = gameState.units.findIndex(u => u.id === unit.id);
            if (idx > -1) gameState.units.splice(idx, 1);
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${unitDef.name} Ï†ÑÎ©∏!`, 'action');
          } else {
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${unitDef.name}Ïóê ${Math.floor(damage/10)}Î™Ö ÌîºÌï¥!`, 'action');
          }
        }
      } else if (target.type === 'building') {
        const building = target.data;
        building.hp -= damage;
        if (building.hp <= 0) {
          const idx = gameState.buildings.findIndex(b => b.x === target.x && b.y === target.y);
          if (idx > -1) gameState.buildings.splice(idx, 1);
          addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${BUILDINGS[building.type].name} ÌååÍ¥¥!`, 'action');
        } else {
          addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${BUILDINGS[building.type].name}Ïóê ${damage.toLocaleString()} ÌîºÌï¥!`, 'action');
        }
      } else if (target.type === 'base') {
        const mapTile = target.data;
        if (mapTile.type === 'main_base') {
          gameState.bases.enemy.main -= damage;
          const baseName = 'Î≥∏Í∏∞ÏßÄ';
          if (gameState.bases.enemy.main <= 0) {
            gameState.bases.enemy.main = 0;
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${baseName} ÌååÍ¥¥! ÏäπÎ¶¨!`, 'action');
            hideMissileLaunchModal();
            setTimeout(() => handleVictory(), 500);
            return;
          } else {
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å ${baseName}Ïóê ${damage.toLocaleString()} ÌîºÌï¥! (HP: ${gameState.bases.enemy.main.toLocaleString()})`, 'action');
          }
        } else {
          const island = getIslandAt(target.x, target.y);
          const subKey = (island === 'enemy_right') ? 'sub2' : 'sub1';
          gameState.bases.enemy[subKey] -= damage;
          if (gameState.bases.enemy[subKey] <= 0) {
            gameState.bases.enemy[subKey] = 0;
            mapTile.type = 'empty';
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å Î∂ÄÍ∏∞ÏßÄ ÌååÍ¥¥!`, 'action');
          } else {
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨! Ï†Å Î∂ÄÍ∏∞ÏßÄÏóê ${damage.toLocaleString()} ÌîºÌï¥!`, 'action');
          }
        }
      }
      
      updateMissileQueueDisplay();
      hideMissileLaunchModal();
      updateResourceDisplay();
      renderMap();
    }
    
    // ÎØ∏ÏÇ¨Ïùº ÌÅê ÎîîÏä§ÌîåÎ†àÏù¥ ÏóÖÎç∞Ïù¥Ìä∏
    function updateMissileQueueDisplay() {
      const panel = document.getElementById('missile-queue-panel');
      const container = document.getElementById('missile-queue-container');
      const countEl = document.getElementById('completed-missile-count');
      
      const queue = gameState.missileQueue.player;
      const stock = gameState.missiles.player;
      
      // ÏÉùÏÇ∞ ÌÅêÎÇò Ïû¨Í≥†Í∞Ä ÏûàÏúºÎ©¥ Ìå®ÎÑê ÌëúÏãú
      if (queue.length > 0 || stock > 0) {
        panel.style.display = 'block';
      } else {
        panel.style.display = 'none';
        return;
      }
      
      // ÌÅê ÎÇ¥Ïö©
      if (queue.length > 0) {
        container.innerHTML = queue.map((m, i) => `
          <div style="display:flex;justify-content:space-between;padding:5px;background:#2a2a3a;border-radius:4px;margin-bottom:3px;">
            <span>üöÄ ÎØ∏ÏÇ¨Ïùº #${i+1}</span>
            <span style="color:#f90;">${m.turnsLeft}ÌÑ¥ ÎÇ®Ïùå</span>
          </div>
        `).join('');
      } else {
        container.innerHTML = '<div style="color:#aaa;text-align:center;padding:5px;">ÏÉùÏÇ∞ Ï§ëÏù∏ ÎØ∏ÏÇ¨Ïùº ÏóÜÏùå</div>';
      }
      
      // ÏôÑÏÑ± Ïû¨Í≥†
      countEl.textContent = stock;
    }
    
    // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÏßÑÌñâ (ÌÑ¥ Ï¢ÖÎ£å Ïãú Ìò∏Ï∂ú)
    function processMissileProduction(owner) {
      const queue = gameState.missileQueue[owner];
      
      for (let i = queue.length - 1; i >= 0; i--) {
        queue[i].turnsLeft--;
        
        if (queue[i].turnsLeft <= 0) {
          // ÏôÑÏÑ±!
          gameState.missiles[owner]++;
          queue.splice(i, 1);
          
          if (owner === 'player') {
            addLog(`üöÄ ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÏôÑÎ£å! Ïû¨Í≥†: ${gameState.missiles.player}Í∞ú`, 'action');
          }
        }
      }
      
      if (owner === 'player') {
        updateMissileQueueDisplay();
      }
    }
    
    // ==================== ÌÉÄÏùº Ï†ïÎ≥¥ Ìå®ÎÑê ====================
    
    // ÌÉÄÏùº Ï†ïÎ≥¥ Ìå®ÎÑê ÏóÖÎç∞Ïù¥Ìä∏
    function updateTileInfoPanel(tile) {
      const content = document.getElementById('tile-info-content');
      
      if (!tile) {
        content.innerHTML = '<div class="no-selection">ÌÉÄÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</div>';
        return;
      }
      
      const building = getBuildingAt(tile.x, tile.y);
      const unit = getGroundUnitAt(tile.x, tile.y);
      const airUnit = getAirUnitAt(tile.x, tile.y);
      
      let html = '';
      
      // ÌÉÄÏùº Í∏∞Î≥∏ Ï†ïÎ≥¥
      let tileIcon = 'üü©';
      let tileName = 'Îπà ÌÉÄÏùº';
      
      if (tile.terrain === 'sea' || tile.type === 'sea') {
        tileIcon = 'üåä';
        tileName = 'Î∞îÎã§';
      } else if (tile.type === 'main_base') {
        tileIcon = 'üè∞';
        tileName = tile.owner === 'player' ? 'ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄ' : 'Ï†Å Î≥∏Í∏∞ÏßÄ';
      } else if (tile.type === 'sub_base') {
        tileIcon = 'üèØ';
        tileName = tile.owner === 'player' ? 'ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄ' : 'Ï†Å Î∂ÄÍ∏∞ÏßÄ';
      } else if (tile.type === 'harbor') {
        tileIcon = '‚öì';
        tileName = tile.owner === 'player' ? 'ÏïÑÍµ∞ Ìï≠Íµ¨' : 'Ï†Å Ìï≠Íµ¨';
      } else if (tile.terrain === 'river') {
        tileIcon = 'üèûÔ∏è';
        tileName = 'Í∞ï';
      }
      
      // Í±¥Î¨ºÏù¥ ÏûàÏúºÎ©¥ Í±¥Î¨º Ï†ïÎ≥¥Î°ú ÎçÆÏñ¥Ïì∞Í∏∞
      if (building) {
        const buildingDef = BUILDINGS[building.type];
        tileIcon = buildingDef.icon;
        tileName = buildingDef.name;
        if (building.owner === 'enemy') tileName = 'Ï†Å ' + tileName;
      }
      
      html += `<div class="tile-icon">${tileIcon}</div>`;
      
      // Ï†ïÎ≥¥ ÌñâÎì§
      html += `<div class="info-row">
        <span class="info-label">Ïù¥Î¶Ñ</span>
        <span class="info-value">${tileName}</span>
      </div>`;
      
      html += `<div class="info-row">
        <span class="info-label">Ï¢åÌëú</span>
        <span class="info-value">(${tile.x}, ${tile.y})</span>
      </div>`;
      
      // Í∏∞ÏßÄ ÎÇ¥Íµ¨ÎèÑ
      if (tile.type === 'main_base' || tile.type === 'sub_base') {
        let hp, maxHp;
        if (tile.type === 'main_base') {
          hp = tile.owner === 'player' ? gameState.bases.player.main : gameState.bases.enemy.main;
          maxHp = BASE_HP.main_base;
        } else {
          const island = getIslandAt(tile.x, tile.y);
          const subKey = (island === 'player_left' || island === 'enemy_right') ? 'sub2' : 'sub1';
          hp = tile.owner === 'player' ? gameState.bases.player[subKey] : gameState.bases.enemy[subKey];
          maxHp = BASE_HP.sub_base;
        }
        const hpPercent = Math.floor((hp / maxHp) * 100);
        const hpColor = hpPercent > 50 ? 'green' : hpPercent > 20 ? 'gold' : 'red';
        html += `<div class="info-row">
          <span class="info-label">ÎÇ¥Íµ¨ÎèÑ</span>
          <span class="info-value ${hpColor}">${hp.toLocaleString()} / ${maxHp.toLocaleString()} (${hpPercent}%)</span>
        </div>`;
      }
      
      // Ìï≠Íµ¨ ÎÇ¥Íµ¨ÎèÑ
      if (tile.type === 'harbor' && tile.harborHp !== undefined) {
        const hpPercent = Math.floor((tile.harborHp / 10000) * 100);
        const hpColor = hpPercent > 50 ? 'green' : hpPercent > 20 ? 'gold' : 'red';
        html += `<div class="info-row">
          <span class="info-label">ÎÇ¥Íµ¨ÎèÑ</span>
          <span class="info-value ${hpColor}">${tile.harborHp.toLocaleString()} / 10,000 (${hpPercent}%)</span>
        </div>`;
      }
      
      // Í±¥Î¨º Ï†ïÎ≥¥
      if (building) {
        const buildingDef = BUILDINGS[building.type];
        const hpPercent = Math.floor((building.hp / buildingDef.hp) * 100);
        const hpColor = hpPercent > 50 ? 'green' : hpPercent > 20 ? 'gold' : 'red';
        
        html += `<div class="info-row">
          <span class="info-label">Í±¥Î¨º HP</span>
          <span class="info-value ${hpColor}">${building.hp.toLocaleString()} / ${buildingDef.hp.toLocaleString()} (${hpPercent}%)</span>
        </div>`;
        
        // Î†àÎ≤®
        if (buildingDef.upgradable) {
          const level = building.level || 1;
          html += `<div class="info-row">
            <span class="info-label">Î†àÎ≤®</span>
            <span class="info-value gold">‚≠ê Lv.${level} / ${buildingDef.maxLevel}</span>
          </div>`;
          
          // ÌòÑÏû¨ Îä•Î†•Ïπò
          html += `<div class="info-row">
            <span class="info-label">Îä•Î†•</span>
            <span class="info-value">${getUpgradeStatText(buildingDef, level)}</span>
          </div>`;
        }
        
        // ÏàòÏûÖ
        if (buildingDef.upgradeType === 'income') {
          const income = getBuildingIncome(building);
          html += `<div class="info-row">
            <span class="info-label">ÏàòÏûÖ</span>
            <span class="info-value green">+${income.toLocaleString()}/ÌÑ¥</span>
          </div>`;
        }
      }
      
      // ÏßÄÏÉÅ Ïú†Îãõ Ï†ïÎ≥¥
      if (unit) {
        const unitDef = UNITS[unit.type];
        const isTank = unitDef.isTank;
        const unitCountText = isTank ? `${unit.count.toLocaleString()}ÎåÄ` : `${unit.count.toLocaleString()}Î™Ö`;
        
        html += `<div class="info-row" style="margin-top:8px;border-top:1px solid #3a4a23;padding-top:8px;">
          <span class="info-label">${isTank ? 'üöú ÌÉ±ÌÅ¨' : 'üéñÔ∏è Ïú†Îãõ'}</span>
          <span class="info-value">${unitDef.icon} ${unitDef.name}</span>
        </div>`;
        html += `<div class="info-row">
          <span class="info-label">${isTank ? 'Î≥¥Ïú†' : 'Î≥ëÎ†•'}</span>
          <span class="info-value">${unitCountText}</span>
        </div>`;
        
        // ÌÉ±ÌÅ¨ Ï∂îÍ∞Ä Ï†ïÎ≥¥
        if (isTank) {
          html += `<div class="info-row">
            <span class="info-label">HP/ÎåÄ</span>
            <span class="info-value">${unitDef.tankHp.toLocaleString()}</span>
          </div>`;
          html += `<div class="info-row">
            <span class="info-label">Îç∞ÎØ∏ÏßÄ</span>
            <span class="info-value red">${unitDef.tankDamage.toLocaleString()}/ÎåÄ</span>
          </div>`;
          html += `<div class="info-row">
            <span class="info-label">Ï¥ù ÌîºÌï¥</span>
            <span class="info-value red">${(unitDef.tankDamage * unit.count).toLocaleString()}</span>
          </div>`;
          html += `<div class="info-row">
            <span class="info-label">ÏÇ¨Í±∞Î¶¨</span>
            <span class="info-value">${unitDef.attackRange}Ïπ∏</span>
          </div>`;
        }
        
        html += `<div class="info-row">
          <span class="info-label">ÏÜåÏú†</span>
          <span class="info-value ${unit.owner === 'player' ? 'green' : 'red'}">${unit.owner === 'player' ? 'ÏïÑÍµ∞' : 'Ï†ÅÍµ∞'}</span>
        </div>`;
        if (unit.moved) {
          html += `<div class="info-row">
            <span class="info-label">ÏÉÅÌÉú</span>
            <span class="info-value">ÌñâÎèô ÏôÑÎ£å ‚úì</span>
          </div>`;
        }
      }
      
      // Í≥µÏ§ë Ïú†Îãõ Ï†ïÎ≥¥
      if (airUnit) {
        const unitDef = UNITS[airUnit.type];
        html += `<div class="info-row" style="margin-top:8px;border-top:1px solid #3a4a23;padding-top:8px;">
          <span class="info-label">‚úàÔ∏è Í≥µÏ§ë</span>
          <span class="info-value">${unitDef.icon} ${unitDef.name}</span>
        </div>`;
        html += `<div class="info-row">
          <span class="info-label">ÏÜåÏú†</span>
          <span class="info-value ${airUnit.owner === 'player' ? 'green' : 'red'}">${airUnit.owner === 'player' ? 'ÏïÑÍµ∞' : 'Ï†ÅÍµ∞'}</span>
        </div>`;
      }
      
      content.innerHTML = html;
    }
    
    // ÏóÖÍ∑∏Î†àÏù¥Îìú Ìå®ÎÑê ÏóÖÎç∞Ïù¥Ìä∏ (Ìò∏ÌôòÏÑ±)
    function updateUpgradePanel(tile) {
      updateTileInfoPanel(tile);
    }
    
    // ÏóÖÍ∑∏Î†àÏù¥Îìú Ïä§ÌÉØ ÌÖçÏä§Ìä∏
    function getUpgradeStatText(buildingDef, level) {
      const stats = buildingDef.levelStats[level];
      if (!stats) return '';
      
      switch (buildingDef.upgradeType) {
        case 'income':
          return `ÌÑ¥Îãπ +${stats.income.toLocaleString()}Ïõê`;
        case 'range':
          return `ÏÇ¨Í±∞Î¶¨ ${stats.attackRange}Ïπ∏`;
        case 'production':
          return `Ï†úÏûë ${stats.buildTurns}ÌÑ¥`;
        default:
          return '';
      }
    }
    
    // ÏóÖÍ∑∏Î†àÏù¥Îìú Ïã§Ìñâ
    function executeUpgrade(x, y) {
      const building = getBuildingAt(x, y);
      if (!building || building.owner !== 'player') return;
      
      const buildingDef = BUILDINGS[building.type];
      if (!buildingDef.upgradable) return;
      
      const currentLevel = building.level || 1;
      if (currentLevel >= buildingDef.maxLevel) return;
      
      const upgradeCost = getUpgradeCost(building.type, currentLevel);
      if (gameState.resources.player < upgradeCost) {
        addLog('ÏûêÏõêÏù¥ Î∂ÄÏ°±Ìï©ÎãàÎã§!', 'system');
        return;
      }
      
      // ÎπÑÏö© Ï∞®Í∞ê
      gameState.resources.player -= upgradeCost;
      
      // Î†àÎ≤® Ï¶ùÍ∞Ä
      building.level = currentLevel + 1;
      
      // Ïä§ÌÉØ ÏóÖÎç∞Ïù¥Ìä∏
      const newStats = buildingDef.levelStats[building.level];
      if (buildingDef.upgradeType === 'income') {
        building.income = newStats.income;
      } else if (buildingDef.upgradeType === 'range') {
        building.attackRange = newStats.attackRange;
      } else if (buildingDef.upgradeType === 'production') {
        building.buildTurns = newStats.buildTurns;
      }
      
      addLog(`‚¨ÜÔ∏è ${buildingDef.name} Lv.${building.level}Î°ú ÏóÖÍ∑∏Î†àÏù¥Îìú! (üí∞ -${upgradeCost.toLocaleString()})`, 'action');
      
      updateResourceDisplay();
      updateUpgradePanel(gameState.selectedTile);
      renderMap();
    }
    
    // Í±¥Î¨º ÏàòÏûÖ Í≥ÑÏÇ∞ (Î†àÎ≤® Î∞òÏòÅ)
    function getBuildingIncome(building) {
      const buildingDef = BUILDINGS[building.type];
      if (!buildingDef) return 0;
      
      if (buildingDef.upgradable && buildingDef.upgradeType === 'income') {
        const level = building.level || 1;
        return buildingDef.levelStats[level].income;
      }
      
      return buildingDef.income || 0;
    }
    
    // Í±¥Î¨º ÏÇ¨Í±∞Î¶¨ Í≥ÑÏÇ∞ (Î†àÎ≤® Î∞òÏòÅ)
    function getBuildingRange(building) {
      const buildingDef = BUILDINGS[building.type];
      if (!buildingDef) return 0;
      
      if (buildingDef.upgradable && buildingDef.upgradeType === 'range') {
        const level = building.level || 1;
        return buildingDef.levelStats[level].attackRange;
      }
      
      return buildingDef.attackRange || 0;
    }
    
    // Íµ∞ÏàòÍ≥µÏû• ÏÉùÏÇ∞ ÌÑ¥ Í≥ÑÏÇ∞ (Î†àÎ≤® Î∞òÏòÅ)
    function getFactoryBuildTurns(building) {
      const buildingDef = BUILDINGS[building.type];
      if (!buildingDef) return MISSILE_BUILD_TURNS;
      
      if (buildingDef.upgradable && buildingDef.upgradeType === 'production') {
        const level = building.level || 1;
        return buildingDef.levelStats[level].buildTurns;
      }
      
      return MISSILE_BUILD_TURNS;
    }
    
    // ÏãúÍ∞Ñ Ìè¨Îß∑
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // ÌÑ¥ ÌÉÄÏù¥Î®∏ ÏãúÏûë
    function startTurnTimer() {
      if (gameState.turnInterval) clearInterval(gameState.turnInterval);
      
      gameState.turnTimeLeft = TURN_TIME_LIMIT;
      updateTurnDisplay();
      
      gameState.turnInterval = setInterval(() => {
        gameState.turnTimeLeft--;
        updateTurnDisplay();
        
        if (gameState.turnTimeLeft <= 0) {
          endTurn();
        }
      }, 1000);
    }
    
    // ÌÑ¥ ÌëúÏãú ÏóÖÎç∞Ïù¥Ìä∏
    function updateTurnDisplay() {
      const timerBar = document.querySelector('.map-timer-bar');
      const turnTimer = document.getElementById('turn-timer');
      const turnText = document.getElementById('turn-text');
      const endTurnBtn = document.getElementById('end-turn-btn');
      const turnNumber = document.getElementById('turn-number');
      
      if (turnTimer) turnTimer.textContent = formatTime(gameState.turnTimeLeft);
      if (turnNumber) turnNumber.textContent = gameState.turnNumber;
      
      if (gameState.isPlayerTurn) {
        if (timerBar) timerBar.classList.remove('enemy-turn');
        if (turnText) turnText.textContent = 'ÎãπÏã†Ïùò ÌÑ¥';
        if (endTurnBtn) endTurnBtn.disabled = false;
      } else {
        if (timerBar) timerBar.classList.add('enemy-turn');
        if (turnText) turnText.textContent = `${gameState.opponent.name}Ïùò ÌÑ¥`;
        if (endTurnBtn) endTurnBtn.disabled = true;
      }
    }
    

    // ==================== AI ÏãúÏä§ÌÖú ====================
    
    // AI ÏÉÅÌÉú
    const aiState = {
      type: 'balanced', // defensive, balanced, aggressive
      phase: 'early',   // early, mid, late
      hasBarracks: false,
      hasFarm: false,
      hasFactory: false,
      hasSilo: false,
      actionDelay: 300,
      actionsThisTurn: 0,
      maxActionsPerTurn: 1  // Í∏∞Î≥∏ 1Ìöå ÌñâÎèô
    };
    
    // AI ÌÉÄÏûÖÎ≥Ñ ÏÑ§Ï†ï
    const AI_CONFIG = {
      defensive: {
        name: 'ÏàòÎπÑÌòï AI',
        icon: 'üõ°Ô∏è',
        initialResources: 1000000,  // 100ÎßåÏõê ÏãúÏûë
        buildPriority: 0.8,
        recruitPriority: 0.5,
        attackPriority: 0.3,
        preferredUnits: ['engineer', 'soldier', 'military_engineer', 'anti_tank'],
        soldierCount: [500, 800, 1000, 1500],
        moveAggressiveness: 0.3,
        useMissiles: true,
        useNavy: true,
        useTanks: true,
        useCities: true,
        maxMovesPerTurn: 2,
        maxAttacksPerTurn: 2,
        tankProductionChance: 0.4,
        cityBuildChance: 0.7,
        missileFireChance: 0.5,
        transportAttackChance: 0.3,
        isHardMode: false
      },
      balanced: {
        name: 'Î∞∏Îü∞Ïä§Ìòï AI',
        icon: '‚öñÔ∏è',
        initialResources: 1000000,
        buildPriority: 0.6,
        recruitPriority: 0.7,
        attackPriority: 0.6,
        preferredUnits: ['engineer', 'soldier', 'commando', 'military_engineer', 'anti_tank'],
        soldierCount: [800, 1000, 1500, 2000, 3000],
        moveAggressiveness: 0.5,
        useMissiles: true,
        useNavy: true,
        useTanks: true,
        useCities: true,
        maxMovesPerTurn: 2,
        maxAttacksPerTurn: 3,
        tankProductionChance: 0.5,
        cityBuildChance: 0.8,
        missileFireChance: 0.6,
        transportAttackChance: 0.5,
        isHardMode: false
      },
      aggressive: {
        name: 'Í≥µÍ≤©Ìòï AI',
        icon: '‚öîÔ∏è',
        initialResources: 1000000,
        buildPriority: 0.5,
        recruitPriority: 0.9,
        attackPriority: 0.9,
        preferredUnits: ['soldier', 'commando', 'military_engineer', 'anti_tank'],
        soldierCount: [1000, 1500, 2000, 3000, 5000],
        moveAggressiveness: 0.8,
        useMissiles: true,
        useNavy: true,
        useTanks: true,
        useCities: true,
        maxMovesPerTurn: 3,
        maxAttacksPerTurn: 4,
        tankProductionChance: 0.7,
        cityBuildChance: 0.6,
        missileFireChance: 0.8,
        transportAttackChance: 0.7,
        isHardMode: false
      },
      hard: {
        name: 'ÌïòÎìú Î™®Îìú (ÌéòÏù¥Ïª§)',
        icon: 'üíÄ',
        initialResources: 2000000,  // 200ÎßåÏõê ÏãúÏûë
        buildPriority: 0.95,
        recruitPriority: 0.95,
        attackPriority: 0.95,
        preferredUnits: ['soldier', 'commando', 'military_engineer', 'anti_tank', 'engineer'],
        soldierCount: [3000, 5000, 8000, 10000, 15000],
        moveAggressiveness: 0.95,
        useMissiles: true,
        useNavy: true,
        useTanks: true,
        useCities: true,
        maxMovesPerTurn: 5,
        maxAttacksPerTurn: 8,
        tankProductionChance: 0.9,
        cityBuildChance: 0.95,
        missileFireChance: 0.95,
        transportAttackChance: 0.9,
        isHardMode: true,
        initialMissiles: 5,
        initialTanks: 10  // Ï¥àÍ∏∞ ÌÉ±ÌÅ¨ 10ÎåÄ
      }
    };
    
    // AI ÌÉÄÏûÖ ÏÑ§Ï†ï
    function setAiType(type) {
      aiState.type = type;
      const config = AI_CONFIG[type];
      gameState.opponent = {
        name: config.name
      };
    }
    
    // AI ÌÑ¥ Ïã§Ìñâ
    async function executeEnemyTurn() {
      const config = AI_CONFIG[aiState.type];
      addLog(`ü§ñ ${config.icon} ${gameState.opponent.name}Ïù¥(Í∞Ä) Ï†ÑÎûµÏùÑ Î∂ÑÏÑù Ï§ë...`, 'enemy');
      
      // Ï†Å ÏûêÏõê ÏàòÏûÖ Í≥ÑÏÇ∞
      let enemyBuildingIncome = 0;
      gameState.buildings.forEach(building => {
        if (building.owner === 'enemy') {
          enemyBuildingIncome += getBuildingIncome(building);
        }
      });
      gameState.resources.enemy += TURN_INCOME + enemyBuildingIncome;
      
      if (enemyBuildingIncome > 0) {
        addLog(`ü§ñ Ï†Å Í±¥Î¨º ÏàòÏûÖ: +${enemyBuildingIncome.toLocaleString()}`, 'enemy');
      }
      
      // Ï†Å Ïú†Îãõ/Í±¥Î¨º ÏÉÅÌÉú Î¶¨ÏÖã
      gameState.units.forEach(unit => {
        if (unit.owner === 'enemy') unit.moved = false;
      });
      gameState.buildings.forEach(building => {
        if (building.owner === 'enemy') {
          if (building.fired !== undefined) building.fired = false;
          if (building.produced !== undefined) building.produced = false;
        }
      });
      
      // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÏßÑÌñâ
      processMissileProduction('enemy');
      
      // AI ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      updateAiState();
      
      await delay(aiState.actionDelay);
      
      // === ÌïòÎìú Î™®Îìú: Îã§Ï§ë ÌñâÎèô ===
      if (config.isHardMode) {
        await executeHardModeActions(config);
      } 
      // === ÏùºÎ∞ò Î™®Îìú: Ï≤¥Í≥ÑÏ†Å Ïö¥ÏòÅ (ÌÑ¥Îãπ 1Ìöå Ï£ºÏöî ÌñâÎèô) ===
      else {
        await executeNormalModeActions(config);
      }
      
      addLog(`ü§ñ ${gameState.opponent.name}Ïùò ÌÑ¥ Ï¢ÖÎ£å`, 'enemy');
    }
    
    // ÏùºÎ∞ò Î™®Îìú AI ÌñâÎèô (Í∞ïÌôîÎêú Ï†ÑÎûµÏ†Å Ïö¥ÏòÅ)
    async function executeNormalModeActions(config) {
      let mainActionDone = false;
      
      // === 1. Ï†ÑÎûµÏ†Å Ïö∞ÏÑ†ÏàúÏúÑÏóê Îî∞Î•∏ Ï£ºÏöî ÌñâÎèô ===
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 1: Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏúºÎ©¥ Í±¥Ï∂ïÍ∞Ä ÏÉùÏÇ∞ (ÎèÑÏãú Í±¥ÏÑ§Ïö©)
      const hasEngineer = gameState.units.some(u => u.owner === 'enemy' && u.type === 'engineer');
      if (!hasEngineer && !mainActionDone) {
        const recruited = await aiRecruitSpecificUnit('engineer');
        if (recruited) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 2: Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÇ∞
      const hasMilitaryEng = gameState.units.some(u => u.owner === 'enemy' && u.type === 'military_engineer');
      if (!hasMilitaryEng && gameState.resources.enemy >= 5000 && !mainActionDone) {
        const recruited = await aiRecruitSpecificUnit('military_engineer');
        if (recruited) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 3: ÎèÑÏãú Í±¥ÏÑ§ (Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏûàÍ≥† ÎèÑÏãú Î∂ÄÏ°±Ïãú) - ÎÜçÏû• ÎåÄÏã†!
      const cityCount = gameState.buildings.filter(b => b.owner === 'enemy' && b.type === 'city').length;
      if (hasEngineer && cityCount < 3 && gameState.resources.enemy >= BUILDINGS.city.cost && !mainActionDone) {
        const built = await aiBuildCity();
        if (built) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 4: ÎèÑÏãú ÏóÖÍ∑∏Î†àÏù¥Îìú (ÎèàÏù¥ ÎßéÏúºÎ©¥)
      if (gameState.resources.enemy >= 200000 && !mainActionDone) {
        const upgraded = await aiUpgradeCity();
        if (upgraded) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 5: ÏßïÎ≥ëÏÜå Í±¥ÏÑ§
      if (hasEngineer && !aiState.hasBarracks && !mainActionDone) {
        const built = await aiBuildBarracks();
        if (built) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 6: Íµ∞ÏÇ¨ Í±¥Î¨º Í±¥ÏÑ§ (Íµ∞ÏàòÍ≥µÏû• ‚Üí ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ÎåÄ)
      if (hasMilitaryEng && !mainActionDone) {
        const built = await aiBuildMilitaryStructures();
        if (built) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 7: ÌîåÎ†àÏù¥Ïñ¥ ÌÉ±ÌÅ¨ ÎåÄÏùë - ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë ÏÉùÏÇ∞
      const playerTanks = gameState.units.filter(u => u.owner === 'player' && UNITS[u.type].isTank);
      const enemyAntiTank = gameState.units.filter(u => u.owner === 'enemy' && u.type === 'anti_tank');
      if (playerTanks.length > 0 && enemyAntiTank.length < playerTanks.length * 2 && !mainActionDone) {
        const recruited = await aiRecruitSpecificUnit('anti_tank');
        if (recruited) mainActionDone = true;
      }
      
      // Ïö∞ÏÑ†ÏàúÏúÑ 8: Î≥ëÏÇ¨/ÌäπÍ≥µÎåÄ ÏÉùÏÇ∞
      if (!mainActionDone && Math.random() < config.recruitPriority) {
        await aiRecruitUnits();
        mainActionDone = true;
      }
      
      await delay(200);
      
      // === 2. ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ (Íµ∞ÏàòÍ≥µÏû•Ïù¥ ÏûàÍ≥† ÏûêÏõê Ï∂©Î∂ÑÏãú) ===
      if (config.useTanks && Math.random() < config.tankProductionChance) {
        await aiProduceTanks();
      }
      
      // === 3. ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î∞è Î∞úÏÇ¨ ===
      if (config.useMissiles) {
        await aiProduceMissiles();
        
        // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ (ÌôïÎ•† Í∏∞Î∞ò)
        if (gameState.missiles.enemy > 0 && Math.random() < config.missileFireChance) {
          await delay(200);
          await aiLaunchMissile();
        }
      }
      
      // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨
      await aiFireMortars();
      
      await delay(200);
      
      // === 4. Ïù¥Îèô (configÏóê Îî∞Îùº Ïó¨Îü¨ Î≤à) ===
      for (let i = 0; i < config.maxMovesPerTurn; i++) {
        await aiMoveUnits();
        await delay(100);
      }
      
      // === 5. Í≥µÍ≤© (configÏóê Îî∞Îùº Ïó¨Îü¨ Î≤à) ===
      for (let i = 0; i < config.maxAttacksPerTurn; i++) {
        if (Math.random() < config.attackPriority) {
          await delay(200);
          await aiAttack();
        }
      }
      
      // === 6. Ìï¥Íµ∞ Ïö¥Ïö© (ÏàòÏÜ°ÏÑ† ÏÉÅÎ•ô Í≥µÍ≤© Ìè¨Ìï®) ===
      if (config.useNavy) {
        await delay(200);
        await aiNavalOperations();
        
        // ÏàòÏÜ°ÏÑ†Ïóê Ïú†Îãõ ÌÉëÏäπ
        await aiLoadTransports();
        
        // ÏàòÏÜ°ÏÑ† ÏÉÅÎ•ô ÏûëÏ†Ñ
        if (Math.random() < config.transportAttackChance) {
          await aiTransportLanding();
        }
      }
    }
    
    // ÌïòÎìú Î™®Îìú AI ÌñâÎèô (Îã§Ï§ë ÌñâÎèô - Îß§Ïö∞ Í∞ïÎ†•!)
    async function executeHardModeActions(config) {
      // === 1. Í≤ΩÏ†ú Í±¥Î¨º (ÎèÑÏãú Ïö∞ÏÑ†) ===
      for (let i = 0; i < 3; i++) {
        const cityCount = gameState.buildings.filter(b => b.owner === 'enemy' && b.type === 'city').length;
        if (cityCount < 5) {
          await aiBuildCity();
          await delay(100);
        }
      }
      
      // ÎèÑÏãú ÏóÖÍ∑∏Î†àÏù¥Îìú (ÏµúÎåÄÌïú ÎßéÏù¥)
      for (let i = 0; i < 5; i++) {
        await aiUpgradeCity();
        await delay(50);
      }
      
      // === 2. Íµ∞ÏÇ¨ Í±¥Î¨º Í±¥ÏÑ§ ===
      for (let i = 0; i < 3; i++) {
        await aiBuildMilitaryStructures();
        await delay(100);
      }
      
      // === 3. Ïú†Îãõ ÏÉùÏÇ∞ ===
      // ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë (ÌîåÎ†àÏù¥Ïñ¥ ÌÉ±ÌÅ¨ ÎåÄÏùë)
      const playerTanks = gameState.units.filter(u => u.owner === 'player' && UNITS[u.type].isTank);
      if (playerTanks.length > 0) {
        for (let i = 0; i < 3; i++) {
          await aiRecruitSpecificUnit('anti_tank');
          await delay(50);
        }
      }
      
      // ÏùºÎ∞ò Ïú†Îãõ ÏÉùÏÇ∞ (5Ìöå)
      for (let i = 0; i < 5; i++) {
        await aiRecruitUnits();
        await delay(100);
      }
      
      // === 4. ÌÉ±ÌÅ¨ ÎåÄÎüâ ÏÉùÏÇ∞ ===
      for (let i = 0; i < 3; i++) {
        await aiProduceTanks();
        await delay(100);
      }
      
      // === 5. ÎØ∏ÏÇ¨Ïùº ÏãúÏä§ÌÖú ===
      await aiProduceMissiles();
      
      // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ (ÏµúÎåÄ 5Î∞ú)
      for (let i = 0; i < 5 && gameState.missiles.enemy > 0; i++) {
        await delay(200);
        await aiLaunchMissile();
      }
      
      // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨
      await aiFireMortars();
      
      // === 6. Ïù¥Îèô (5Ìöå) ===
      for (let i = 0; i < config.maxMovesPerTurn; i++) {
        await aiMoveUnits();
        await delay(50);
      }
      
      // === 7. Í≥µÍ≤© (8Ìöå) ===
      for (let i = 0; i < config.maxAttacksPerTurn; i++) {
        await aiAttack();
        await delay(100);
      }
      
      // === 8. Ìï¥Íµ∞ ÏÉÅÎ•ô ÏûëÏ†Ñ ===
      await aiNavalOperations();
      await aiLoadTransports();
      await aiTransportLanding();
      await aiTransportOperations();
    }
    
    // ÌäπÏ†ï Ïú†Îãõ ÏÉùÏÇ∞
    async function aiRecruitSpecificUnit(unitType) {
      const unitDef = UNITS[unitType];
      if (!unitDef) return false;
      
      const cost = unitDef.cost;
      if (gameState.resources.enemy < cost) return false;
      
      // ÏÉùÏÇ∞ ÏúÑÏπò Ï∞æÍ∏∞
      const productionSites = [];
      gameState.map.forEach((row, y) => {
        row.forEach((tile, x) => {
          if ((tile.type === 'main_base' || tile.type === 'sub_base') && tile.owner === 'enemy') {
            productionSites.push({ x, y });
          }
        });
      });
      
      const enemyBarracks = gameState.buildings.filter(b => b.owner === 'enemy' && b.type === 'barracks');
      productionSites.push(...enemyBarracks);
      
      if (productionSites.length === 0) return false;
      
      const site = productionSites[Math.floor(Math.random() * productionSites.length)];
      const spawnTile = findEnemySpawnTile(site.x, site.y);
      if (!spawnTile) return false;
      
      gameState.resources.enemy -= cost;
      gameState.units.push({
        id: Date.now() + Math.random(),
        type: unitType,
        x: spawnTile.x,
        y: spawnTile.y,
        owner: 'enemy',
        count: 1,
        moved: true
      });
      
      addLog(`ü§ñ Ï†ÅÏù¥ ${unitDef.name}ÏùÑ(Î•º) ÏÉùÏÇ∞ÌñàÏäµÎãàÎã§!`, 'enemy');
      renderMap();
      return true;
    }
    
    // ÎÜçÏû•/Ïò®Ïã§ Í±¥ÏÑ§ (ÎÜçÎ∂Ä ÏÇ¨Ïö©)
    async function aiBuildFarmStructures() {
      const farmers = gameState.units.filter(u => u.owner === 'enemy' && u.type === 'farmer' && !u.moved);
      if (farmers.length === 0) return false;
      
      const farmer = farmers[0];
      const buildTile = findBuildableTileForFarm(farmer.x, farmer.y);
      if (!buildTile) return false;
      
      // Ïò®Ïã§ Ïö∞ÏÑ† (ÏûêÏõê Ï∂©Î∂ÑÏãú), ÏïÑÎãàÎ©¥ ÎÜçÏû•
      let buildType = 'farm';
      if (gameState.resources.enemy >= BUILDINGS.greenhouse.cost) {
        buildType = 'greenhouse';
      } else if (gameState.resources.enemy < BUILDINGS.farm.cost) {
        return false;
      }
      
      gameState.resources.enemy -= BUILDINGS[buildType].cost;
      gameState.buildings.push({
        type: buildType,
        x: buildTile.x,
        y: buildTile.y,
        owner: 'enemy',
        hp: BUILDINGS[buildType].hp,
        level: 1
      });
      
      farmer.moved = true;
      addLog(`ü§ñ Ï†ÅÏù¥ ${BUILDINGS[buildType].name}ÏùÑ(Î•º) Í±¥ÏÑ§ÌñàÏäµÎãàÎã§!`, 'enemy');
      renderMap();
      return true;
    }
    
    // ÎÜçÏû• Í±¥ÏÑ§ Í∞ÄÎä• ÌÉÄÏùº Ï∞æÍ∏∞
    function findBuildableTileForFarm(x, y) {
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
      ];
      
      for (const dir of directions) {
        const nx = x + dir.x;
        const ny = y + dir.y;
        
        if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
        if (ny > ENEMY_ZONE_END) continue;
        
        const tile = gameState.map[ny][nx];
        if (tile.terrain !== 'land' || tile.type !== 'empty') continue;
        if (getBuildingAt(nx, ny)) continue;
        if (getGroundUnitAt(nx, ny)) continue;
        
        return { x: nx, y: ny };
      }
      return null;
    }
    
    // ÏßïÎ≥ëÏÜå Í±¥ÏÑ§ (Í±¥Ï∂ïÍ∞Ä ÏÇ¨Ïö©)
    async function aiBuildBarracks() {
      const engineers = gameState.units.filter(u => u.owner === 'enemy' && u.type === 'engineer' && !u.moved);
      if (engineers.length === 0) return false;
      if (gameState.resources.enemy < BUILDINGS.barracks.cost) return false;
      
      const engineer = engineers[0];
      const buildTile = findBuildableTileForFarm(engineer.x, engineer.y);
      if (!buildTile) return false;
      
      gameState.resources.enemy -= BUILDINGS.barracks.cost;
      gameState.buildings.push({
        type: 'barracks',
        x: buildTile.x,
        y: buildTile.y,
        owner: 'enemy',
        hp: BUILDINGS.barracks.hp,
        level: 1
      });
      
      engineer.moved = true;
      addLog(`ü§ñ Ï†ÅÏù¥ ÏßïÎ≥ëÏÜåÎ•º Í±¥ÏÑ§ÌñàÏäµÎãàÎã§!`, 'enemy');
      renderMap();
      return true;
    }
    
    // ÎîúÎ†àÏù¥ Ïú†Ìã∏Î¶¨Ìã∞
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
    
    // AI ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    function updateAiState() {
      // Ï†Å ÏßïÎ≥ëÏÜå ÌôïÏù∏
      aiState.hasBarracks = gameState.buildings.some(b => 
        b.owner === 'enemy' && b.type === 'barracks'
      );
      
      // Ï†Å ÎÜçÏû• ÌôïÏù∏
      aiState.hasFarm = gameState.buildings.some(b => 
        b.owner === 'enemy' && (b.type === 'farm' || b.type === 'greenhouse')
      );
      
      // Íµ∞ÏÇ¨ Í±¥Î¨º ÌôïÏù∏
      aiState.hasFactory = gameState.buildings.some(b => 
        b.owner === 'enemy' && b.type === 'arms_factory'
      );
      aiState.hasSilo = gameState.buildings.some(b => 
        b.owner === 'enemy' && b.type === 'missile_silo'
      );
      
      // Í≤åÏûÑ Îã®Í≥Ñ ÌåêÎã® (ÏûêÏõê Í∏∞Î∞òÏúºÎ°ú Î≥ÄÍ≤Ω)
      const enemyResources = gameState.resources.enemy;
      if (gameState.turnNumber <= 3) {
        aiState.phase = 'early';
      } else if (gameState.turnNumber <= 10) {
        aiState.phase = 'mid';
      } else {
        aiState.phase = 'late';
      }
    }
    
    // AI Ïú†Îãõ ÏÉùÏÇ∞ (1Î≤àÎßå)
    async function aiRecruitUnits() {
      const config = AI_CONFIG[aiState.type];
      
      // ÏÉùÏÇ∞ ÏúÑÏπò Ï∞æÍ∏∞ (Í∏∞ÏßÄ ÎòêÎäî ÏßïÎ≥ëÏÜå)
      const productionSites = [];
      
      // Ï†Å Í∏∞ÏßÄ ÏúÑÏπò ÏàòÏßë
      gameState.map.forEach((row, y) => {
        row.forEach((tile, x) => {
          if ((tile.type === 'main_base' || tile.type === 'sub_base') && tile.owner === 'enemy') {
            productionSites.push({ x, y, type: tile.type });
          }
        });
      });
      
      // Ï†Å ÏßïÎ≥ëÏÜå ÏúÑÏπò ÏàòÏßë
      const enemyBarracks = gameState.buildings.filter(b => 
        b.owner === 'enemy' && b.type === 'barracks'
      );
      productionSites.push(...enemyBarracks);
      
      if (productionSites.length === 0) return false;
      
      // ÎûúÎç§ ÏÉùÏÇ∞ ÏúÑÏπò ÏÑ†ÌÉù
      const site = productionSites[Math.floor(Math.random() * productionSites.length)];
      
      // Ïä§Ìè∞ ÏúÑÏπò Ï∞æÍ∏∞
      const spawnTile = findEnemySpawnTile(site.x, site.y);
      if (!spawnTile) return false;
      
      // Ïñ¥Îñ§ Ïú†ÎãõÏùÑ ÏÉùÏÇ∞Ìï†ÏßÄ Í≤∞Ï†ï
      const unitType = decideUnitToRecruit();
      if (!unitType) return false;
      
      const unitDef = UNITS[unitType];
      
      // ÏàòÎüâ Í≤∞Ï†ï (Î≥ëÏÇ¨/ÌäπÍ≥µÎåÄÎäî Îã§ÏñëÌïú ÏàòÎüâ)
      let quantity = 1;
      if (unitType === 'soldier' || unitType === 'commando') {
        const counts = config.soldierCount;
        quantity = counts[Math.floor(Math.random() * counts.length)];
      }
      
      const totalCost = unitDef.cost * (unitType === 'soldier' || unitType === 'commando' ? quantity / 100 : quantity);
      
      if (gameState.resources.enemy < totalCost) return false;
      
      // ÏûêÏõê Ï∞®Í∞ê Î∞è Ïú†Îãõ ÏÉùÏÇ∞
      gameState.resources.enemy -= totalCost;
      
      // Í∞ôÏùÄ ÏúÑÏπòÏóê Í∞ôÏùÄ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ Ìï©Î•ò
      const existingUnit = gameState.units.find(u => 
        u.x === spawnTile.x && u.y === spawnTile.y && 
        u.type === unitType && u.owner === 'enemy'
      );
      
      if (existingUnit) {
        existingUnit.count += quantity;
      } else {
        gameState.units.push({
          id: Date.now() + Math.random(),
          type: unitType,
          x: spawnTile.x,
          y: spawnTile.y,
          owner: 'enemy',
          hp: unitDef.hp,
          count: quantity,
          moved: true
        });
      }
      
      const countText = (unitType === 'soldier' || unitType === 'commando') ? `${quantity}Î™Ö` : '';
      addLog(`ü§ñ Ï†ÅÏù¥ ${unitDef.name} ${countText}ÏùÑ(Î•º) ÏÉùÏÇ∞ÌñàÏäµÎãàÎã§!`, 'enemy');
      renderMap();
      
      return true;
    }
    
    // Ï†Å Ïú†Îãõ Ïä§Ìè∞ ÏúÑÏπò Ï∞æÍ∏∞
    function findEnemySpawnTile(centerX, centerY) {
      // Î®ºÏ†Ä Ìï¥Îãπ ÏúÑÏπòÏóê Ïú†ÎãõÏù¥ ÏóÜÏúºÎ©¥ Í∑∏ ÏûêÎ¶¨Ïóê
      if (!getUnitAt(centerX, centerY)) {
        const tile = gameState.map[centerY][centerX];
        if (tile.terrain !== 'sea') {
          return { x: centerX, y: centerY };
        }
      }
      
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
      ];
      
      for (const dir of directions) {
        const nx = centerX + dir.x;
        const ny = centerY + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const tile = gameState.map[ny][nx];
          if (tile.terrain !== 'sea' && !getUnitAt(nx, ny)) {
            return { x: nx, y: ny };
          }
        }
      }
      return null;
    }
    
    // Ïñ¥Îñ§ Ïú†ÎãõÏùÑ ÏÉùÏÇ∞Ìï†ÏßÄ Í≤∞Ï†ï
    function decideUnitToRecruit() {
      const config = AI_CONFIG[aiState.type];
      const enemyUnits = gameState.units.filter(u => u.owner === 'enemy');
      
      // Ïú†Îãõ Ïàò Í≥ÑÏÇ∞
      const engineerCount = enemyUnits.filter(u => u.type === 'engineer').length;
      const farmerCount = enemyUnits.filter(u => u.type === 'farmer').length;
      const militaryEngCount = enemyUnits.filter(u => u.type === 'military_engineer').length;
      const soldierCount = enemyUnits.filter(u => u.type === 'soldier')
        .reduce((sum, u) => sum + u.count, 0);
      
      // Ï¥àÍ∏∞: Í±¥Ï∂ïÍ∞Ä/ÎÜçÎ∂Ä Ïö∞ÏÑ†
      if (aiState.phase === 'early') {
        if (engineerCount < 2 && gameState.resources.enemy >= UNITS.engineer.cost) {
          return 'engineer';
        }
        if (!aiState.hasFarm && farmerCount < 2 && gameState.resources.enemy >= UNITS.farmer.cost) {
          return 'farmer';
        }
      }
      
      // Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞ÄÍ∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÇ∞ (Ï§ëÍ∏∞ Ïù¥ÌõÑ)
      if (aiState.phase !== 'early' && militaryEngCount < 2 && 
          gameState.resources.enemy >= UNITS.military_engineer.cost) {
        if (Math.random() < 0.5) {
          return 'military_engineer';
        }
      }
      
      // ÌõÑÍ∏∞ÏóêÎäî ÌäπÍ≥µÎåÄÎèÑ ÏÉùÏÇ∞
      if (aiState.phase === 'late' && Math.random() < 0.3 &&
          gameState.resources.enemy >= UNITS.commando.cost * 10) {
        return 'commando';
      }
      
      // AI ÌÉÄÏûÖÏóê Îî∞Î•∏ ÏÑ†Ìò∏ Ïú†Îãõ ÏÑ†ÌÉù
      const preferred = config.preferredUnits;
      const chosen = preferred[Math.floor(Math.random() * preferred.length)];
      
      if (UNITS[chosen] && gameState.resources.enemy >= UNITS[chosen].cost) {
        return chosen;
      }
      
      // Í∏∞Î≥∏ Î≥ëÏÇ¨
      if (gameState.resources.enemy >= UNITS.soldier.cost) {
        return 'soldier';
      }
      
      return null;
    }
    
    // AI Í±¥Î¨º Í±¥ÏÑ§ (1Î≤àÎßå)
    async function aiBuildStructures() {
      const config = AI_CONFIG[aiState.type];
      
      // Í±¥Ï∂ïÍ∞Ä Ï∞æÍ∏∞
      const enemyEngineers = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'engineer' && !u.moved
      );
      
      const enemyFarmers = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'farmer' && !u.moved
      );
      
      // ÏàòÎπÑÌòï: ÎÜçÏû• Ïö∞ÏÑ†
      if (aiState.type === 'defensive' && enemyFarmers.length > 0) {
        const farmer = enemyFarmers[0];
        const buildTile = findBuildableTile(farmer.x, farmer.y, 'enemy');
        
        if (buildTile && gameState.resources.enemy >= BUILDINGS.farm.cost) {
          const buildType = gameState.resources.enemy >= BUILDINGS.greenhouse.cost ? 'greenhouse' : 'farm';
          
          gameState.resources.enemy -= BUILDINGS[buildType].cost;
          gameState.buildings.push({
            type: buildType,
            x: buildTile.x,
            y: buildTile.y,
            owner: 'enemy',
            hp: BUILDINGS[buildType].hp,
            level: 1
          });
          
          farmer.moved = true;
          aiState.hasFarm = true;
          
          addLog(`ü§ñ Ï†ÅÏù¥ (${buildTile.x}, ${buildTile.y})Ïóê ${BUILDINGS[buildType].icon} Í±¥ÏÑ§!`, 'enemy');
          renderMap();
          return true;
        }
      }
      
      // ÏßïÎ≥ëÏÜå Í±¥ÏÑ§
      if (enemyEngineers.length > 0 && !aiState.hasBarracks) {
        const engineer = enemyEngineers[0];
        const buildTile = findBuildableTile(engineer.x, engineer.y, 'enemy');
        
        if (buildTile && gameState.resources.enemy >= BUILDINGS.barracks.cost) {
          gameState.resources.enemy -= BUILDINGS.barracks.cost;
          gameState.buildings.push({
            type: 'barracks',
            x: buildTile.x,
            y: buildTile.y,
            owner: 'enemy',
            hp: BUILDINGS.barracks.hp,
            level: 1
          });
          
          engineer.moved = true;
          aiState.hasBarracks = true;
          
          addLog(`ü§ñ Ï†ÅÏù¥ (${buildTile.x}, ${buildTile.y})Ïóê ÏßïÎ≥ëÏÜåÎ•º Í±¥ÏÑ§ÌñàÏäµÎãàÎã§!`, 'enemy');
          renderMap();
          return true;
        }
      }
      
      // ÎÜçÎ∂ÄÎ°ú ÎÜçÏû• Í±¥ÏÑ§
      if (enemyFarmers.length > 0 && !aiState.hasFarm) {
        const farmer = enemyFarmers[0];
        const buildTile = findBuildableTile(farmer.x, farmer.y, 'enemy');
        
        if (buildTile && gameState.resources.enemy >= BUILDINGS.farm.cost) {
          gameState.resources.enemy -= BUILDINGS.farm.cost;
          gameState.buildings.push({
            type: 'farm',
            x: buildTile.x,
            y: buildTile.y,
            owner: 'enemy',
            hp: BUILDINGS.farm.hp,
            level: 1
          });
          
          farmer.moved = true;
          aiState.hasFarm = true;
          
          addLog(`ü§ñ Ï†ÅÏù¥ (${buildTile.x}, ${buildTile.y})Ïóê üåæÎÜçÏû•ÏùÑ Í±¥ÏÑ§ÌñàÏäµÎãàÎã§!`, 'enemy');
          renderMap();
          return true;
        }
      }
      
      return false;
    }
    
    // Í±¥ÏÑ§ Í∞ÄÎä•Ìïú ÌÉÄÏùº Ï∞æÍ∏∞
    function findBuildableTile(centerX, centerY, owner) {
      const zoneLimit = owner === 'enemy' ? ENEMY_ZONE_END : PLAYER_ZONE_START;
      
      const directions = [
        {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
        {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
      ];
      
      for (const dir of directions) {
        const nx = centerX + dir.x;
        const ny = centerY + dir.y;
        
        if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
          const tile = gameState.map[ny][nx];
          const building = getBuildingAt(nx, ny);
          const unit = getUnitAt(nx, ny);
          
          // Ï†Å ÏòÅÏó≠ ÎÇ¥, Îπà ÌÉÄÏùº, Ïú°ÏßÄ
          const inZone = owner === 'enemy' ? ny <= zoneLimit : ny >= zoneLimit;
          if (inZone && tile.type === 'empty' && tile.terrain === 'land' && !building && !unit) {
            return { x: nx, y: ny };
          }
        }
      }
      return null;
    }
    
    // AI Ïú†Îãõ Ïù¥Îèô (ÌÑ¥Îãπ Ï†úÌïú)
    async function aiMoveUnits() {
      const config = AI_CONFIG[aiState.type];
      const maxMoves = config.maxMovesPerTurn || 1;  // Í∏∞Î≥∏ 1Ìöå
      let moveCount = 0;
      
      const movableUnits = gameState.units.filter(u => 
        u.owner === 'enemy' && !u.moved && 
        !UNITS[u.type].isNavalUnit && !UNITS[u.type].isAirUnit
      );
      
      // Í±¥Ï∂ïÍ∞Ä/ÎÜçÎ∂Ä Ïù¥Îèô (Í±¥ÏÑ§Ïö© - Ïù¥Îèô Ïπ¥Ïö¥Ìä∏Ïóê Ìè¨Ìï® Ïïà Ìï®)
      for (const unit of movableUnits) {
        const unitDef = UNITS[unit.type];
        
        if (unitDef.canBuild || unitDef.canFarm || unitDef.canMilitaryBuild) {
          const buildTarget = findBuildMoveTarget(unit);
          if (buildTarget) {
            await moveEnemyUnit(unit, buildTarget);
          }
        }
      }
      
      // Ï†ÑÌà¨ Ïú†Îãõ Ïù¥Îèô (Ï†úÌïú Ï†ÅÏö©)
      for (const unit of movableUnits) {
        if (moveCount >= maxMoves) break;
        
        const unitDef = UNITS[unit.type];
        
        // Í±¥Ï∂ïÍ∞Ä/ÎÜçÎ∂ÄÎäî ÏúÑÏóêÏÑú Ï≤òÎ¶¨Ìï®
        if (unitDef.canBuild || unitDef.canFarm || unitDef.canMilitaryBuild) continue;
        if (unit.moved) continue;
        
        // Ïù¥Îèô ÌôïÎ•† (moveAggressiveness)
        if (Math.random() > config.moveAggressiveness) continue;
        
        // Ï†ÑÌà¨ Ïú†ÎãõÏùÄ ÌîåÎ†àÏù¥Ïñ¥ Î∞©Ìñ•ÏúºÎ°ú ÏßÑÍ≤©
        const attackTarget = findAggressiveMoveTarget(unit);
        if (attackTarget) {
          await moveEnemyUnit(unit, attackTarget);
          moveCount++;
        }
      }
    }
    
    // Í±¥Ï∂ïÍ∞ÄÏö© Ïù¥Îèô Î™©Ìëú Ï∞æÍ∏∞
    function findBuildMoveTarget(unit) {
      const unitDef = UNITS[unit.type];
      const moveRange = unitDef.moveRange;
      
      // Ï†Å ÏòÅÏó≠ ÎÇ¥ Îπà ÌÉÄÏùº Ï∞æÍ∏∞
      for (let dy = -moveRange; dy <= moveRange; dy++) {
        for (let dx = -moveRange; dx <= moveRange; dx++) {
          const distance = Math.abs(dx) + Math.abs(dy);
          if (distance === 0 || distance > moveRange) continue;
          
          const nx = unit.x + dx;
          const ny = unit.y + dy;
          
          if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
          if (ny > ENEMY_ZONE_END) continue; // Ï†Å ÏòÅÏó≠Îßå
          
          const tile = gameState.map[ny][nx];
          if (tile.terrain !== 'land') continue;
          if (tile.type !== 'empty') continue;
          if (getUnitAt(nx, ny)) continue;
          if (getBuildingAt(nx, ny)) continue;
          
          return { x: nx, y: ny };
        }
      }
      return null;
    }
    
    // Í≥µÍ≤©Ï†Å Ïù¥Îèô Î™©Ìëú Ï∞æÍ∏∞ - ÌîåÎ†àÏù¥Ïñ¥ ÏòÅÏó≠ÏúºÎ°ú ÏßÑÍ≤©!
    function findAggressiveMoveTarget(unit) {
      const unitDef = UNITS[unit.type];
      const moveRange = unitDef.moveRange;
      
      let bestTarget = null;
      let bestScore = -Infinity;
      
      // ÌîåÎ†àÏù¥Ïñ¥ Î≥∏Í∏∞ÏßÄ ÏúÑÏπò Ï∞æÍ∏∞
      let playerMainBase = null;
      gameState.map.forEach((row, y) => {
        row.forEach((tile, x) => {
          if (tile.type === 'main_base' && tile.owner === 'player') {
            playerMainBase = { x, y };
          }
        });
      });
      
      for (let dy = -moveRange; dy <= moveRange; dy++) {
        for (let dx = -moveRange; dx <= moveRange; dx++) {
          const distance = Math.abs(dx) + Math.abs(dy);
          if (distance === 0 || distance > moveRange) continue;
          
          const nx = unit.x + dx;
          const ny = unit.y + dy;
          
          if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
          
          const tile = gameState.map[ny][nx];
          
          // Ïù¥Îèô Í∞ÄÎä• Ï°∞Í±¥
          if (tile.terrain === 'sea') continue;
          if (tile.terrain === 'river' && !getBuildingAt(nx, ny)?.type !== 'bridge') continue;
          if (getGroundUnitAt(nx, ny)) continue;
          
          let score = 0;
          
          // ÌîåÎ†àÏù¥Ïñ¥ ÏòÅÏó≠(ÏïÑÎûòÏ™Ω)ÏúºÎ°ú Í∞àÏàòÎ°ù ÎÜíÏùÄ Ï†êÏàò
          score += (ny - unit.y) * 10;
          
          // ÌîåÎ†àÏù¥Ïñ¥ Î≥∏Í∏∞ÏßÄÏôÄ Í∞ÄÍπåÏö∏ÏàòÎ°ù ÎÜíÏùÄ Ï†êÏàò
          if (playerMainBase) {
            const distToBase = Math.abs(nx - playerMainBase.x) + Math.abs(ny - playerMainBase.y);
            score += (100 - distToBase);
          }
          
          // ÌîåÎ†àÏù¥Ïñ¥ Ïú†Îãõ Í∑ºÏ≤òÎ©¥ Í≥µÍ≤© Í∏∞Ìöå Î≥¥ÎÑàÏä§
          const nearbyPlayerUnits = gameState.units.filter(u => 
            u.owner === 'player' && !UNITS[u.type].isAirUnit &&
            Math.abs(u.x - nx) <= unitDef.attackRange && 
            Math.abs(u.y - ny) <= unitDef.attackRange
          );
          score += nearbyPlayerUnits.length * 50;
          
          // ÌîåÎ†àÏù¥Ïñ¥ Í∏∞ÏßÄ Í∑ºÏ≤òÎ©¥ ÌÅ∞ Î≥¥ÎÑàÏä§
          if (tile.type === 'main_base' || tile.type === 'sub_base') {
            if (tile.owner === 'player') score += 100;
          }
          
          if (score > bestScore) {
            bestScore = score;
            bestTarget = { x: nx, y: ny };
          }
        }
      }
      
      return bestTarget;
    }
    
    // Ïù¥Îèô Î™©Ìëú Ï∞æÍ∏∞ (Î†àÍ±∞Ïãú - Ìò∏ÌôòÏÑ±)
    function findMoveTarget(unit, purpose) {
      const unitDef = UNITS[unit.type];
      const moveRange = unitDef.moveRange;
      
      let bestTarget = null;
      let bestScore = -Infinity;
      
      for (let dy = -moveRange; dy <= moveRange; dy++) {
        for (let dx = -moveRange; dx <= moveRange; dx++) {
          const distance = Math.abs(dx) + Math.abs(dy);
          if (distance === 0 || distance > moveRange) continue;
          
          const nx = unit.x + dx;
          const ny = unit.y + dy;
          
          if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
          
          const tile = gameState.map[ny][nx];
          
          // Ïù¥Îèô Î∂àÍ∞Ä Ï°∞Í±¥
          if (tile.terrain === 'sea') continue;
          if (getUnitAt(nx, ny)) continue;
          
          let score = 0;
          
          if (purpose === 'attack') {
            // ÏïÑÍµ∞ Î∞©Ìñ•(ÏïÑÎûòÏ™Ω)ÏúºÎ°ú Í∞àÏàòÎ°ù ÎÜíÏùÄ Ï†êÏàò
            score = ny - unit.y;
            
            // ÏïÑÍµ∞ Ïú†Îãõ Í∑ºÏ≤òÎ©¥ Î≥¥ÎÑàÏä§
            const nearbyPlayerUnits = gameState.units.filter(u => 
              u.owner === 'player' && 
              Math.abs(u.x - nx) <= 3 && Math.abs(u.y - ny) <= 3
            );
            score += nearbyPlayerUnits.length * 2;
          }
          
          if (score > bestScore) {
            bestScore = score;
            bestTarget = { x: nx, y: ny };
          }
        }
      }
      
      return bestTarget;
    }
    
    // Ï†Å Ïú†Îãõ Ïù¥Îèô Ïã§Ìñâ
    async function moveEnemyUnit(unit, target) {
      const unitDef = UNITS[unit.type];
      const oldX = unit.x;
      const oldY = unit.y;
      
      unit.x = target.x;
      unit.y = target.y;
      unit.moved = true;
      
      addLog(`ü§ñ Ï†Å ${unitDef.name}Ïù¥(Í∞Ä) (${oldX},${oldY})‚Üí(${target.x},${target.y}) Ïù¥Îèô`, 'enemy');
      
      // ÌÉ±ÌÅ¨/Ï∞®ÎüâÏù¥Î©¥ ÏßÄÎ¢∞ Ï≤¥ÌÅ¨
      if (unitDef.isTank || unitDef.isVehicle) {
        checkMineOnPath(unit, oldX, oldY, target.x, target.y);
      }
      
      renderMap();
      await delay(150);
    }
    
    // AI Í≥µÍ≤© (ÌÑ¥Îãπ Ï†úÌïú)
    async function aiAttack() {
      const config = AI_CONFIG[aiState.type];
      const maxAttacks = config.isHardMode ? 5 : 1;  // ÌïòÎìúÎ™®Îìú 5Ìöå, ÏùºÎ∞ò 1Ìöå
      let attackCount = 0;
      
      const attackableUnits = gameState.units.filter(u => 
        u.owner === 'enemy' && !u.moved && 
        (UNITS[u.type].damagePercent > 0 || UNITS[u.type].attack > 0) &&
        !UNITS[u.type].isAirUnit  // Í≥µÏ§ë Ïú†ÎãõÏùÄ ÏùºÎ∞ò Í≥µÍ≤© Î∂àÍ∞Ä
      );
      
      for (const unit of attackableUnits) {
        if (attackCount >= maxAttacks) break;
        
        const unitDef = UNITS[unit.type];
        const attackRange = unitDef.attackRange || 1;
        
        // Í≥µÍ≤© ÎåÄÏÉÅ Ï∞æÍ∏∞
        let target = null;
        
        // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÏïÑÍµ∞ Ïú†Îãõ Ï∞æÍ∏∞ (ÏßÄÏÉÅ Ïú†ÎãõÎßå - Í≥µÏ§ë Ïú†Îãõ Ï†úÏô∏!)
        for (const playerUnit of gameState.units) {
          if (playerUnit.owner !== 'player') continue;
          
          // ÏßÄÏÉÅ Ïú†ÎãõÏùÄ Í≥µÏ§ë Ïú†ÎãõÏùÑ Í≥µÍ≤©Ìï† Ïàò ÏóÜÏùå
          const playerUnitDef = UNITS[playerUnit.type];
          if (playerUnitDef.isAirUnit) continue;
          
          const distance = Math.abs(playerUnit.x - unit.x) + Math.abs(playerUnit.y - unit.y);
          if (distance <= attackRange) {
            target = { type: 'unit', unit: playerUnit };
            break;
          }
        }
        
        // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÏïÑÍµ∞ Í±¥Î¨º Ï∞æÍ∏∞
        if (!target) {
          for (const building of gameState.buildings) {
            if (building.owner !== 'player') continue;
            const distance = Math.abs(building.x - unit.x) + Math.abs(building.y - unit.y);
            if (distance <= attackRange) {
              target = { type: 'building', building: building };
              break;
            }
          }
        }
        
        // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÏïÑÍµ∞ Í∏∞ÏßÄ Ï∞æÍ∏∞
        if (!target) {
          for (let dy = -attackRange; dy <= attackRange; dy++) {
            for (let dx = -attackRange; dx <= attackRange; dx++) {
              const distance = Math.abs(dx) + Math.abs(dy);
              if (distance > attackRange) continue;
              
              const nx = unit.x + dx;
              const ny = unit.y + dy;
              
              if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
              
              const tile = gameState.map[ny][nx];
              if ((tile.type === 'main_base' || tile.type === 'sub_base') && tile.owner === 'player') {
                target = { type: 'base', tile: tile, x: nx, y: ny };
                break;
              }
            }
            if (target) break;
          }
        }
        
        if (target) {
          await executeEnemyAttack(unit, target);
          attackCount++;
          await delay(100);
        }
      }
    }
    
    // Ï†Å Í≥µÍ≤© Ïã§Ìñâ
    async function executeEnemyAttack(attacker, target) {
      const attackerDef = UNITS[attacker.type];
      attacker.moved = true;
      
      if (target.type === 'unit') {
        const defender = target.unit;
        const defenderDef = UNITS[defender.type];
        
        const attackerIsTank = attackerDef.isTank;
        const defenderIsTank = defenderDef.isTank;
        
        // === Ï†Å ÌÉ±ÌÅ¨Í∞Ä ÏïÑÍµ∞ Ïú†Îãõ Í≥µÍ≤© ===
        if (attackerIsTank) {
          const tankDamage = attackerDef.tankDamage * attacker.count;
          
          if (defenderIsTank) {
            // ÌÉ±ÌÅ¨ vs ÌÉ±ÌÅ¨
            const destroyedTanks = Math.floor(tankDamage / defenderDef.tankHp);
            defender.count -= destroyedTanks;
            
            if (defender.count <= 0) {
              const index = gameState.units.findIndex(u => u.id === defender.id);
              if (index > -1) gameState.units.splice(index, 1);
              addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏! (${destroyedTanks}ÎåÄ ÌååÍ¥¥)`, 'enemy');
            } else {
              addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}Ïóê ${destroyedTanks}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${defender.count}ÎåÄ)`, 'enemy');
              
              // Î∞òÍ≤©
              const counterDamage = defenderDef.tankDamage * defender.count;
              const counterDestroyed = Math.floor(counterDamage / attackerDef.tankHp);
              attacker.count -= counterDestroyed;
              
              if (attacker.count <= 0) {
                const index = gameState.units.findIndex(u => u.id === attacker.id);
                if (index > -1) gameState.units.splice(index, 1);
                addLog(`‚öîÔ∏è ÏïÑÍµ∞ ${defenderDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú Ï†Å ${attackerDef.name} Ï†ÑÎ©∏!`, 'action');
              }
            }
          } else {
            // ÌÉ±ÌÅ¨ ‚Üí ÏùºÎ∞ò Ïú†Îãõ
            defender.count -= tankDamage;
            
            if (defender.count <= 0) {
              const index = gameState.units.findIndex(u => u.id === defender.id);
              if (index > -1) gameState.units.splice(index, 1);
              addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏! (${tankDamage.toLocaleString()}Î™Ö ÌîºÌï¥)`, 'enemy');
            } else {
              addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}Ïóê ${tankDamage.toLocaleString()}Î™Ö ÌîºÌï¥!`, 'enemy');
              
              // ÏùºÎ∞ò Ïú†Îãõ Î∞òÍ≤© ‚Üí ÌÉ±ÌÅ¨
              const counterDamagePercent = defenderDef.damagePercent || 10;
              const counterDamage = Math.floor(defender.count * counterDamagePercent / 100);
              const counterDestroyed = Math.floor(counterDamage / attackerDef.tankHp);
              
              if (counterDestroyed > 0) {
                attacker.count -= counterDestroyed;
                if (attacker.count <= 0) {
                  const index = gameState.units.findIndex(u => u.id === attacker.id);
                  if (index > -1) gameState.units.splice(index, 1);
                  addLog(`‚öîÔ∏è ÏïÑÍµ∞ ${defenderDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú Ï†Å ${attackerDef.name} Ï†ÑÎ©∏!`, 'action');
                }
              }
            }
          }
        }
        // === Ï†Å ÏùºÎ∞ò Ïú†ÎãõÏù¥ ÏïÑÍµ∞ ÌÉ±ÌÅ¨ Í≥µÍ≤© ===
        else if (defenderIsTank) {
          const damagePercent = attackerDef.damagePercent || 10;
          const damage = Math.floor(attacker.count * damagePercent / 100);
          const destroyedTanks = Math.floor(damage / defenderDef.tankHp);
          
          defender.count -= destroyedTanks;
          
          if (defender.count <= 0) {
            const index = gameState.units.findIndex(u => u.id === defender.id);
            if (index > -1) gameState.units.splice(index, 1);
            addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏! (${destroyedTanks}ÎåÄ ÌååÍ¥¥)`, 'enemy');
          } else {
            if (destroyedTanks > 0) {
              addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}Ïóê ${destroyedTanks}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${defender.count}ÎåÄ)`, 'enemy');
            } else {
              addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}ÏùÑ(Î•º) Í≥µÍ≤©ÌñàÏßÄÎßå ÌîºÌï¥ ÏóÜÏùå!`, 'enemy');
            }
            
            // ÌÉ±ÌÅ¨ Î∞òÍ≤© ‚Üí ÏùºÎ∞ò Ïú†Îãõ
            const counterDamage = defenderDef.tankDamage * defender.count;
            attacker.count -= counterDamage;
            
            if (attacker.count <= 0) {
              const index = gameState.units.findIndex(u => u.id === attacker.id);
              if (index > -1) gameState.units.splice(index, 1);
              addLog(`‚öîÔ∏è ÏïÑÍµ∞ ${defenderDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú Ï†Å ${attackerDef.name} Ï†ÑÎ©∏!`, 'action');
            } else {
              addLog(`‚öîÔ∏è ÏïÑÍµ∞ ${defenderDef.name}Ïùò Î∞òÍ≤©! ${counterDamage.toLocaleString()}Î™Ö ÌîºÌï¥!`, 'action');
            }
          }
        }
        // === ÏùºÎ∞ò Ïú†Îãõ vs ÏùºÎ∞ò Ïú†Îãõ (Í∏∞Ï°¥ Î°úÏßÅ) ===
        else {
          const damagePercent = attackerDef.damagePercent || 10;
          const damage = Math.floor(attacker.count * damagePercent / 100);
          
          defender.count -= damage;
          
          if (defender.count <= 0) {
            const index = gameState.units.findIndex(u => u.id === defender.id);
            if (index > -1) gameState.units.splice(index, 1);
            addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§!`, 'enemy');
          } else {
            addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ${defenderDef.name}ÏóêÍ≤å ${damage}Î™Ö ÌîºÌï¥!`, 'enemy');
          }
          
          // Î∞òÍ≤©
          if (defender.count > 0) {
            const counterDamagePercent = defenderDef.damagePercent || 10;
            const counterDamage = Math.floor(defender.count * counterDamagePercent / 100);
            attacker.count -= counterDamage;
            
            if (attacker.count <= 0) {
              const index = gameState.units.findIndex(u => u.id === attacker.id);
              if (index > -1) gameState.units.splice(index, 1);
              addLog(`‚öîÔ∏è ÏïÑÍµ∞ ${defenderDef.name}Ïùò Î∞òÍ≤©ÏúºÎ°ú Ï†Å ${attackerDef.name} Ï†ÑÎ©∏!`, 'action');
            }
          }
        }
      }
      else if (target.type === 'base') {
        // ÌÉ±ÌÅ¨Ïùò Í∏∞ÏßÄ Í≥µÍ≤©ÏùÄ 5Î∞∞ ÌîºÌï¥
        let damage;
        if (attackerDef.isTank) {
          damage = attackerDef.tankDamage * attacker.count * attackerDef.structureMultiplier;
        } else {
          damage = attacker.count * (attackerDef.damagePercent || 10);
        }
        
        if (target.tile.type === 'main_base') {
          gameState.bases.player.main -= damage;
          addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄÏóê ${damage.toLocaleString()} ÌîºÌï¥! (HP: ${Math.max(0, gameState.bases.player.main).toLocaleString()})`, 'enemy');
          
          if (gameState.bases.player.main <= 0) {
            gameState.bases.player.main = 0;
            setTimeout(() => {
              alert('Ìå®Î∞∞! Î≥∏Í∏∞ÏßÄÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§.');
              showScreen('lobby');
            }, 500);
          }
        } else {
          const island = getIslandAt(target.x, target.y);
          const subKey = (island === 'enemy_right' || island === 'player_left') ? 'sub2' : 'sub1';
          gameState.bases.player[subKey] -= damage;
          addLog(`ü§ñ Ï†Å ${attackerDef.name}Ïù¥(Í∞Ä) ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄÏóê ${damage.toLocaleString()} ÌîºÌï¥!`, 'enemy');
          
          if (gameState.bases.player[subKey] <= 0) {
            gameState.bases.player[subKey] = 0;
            target.tile.type = 'empty';
            addLog(`üí• ÏïÑÍµ∞ Î∂ÄÍ∏∞ÏßÄÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§!`, 'system');
          }
        }
      }
      
      renderMap();
      await delay(200);
    }
    
    // AI Ìï¥Íµ∞ Ïö¥Ïö© (Í∞ÑÏÜåÌôî)
    async function aiNavalOperations() {
      // Ï†Å Ìï≠Íµ¨ ÌôïÏù∏
      let enemyHarbor = null;
      gameState.map.forEach((row, y) => {
        row.forEach((tile, x) => {
          if (tile.type === 'harbor' && tile.owner === 'enemy' && tile.harborHp > 0) {
            enemyHarbor = { x, y, tile };
          }
        });
      });
      
      if (!enemyHarbor) return;
      
      // Ï†ÑÌï® ÎòêÎäî ÏàòÏÜ°Ìï® ÏÉùÏÇ∞
      const shipTypes = ['attack_ship', 'transport_ship', 'missile_cruiser'];
      const shipType = shipTypes[Math.floor(Math.random() * shipTypes.length)];
      
      if (gameState.resources.enemy >= UNITS[shipType].cost && Math.random() < 0.4) {
        const seaPositions = [];
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue;
            const nx = enemyHarbor.x + dx;
            const ny = enemyHarbor.y + dy;
            if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
              const tile = gameState.map[ny][nx];
              if (tile.terrain === 'sea' && !getUnitAt(nx, ny)) {
                seaPositions.push({ x: nx, y: ny });
              }
            }
          }
        }
        
        if (seaPositions.length > 0) {
          const spawnPos = seaPositions[0];
          gameState.resources.enemy -= UNITS[shipType].cost;
          gameState.units.push({
            id: Date.now() + Math.random(),
            type: shipType,
            x: spawnPos.x,
            y: spawnPos.y,
            owner: 'enemy',
            hp: UNITS[shipType].hp,
            count: 1,
            moved: true,
            cargo: shipType === 'transport_ship' ? [] : undefined
          });
          
          addLog(`ü§ñ Ï†ÅÏù¥ ${UNITS[shipType].name}ÏùÑ(Î•º) ÏÉùÏÇ∞ÌñàÏäµÎãàÎã§!`, 'enemy');
          renderMap();
        }
      }
    }
    
    // AI Íµ∞ÏÇ¨ Í±¥Î¨º Í±¥ÏÑ§
    async function aiBuildMilitaryStructures() {
      // Íµ∞ÏÇ¨ Í±¥Ï∂ïÍ∞Ä Ï∞æÍ∏∞
      const militaryEngineers = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'military_engineer' && !u.moved
      );
      
      if (militaryEngineers.length === 0) return false;
      
      for (const engineer of militaryEngineers) {
        // Ïù∏Ï†ë Îπà ÌÉÄÏùº Ï∞æÍ∏∞
        const directions = [
          {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
          {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
        ];
        
        for (const dir of directions) {
          const nx = engineer.x + dir.x;
          const ny = engineer.y + dir.y;
          
          if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
          if (ny > ENEMY_ZONE_END) continue;  // Ï†Å ÏòÅÏó≠Îßå
          
          const tile = gameState.map[ny][nx];
          if (tile.terrain !== 'land') continue;
          if (getBuildingAt(nx, ny)) continue;
          if (getGroundUnitAt(nx, ny)) continue;
          if (tile.type !== 'empty') continue;
          
          // Í±¥ÏÑ§Ìï† Í±¥Î¨º Í≤∞Ï†ï (Ïö∞ÏÑ†ÏàúÏúÑ: Íµ∞ÏàòÍ≥µÏû• > ÎØ∏ÏÇ¨ÏùºÎ∞úÏÇ¨ÎåÄ > Î∞ïÍ≤©Ìè¨)
          const hasFactory = gameState.buildings.some(b => 
            b.owner === 'enemy' && b.type === 'arms_factory'
          );
          const hasSilo = gameState.buildings.some(b => 
            b.owner === 'enemy' && b.type === 'missile_silo'
          );
          const hasMortar = gameState.buildings.some(b => 
            b.owner === 'enemy' && b.type === 'mortar'
          );
          
          let buildingType = null;
          let cost = 0;
          
          if (!hasFactory && gameState.resources.enemy >= BUILDINGS.arms_factory.cost) {
            buildingType = 'arms_factory';
            cost = BUILDINGS.arms_factory.cost;
          } else if (hasFactory && !hasSilo && gameState.resources.enemy >= BUILDINGS.missile_silo.cost) {
            buildingType = 'missile_silo';
            cost = BUILDINGS.missile_silo.cost;
          } else if (!hasMortar && gameState.resources.enemy >= BUILDINGS.mortar.cost) {
            buildingType = 'mortar';
            cost = BUILDINGS.mortar.cost;
          } else if (gameState.resources.enemy >= BUILDINGS.runway.cost && Math.random() < 0.3) {
            const hasRunway = gameState.buildings.some(b => 
              b.owner === 'enemy' && b.type === 'runway'
            );
            if (!hasRunway) {
              buildingType = 'runway';
              cost = BUILDINGS.runway.cost;
            }
          }
          
          if (buildingType && gameState.resources.enemy >= cost) {
            gameState.resources.enemy -= cost;
            gameState.buildings.push({
              type: buildingType,
              x: nx,
              y: ny,
              owner: 'enemy',
              hp: BUILDINGS[buildingType].hp,
              level: 1,
              fired: false,
              produced: false
            });
            
            engineer.moved = true;
            addLog(`ü§ñ Ï†ÅÏù¥ ${BUILDINGS[buildingType].name}ÏùÑ(Î•º) Í±¥ÏÑ§ÌñàÏäµÎãàÎã§!`, 'enemy');
            renderMap();
            return true;
          }
        }
      }
      
      return false;
    }
    
    // AI ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞
    async function aiProduceMissiles() {
      const factories = gameState.buildings.filter(b => 
        b.owner === 'enemy' && b.type === 'arms_factory' && !b.produced
      );
      
      if (factories.length === 0) return;
      
      for (const factory of factories) {
        if (gameState.resources.enemy >= MISSILE_COST) {
          const buildTurns = getFactoryBuildTurns(factory);
          gameState.resources.enemy -= MISSILE_COST;
          gameState.missileQueue.enemy.push({ turnsLeft: buildTurns });
          factory.produced = true;
          
          addLog(`ü§ñ Ï†ÅÏù¥ ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ÏùÑ ÏãúÏûëÌñàÏäµÎãàÎã§! (${buildTurns}ÌÑ¥ ÏÜåÏöî)`, 'enemy');
        }
      }
    }
    
    // AI ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨
    async function aiLaunchMissile() {
      if (gameState.missiles.enemy <= 0) return;
      
      const config = AI_CONFIG[aiState.type];
      const maxLaunches = config.isHardMode ? 5 : 1;  // ÌïòÎìúÎ™®Îìú 5Î∞ú, ÏùºÎ∞ò 1Î∞ú
      let launchCount = 0;
      
      const silos = gameState.buildings.filter(b => 
        b.owner === 'enemy' && b.type === 'missile_silo' && !b.fired
      );
      
      if (silos.length === 0) return;
      
      for (const silo of silos) {
        if (gameState.missiles.enemy <= 0) break;
        if (launchCount >= maxLaunches) break;
        
        const siloRange = getBuildingRange(silo);
        const launchCost = BUILDINGS.missile_silo.launchCost;
        
        if (gameState.resources.enemy < launchCost) continue;
        
        // ÌÉÄÍ≤ü Ï∞æÍ∏∞
        let target = null;
        let bestScore = -1;
        
        // ÌîåÎ†àÏù¥Ïñ¥ Í∏∞ÏßÄÎì§ ÌôïÏù∏
        gameState.map.forEach((row, y) => {
          row.forEach((tile, x) => {
            if (tile.owner !== 'player') return;
            
            const distance = Math.abs(x - silo.x) + Math.abs(y - silo.y);
            if (distance > siloRange) return;
            
            let score = 0;
            if (tile.type === 'main_base') {
              score = 1000;  // Î≥∏Í∏∞ÏßÄ ÏµúÏö∞ÏÑ†
            } else if (tile.type === 'sub_base') {
              score = 500;   // Î∂ÄÍ∏∞ÏßÄ
            }
            
            if (score > bestScore) {
              bestScore = score;
              if (tile.type === 'main_base') {
                target = { type: 'base', x, y, key: 'main' };
              } else {
                const island = getIslandAt(x, y);
                const subKey = (island === 'player_left') ? 'sub2' : 'sub1';
                target = { type: 'base', x, y, key: subKey };
              }
            }
          });
        });
        
        // Í±¥Î¨ºÎèÑ ÌÉÄÍ≤üÏúºÎ°ú
        if (!target) {
          for (const building of gameState.buildings) {
            if (building.owner !== 'player') continue;
            const distance = Math.abs(building.x - silo.x) + Math.abs(building.y - silo.y);
            if (distance <= siloRange) {
              target = { type: 'building', building: building, x: building.x, y: building.y };
              break;
            }
          }
        }
        
        // Ïú†ÎãõÎèÑ ÌÉÄÍ≤üÏúºÎ°ú (100Î™Ö Ïù¥ÏÉÅ)
        if (!target) {
          const targetUnits = gameState.units.filter(u => 
            u.owner === 'player' && u.count >= 100 && !UNITS[u.type].isAirUnit &&
            Math.abs(u.x - silo.x) + Math.abs(u.y - silo.y) <= siloRange
          );
          if (targetUnits.length > 0) {
            // Í∞ÄÏû• Î≥ëÎ†•Ïù¥ ÎßéÏùÄ Ïú†Îãõ
            targetUnits.sort((a, b) => b.count - a.count);
            const u = targetUnits[0];
            target = { type: 'unit', x: u.x, y: u.y, unit: u };
          }
        }
        
        if (target) {
          gameState.resources.enemy -= launchCost;
          gameState.missiles.enemy--;
          silo.fired = true;
          
          const damage = BUILDINGS.missile_silo.damage;
          
          if (target.type === 'base') {
            gameState.bases.player[target.key] -= damage;
            if (gameState.bases.player[target.key] < 0) {
              gameState.bases.player[target.key] = 0;
            }
            const baseName = target.key === 'main' ? 'Î≥∏Í∏∞ÏßÄ' : 'Î∂ÄÍ∏∞ÏßÄ';
            addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ ${baseName}Ïóê Î™ÖÏ§ë! ${damage.toLocaleString()} ÌîºÌï¥!`, 'enemy');
            
            if (target.key === 'main' && gameState.bases.player.main <= 0) {
              setTimeout(() => {
                alert('Ìå®Î∞∞! Î≥∏Í∏∞ÏßÄÍ∞Ä ÌååÍ¥¥ÎêòÏóàÏäµÎãàÎã§.');
                showScreen('lobby');
              }, 500);
              return;
            }
          } else if (target.type === 'building') {
            target.building.hp -= damage;
            const buildingDef = BUILDINGS[target.building.type];
            if (target.building.hp <= 0) {
              const idx = gameState.buildings.findIndex(b => b.x === target.x && b.y === target.y);
              if (idx > -1) gameState.buildings.splice(idx, 1);
              addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ ${buildingDef.name}ÏùÑ(Î•º) ÌååÍ¥¥ÌñàÏäµÎãàÎã§!`, 'enemy');
            } else {
              addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ ${buildingDef.name}Ïóê ${damage.toLocaleString()} ÌîºÌï¥!`, 'enemy');
            }
          } else if (target.type === 'unit') {
            const targetDef = UNITS[target.unit.type];
            
            // ÌÉ±ÌÅ¨/Ï∞®ÎüâÏùÄ ÎåÄÏàò Í∏∞Î∞ò, ÏùºÎ∞ò Ïú†ÎãõÏùÄ Î™ÖÏàò Í∏∞Î∞ò
            if (targetDef.isTank || targetDef.isVehicle) {
              const tankHp = targetDef.tankHp || 1000;
              const destroyedCount = Math.floor(damage / tankHp);
              target.unit.count -= destroyedCount;
              
              if (target.unit.count <= 0) {
                const idx = gameState.units.findIndex(u => u.id === target.unit.id);
                if (idx > -1) gameState.units.splice(idx, 1);
                addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ ${targetDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§! (${destroyedCount}ÎåÄ ÌååÍ¥¥)`, 'enemy');
              } else {
                addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ ${targetDef.name} ${destroyedCount}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${target.unit.count}ÎåÄ)`, 'enemy');
              }
            } else {
              const unitDamage = Math.floor(damage / 10);
              target.unit.count -= unitDamage;
              if (target.unit.count <= 0) {
                const idx = gameState.units.findIndex(u => u.id === target.unit.id);
                if (idx > -1) gameState.units.splice(idx, 1);
                addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ Ïú†ÎãõÏùÑ Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§!`, 'enemy');
              } else {
                addLog(`üöÄüí• Ï†Å ÎØ∏ÏÇ¨ÏùºÏù¥ ÏïÑÍµ∞ Ïú†ÎãõÏóê ${unitDamage.toLocaleString()}Î™Ö ÌîºÌï¥!`, 'enemy');
              }
            }
          }
          
          renderMap();
          launchCount++;
          await delay(300);
        }
      }
    }
    
    // AI Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨
    async function aiFireMortars() {
      const mortars = gameState.buildings.filter(b => 
        b.owner === 'enemy' && b.type === 'mortar' && !b.fired
      );
      
      for (const mortar of mortars) {
        const mortarRange = getBuildingRange(mortar);
        const fireCost = BUILDINGS.mortar.fireCost;
        
        if (gameState.resources.enemy < fireCost) continue;
        
        // ÏÇ¨Í±∞Î¶¨ ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥ Ïú†Îãõ Ï∞æÍ∏∞
        const targetUnits = gameState.units.filter(u => 
          u.owner === 'player' && !UNITS[u.type].isAirUnit &&
          Math.abs(u.x - mortar.x) + Math.abs(u.y - mortar.y) <= mortarRange
        );
        
        if (targetUnits.length > 0) {
          // Í∞ÄÏû• Î≥ëÎ†•Ïù¥ ÎßéÏùÄ Ïú†Îãõ Í≥µÍ≤©
          targetUnits.sort((a, b) => b.count - a.count);
          const target = targetUnits[0];
          const targetDef = UNITS[target.type];
          
          gameState.resources.enemy -= fireCost;
          mortar.fired = true;
          
          const damage = BUILDINGS.mortar.damage;
          
          // ÌÉ±ÌÅ¨/Ï∞®ÎüâÏùÄ ÎåÄÏàò Í∏∞Î∞ò, ÏùºÎ∞ò Ïú†ÎãõÏùÄ HP Í∏∞Î∞ò
          if (targetDef.isTank || targetDef.isVehicle) {
            const tankHp = targetDef.tankHp || 1000;
            const destroyedCount = Math.floor(damage / tankHp);
            target.count -= destroyedCount;
            
            if (target.count <= 0) {
              const idx = gameState.units.findIndex(u => u.id === target.id);
              if (idx > -1) gameState.units.splice(idx, 1);
              addLog(`ü§ñ Ï†Å Î∞ïÍ≤©Ìè¨Í∞Ä ÏïÑÍµ∞ ${targetDef.name}ÏùÑ(Î•º) Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§!`, 'enemy');
            } else {
              addLog(`ü§ñ Ï†Å Î∞ïÍ≤©Ìè¨Í∞Ä ÏïÑÍµ∞ ${targetDef.name} ${destroyedCount}ÎåÄ ÌååÍ¥¥! (ÎÇ®ÏùÄ: ${target.count}ÎåÄ)`, 'enemy');
            }
          } else {
            const unitDamage = Math.floor(damage / 10);
            target.count -= unitDamage;
            
            if (target.count <= 0) {
              const idx = gameState.units.findIndex(u => u.id === target.id);
              if (idx > -1) gameState.units.splice(idx, 1);
              addLog(`ü§ñ Ï†Å Î∞ïÍ≤©Ìè¨Í∞Ä ÏïÑÍµ∞ Ïú†ÎãõÏùÑ Ï†ÑÎ©∏ÏãúÏº∞ÏäµÎãàÎã§!`, 'enemy');
            } else {
              addLog(`ü§ñ Ï†Å Î∞ïÍ≤©Ìè¨Í∞Ä ÏïÑÍµ∞ Ïú†ÎãõÏóê ${unitDamage.toLocaleString()}Î™Ö ÌîºÌï¥!`, 'enemy');
            }
          }
          
          renderMap();
        }
      }
    }
    
    // AI ÏàòÏÜ°Ìï® ÏÉÅÎ•ô ÏûëÏ†Ñ
    async function aiTransportOperations() {
      // ÏàòÏÜ°Ìï® Ï∞æÍ∏∞
      const transports = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'transport_ship' && !u.moved
      );
      
      for (const transport of transports) {
        // ÌÉëÏäπ Ïú†ÎãõÏù¥ ÏûàÏúºÎ©¥ ÌîåÎ†àÏù¥Ïñ¥ ÏòÅÏó≠ÏúºÎ°ú Ïù¥Îèô ÌõÑ ÏÉÅÎ•ô!
        if (transport.cargo && transport.cargo.length > 0) {
          // ÌîåÎ†àÏù¥Ïñ¥ ÏòÅÏó≠ Ìï¥Ïïà Ï∞æÍ∏∞ (ÎÑìÏùÄ Î≤îÏúÑ)
          const landingSpots = [];
          for (let y = PLAYER_ZONE_START; y < MAP_HEIGHT; y++) {
            for (let x = 0; x < MAP_WIDTH; x++) {
              const tile = gameState.map[y][x];
              if (tile.terrain === 'land') {
                // Î∞îÎã§ÏôÄ Ïù∏Ï†ëÌïúÏßÄ ÌôïÏù∏
                const adjacentSea = [{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}].some(d => {
                  const nx = x + d.x, ny = y + d.y;
                  if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) return false;
                  return gameState.map[ny][nx].terrain === 'sea';
                });
                if (adjacentSea && !getGroundUnitAt(x, y)) {
                  const dist = Math.abs(x - transport.x) + Math.abs(y - transport.y);
                  landingSpots.push({ x, y, dist });
                }
              }
            }
          }
          
          if (landingSpots.length > 0) {
            landingSpots.sort((a, b) => a.dist - b.dist);
            const spot = landingSpots[0];
            
            // Î™©Ìëú Ìï¥Ïïà Ïù∏Ï†ë Î∞îÎã§ Ï∞æÍ∏∞
            let targetSea = null;
            for (const d of [{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}]) {
              const nx = spot.x + d.x, ny = spot.y + d.y;
              if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
                if (gameState.map[ny][nx].terrain === 'sea') {
                  targetSea = { x: nx, y: ny };
                  break;
                }
              }
            }
            
            if (targetSea) {
              const distToTarget = Math.abs(transport.x - targetSea.x) + Math.abs(transport.y - targetSea.y);
              
              // Î™©ÌëúÏóê ÎèÑÏ∞©ÌñàÍ±∞ÎÇò Í∞ÄÍπåÏö∞Î©¥ ÏÉÅÎ•ô!
              if (distToTarget <= 1) {
                // ÏàòÏÜ°Ìï®ÏùÑ Î™©Ìëú Î∞îÎã§Î°ú Ïù¥Îèô
                if (!getUnitAt(targetSea.x, targetSea.y)) {
                  transport.x = targetSea.x;
                  transport.y = targetSea.y;
                }
                
                // ÏÉÅÎ•ô!
                for (const cargo of transport.cargo) {
                  // Îπà ÏÉÅÎ•ô ÏßÄÏ†ê Ï∞æÍ∏∞
                  let landSpot = spot;
                  if (getGroundUnitAt(spot.x, spot.y)) {
                    for (const d of [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}]) {
                      const nx = spot.x + d.x, ny = spot.y + d.y;
                      if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
                        const tile = gameState.map[ny][nx];
                        if (tile.terrain === 'land' && !getGroundUnitAt(nx, ny)) {
                          landSpot = { x: nx, y: ny };
                          break;
                        }
                      }
                    }
                  }
                  
                  gameState.units.push({
                    id: Date.now() + Math.random(),
                    type: cargo.type,
                    x: landSpot.x,
                    y: landSpot.y,
                    owner: 'enemy',
                    count: cargo.count,
                    moved: false  // ÏÉÅÎ•ô ÌõÑ Î∞îÎ°ú ÌñâÎèô Í∞ÄÎä•!
                  });
                  addLog(`‚ö†Ô∏èüö¢ Ï†Å ${UNITS[cargo.type].name} ${cargo.count.toLocaleString()}Î™ÖÏù¥ ÏïÑÍµ∞ ÏòÅÏó≠Ïóê ÏÉÅÎ•ô!`, 'enemy');
                }
                transport.cargo = [];
                transport.moved = true;
                renderMap();
                await delay(200);
              } else {
                // Î™©ÌëúÎ°ú Ïù¥Îèô
                const moveRange = UNITS.transport_ship.moveRange;
                let bestMove = null;
                let bestDist = Infinity;
                
                for (let dy = -moveRange; dy <= moveRange; dy++) {
                  for (let dx = -moveRange; dx <= moveRange; dx++) {
                    const dist = Math.abs(dx) + Math.abs(dy);
                    if (dist === 0 || dist > moveRange) continue;
                    
                    const nx = transport.x + dx;
                    const ny = transport.y + dy;
                    
                    if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
                    if (gameState.map[ny][nx].terrain !== 'sea') continue;
                    if (getUnitAt(nx, ny)) continue;
                    
                    const newDist = Math.abs(nx - targetSea.x) + Math.abs(ny - targetSea.y);
                    if (newDist < bestDist) {
                      bestDist = newDist;
                      bestMove = { x: nx, y: ny };
                    }
                  }
                }
                
                if (bestMove) {
                  transport.x = bestMove.x;
                  transport.y = bestMove.y;
                  transport.moved = true;
                  addLog(`üö¢ Ï†Å ÏàòÏÜ°Ìï®Ïù¥ ÏïÑÍµ∞ Ìï¥ÏïàÏúºÎ°ú Ï†ëÍ∑º Ï§ë...`, 'enemy');
                  renderMap();
                  await delay(100);
                }
              }
            }
          }
        }
      }
    }
    
    // ==================== AI Í∞ïÌôî Ìï®ÏàòÎì§ ====================
    
    // AI ÎèÑÏãú Í±¥ÏÑ§
    async function aiBuildCity() {
      const engineers = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'engineer' && !u.moved
      );
      
      if (engineers.length === 0) return false;
      if (gameState.resources.enemy < BUILDINGS.city.cost) return false;
      
      for (const engineer of engineers) {
        const directions = [
          {x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0},
          {x: 1, y: 1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: -1, y: -1}
        ];
        
        for (const dir of directions) {
          const nx = engineer.x + dir.x;
          const ny = engineer.y + dir.y;
          
          if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
          if (ny > ENEMY_ZONE_END) continue;
          
          const tile = gameState.map[ny][nx];
          if (tile.terrain !== 'land') continue;
          if (getBuildingAt(nx, ny)) continue;
          if (getGroundUnitAt(nx, ny)) continue;
          if (tile.type !== 'empty') continue;
          
          gameState.resources.enemy -= BUILDINGS.city.cost;
          gameState.buildings.push({
            type: 'city',
            x: nx,
            y: ny,
            owner: 'enemy',
            hp: BUILDINGS.city.hp,
            level: 1
          });
          
          engineer.moved = true;
          addLog(`ü§ñ Ï†ÅÏù¥ ÎèÑÏãúÎ•º Í±¥ÏÑ§ÌñàÏäµÎãàÎã§! (ÌÑ¥Îãπ +${BUILDINGS.city.levelStats[1].income.toLocaleString()}Ïõê)`, 'enemy');
          renderMap();
          return true;
        }
      }
      return false;
    }
    
    // AI ÎèÑÏãú ÏóÖÍ∑∏Î†àÏù¥Îìú
    async function aiUpgradeCity() {
      const cities = gameState.buildings.filter(b => 
        b.owner === 'enemy' && b.type === 'city' && (b.level || 1) < BUILDINGS.city.maxLevel
      );
      
      if (cities.length === 0) return false;
      
      for (const city of cities) {
        const currentLevel = city.level || 1;
        const upgradeCost = getUpgradeCost('city', currentLevel);
        
        if (gameState.resources.enemy >= upgradeCost) {
          gameState.resources.enemy -= upgradeCost;
          city.level = currentLevel + 1;
          
          const newIncome = BUILDINGS.city.levelStats[city.level].income;
          addLog(`ü§ñ Ï†ÅÏù¥ ÎèÑÏãúÎ•º Lv.${city.level}Î°ú ÏóÖÍ∑∏Î†àÏù¥Îìú! (ÌÑ¥Îãπ +${newIncome.toLocaleString()}Ïõê)`, 'enemy');
          renderMap();
          return true;
        }
      }
      return false;
    }
    
    // AI ÌÉ±ÌÅ¨ ÏÉùÏÇ∞
    async function aiProduceTanks() {
      const factories = gameState.buildings.filter(b => 
        b.owner === 'enemy' && b.type === 'arms_factory' && !b.produced
      );
      
      if (factories.length === 0) return;
      
      for (const factory of factories) {
        // ÏûêÏõêÏóê Îî∞Îùº ÌÉ±ÌÅ¨ Îì±Í∏â Í≤∞Ï†ï
        let tankType = null;
        if (gameState.resources.enemy >= UNITS.tank_advanced.cost * 3) {
          tankType = 'tank_advanced';
        } else if (gameState.resources.enemy >= UNITS.tank_medium.cost * 3) {
          tankType = 'tank_medium';
        } else if (gameState.resources.enemy >= UNITS.tank_basic.cost * 3) {
          tankType = 'tank_basic';
        }
        
        if (!tankType) continue;
        
        const tankDef = UNITS[tankType];
        const quantity = Math.min(5, Math.floor(gameState.resources.enemy / tankDef.cost / 2));
        
        if (quantity < 1) continue;
        
        // Ïä§Ìè∞ ÏúÑÏπò Ï∞æÍ∏∞
        const spawnTile = findSpawnTile(factory.x, factory.y);
        if (!spawnTile) continue;
        
        const totalCost = tankDef.cost * quantity;
        gameState.resources.enemy -= totalCost;
        
        gameState.units.push({
          id: Date.now() + Math.random(),
          type: tankType,
          x: spawnTile.x,
          y: spawnTile.y,
          owner: 'enemy',
          count: quantity,
          moved: true
        });
        
        factory.produced = true;
        addLog(`ü§ñ Ï†ÅÏù¥ ${tankDef.name} ${quantity}ÎåÄÎ•º ÏÉùÏÇ∞ÌñàÏäµÎãàÎã§!`, 'enemy');
        renderMap();
      }
    }
    
    // AI ÏàòÏÜ°ÏÑ†Ïóê Ïú†Îãõ ÌÉëÏäπ
    async function aiLoadTransports() {
      const transports = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'transport_ship' && 
        (!u.cargo || u.cargo.length < 2) && !u.moved
      );
      
      if (transports.length === 0) return;
      
      for (const transport of transports) {
        // Ïù∏Ï†ë Ïú†Îãõ Ï∞æÍ∏∞ (ÌÉ±ÌÅ¨ Ïö∞ÏÑ†!)
        const nearbyUnits = gameState.units.filter(u => {
          if (u.owner !== 'enemy' || u.id === transport.id) return false;
          if (UNITS[u.type].isNavalUnit || UNITS[u.type].isAirUnit) return false;
          const dist = Math.abs(u.x - transport.x) + Math.abs(u.y - transport.y);
          return dist <= 2;
        });
        
        // ÌÉ±ÌÅ¨ Ïö∞ÏÑ† Ï†ïÎ†¨
        nearbyUnits.sort((a, b) => {
          const aIsTank = UNITS[a.type].isTank ? 1 : 0;
          const bIsTank = UNITS[b.type].isTank ? 1 : 0;
          return bIsTank - aIsTank;
        });
        
        if (!transport.cargo) transport.cargo = [];
        
        for (const unit of nearbyUnits) {
          if (transport.cargo.length >= 2) break;
          
          // Ïú†ÎãõÏùÑ ÏàòÏÜ°Ìï®Ïóê ÌÉëÏäπ
          transport.cargo.push({
            type: unit.type,
            count: unit.count
          });
          
          // ÏõêÎûò Ïú†Îãõ Ï†úÍ±∞
          const idx = gameState.units.findIndex(u => u.id === unit.id);
          if (idx > -1) gameState.units.splice(idx, 1);
          
          addLog(`üö¢ Ï†Å ${UNITS[unit.type].name}Ïù¥(Í∞Ä) ÏàòÏÜ°Ìï®Ïóê ÌÉëÏäπ!`, 'enemy');
        }
        
        if (transport.cargo.length > 0) {
          renderMap();
        }
      }
    }
    
    // AI ÏàòÏÜ°ÏÑ† ÏÉÅÎ•ô ÏûëÏ†Ñ (Í∞ïÌôî)
    async function aiTransportLanding() {
      const transports = gameState.units.filter(u => 
        u.owner === 'enemy' && u.type === 'transport_ship' && 
        u.cargo && u.cargo.length > 0 && !u.moved
      );
      
      for (const transport of transports) {
        // ÌîåÎ†àÏù¥Ïñ¥ Ìï¥Ïïà Í∑ºÏ≤ò Ï∞æÍ∏∞
        let targetCoast = null;
        let minDist = Infinity;
        
        for (let y = PLAYER_ZONE_START; y < MAP_HEIGHT; y++) {
          for (let x = 0; x < MAP_WIDTH; x++) {
            const tile = gameState.map[y][x];
            if (tile.terrain !== 'land') continue;
            
            // Î∞îÎã§ Ïù∏Ï†ë ÌôïÏù∏
            const hasAdjacentSea = [{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}].some(d => {
              const nx = x + d.x, ny = y + d.y;
              if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) return false;
              return gameState.map[ny][nx].terrain === 'sea';
            });
            
            if (hasAdjacentSea && !getGroundUnitAt(x, y)) {
              const dist = Math.abs(x - transport.x) + Math.abs(y - transport.y);
              if (dist < minDist) {
                minDist = dist;
                targetCoast = { x, y };
              }
            }
          }
        }
        
        if (!targetCoast) continue;
        
        // Î™©Ìëú Ìï¥Ïïà Ïù∏Ï†ë Î∞îÎã§ Ï∞æÍ∏∞
        let targetSea = null;
        for (const d of [{x:-1,y:0},{x:1,y:0},{x:0,y:-1},{x:0,y:1}]) {
          const nx = targetCoast.x + d.x, ny = targetCoast.y + d.y;
          if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
            if (gameState.map[ny][nx].terrain === 'sea' && !getUnitAt(nx, ny)) {
              targetSea = { x: nx, y: ny };
              break;
            }
          }
        }
        
        if (!targetSea) continue;
        
        const distToTarget = Math.abs(transport.x - targetSea.x) + Math.abs(transport.y - targetSea.y);
        
        // ÎèÑÏ∞©ÌñàÏúºÎ©¥ ÏÉÅÎ•ô!
        if (distToTarget <= UNITS.transport_ship.moveRange) {
          transport.x = targetSea.x;
          transport.y = targetSea.y;
          
          // ÏÉÅÎ•ô!
          for (const cargo of transport.cargo) {
            let landSpot = targetCoast;
            if (getGroundUnitAt(targetCoast.x, targetCoast.y)) {
              for (const d of [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},{x:1,y:1},{x:-1,y:1}]) {
                const nx = targetCoast.x + d.x, ny = targetCoast.y + d.y;
                if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
                  const tile = gameState.map[ny][nx];
                  if (tile.terrain === 'land' && !getGroundUnitAt(nx, ny)) {
                    landSpot = { x: nx, y: ny };
                    break;
                  }
                }
              }
            }
            
            gameState.units.push({
              id: Date.now() + Math.random(),
              type: cargo.type,
              x: landSpot.x,
              y: landSpot.y,
              owner: 'enemy',
              count: cargo.count,
              moved: false
            });
            
            const unitDef = UNITS[cargo.type];
            const countText = unitDef.isTank ? `${cargo.count}ÎåÄ` : `${cargo.count.toLocaleString()}Î™Ö`;
            addLog(`‚ö†Ô∏èüö¢ Ï†Å ${unitDef.name} ${countText}Ïù¥(Í∞Ä) ÏïÑÍµ∞ ÏòÅÏó≠Ïóê ÏÉÅÎ•ôÌñàÏäµÎãàÎã§!`, 'enemy');
          }
          
          transport.cargo = [];
          transport.moved = true;
          renderMap();
          await delay(300);
        } else {
          // Î™©ÌëúÎ°ú Ïù¥Îèô
          const moveRange = UNITS.transport_ship.moveRange;
          let bestMove = null;
          let bestDist = Infinity;
          
          for (let dy = -moveRange; dy <= moveRange; dy++) {
            for (let dx = -moveRange; dx <= moveRange; dx++) {
              const dist = Math.abs(dx) + Math.abs(dy);
              if (dist === 0 || dist > moveRange) continue;
              
              const nx = transport.x + dx;
              const ny = transport.y + dy;
              
              if (nx < 0 || nx >= MAP_WIDTH || ny < 0 || ny >= MAP_HEIGHT) continue;
              if (gameState.map[ny][nx].terrain !== 'sea') continue;
              if (getUnitAt(nx, ny)) continue;
              
              const newDist = Math.abs(nx - targetSea.x) + Math.abs(ny - targetSea.y);
              if (newDist < bestDist) {
                bestDist = newDist;
                bestMove = { x: nx, y: ny };
              }
            }
          }
          
          if (bestMove) {
            transport.x = bestMove.x;
            transport.y = bestMove.y;
            transport.moved = true;
            addLog(`üö¢ Ï†Å ÏàòÏÜ°Ìï®Ïù¥ ÏÉÅÎ•ô ÏûëÏ†ÑÏùÑ ÏúÑÌï¥ Ïù¥Îèô Ï§ë...`, 'enemy');
            renderMap();
          }
        }
      }
    }
    
    // ==================== AI Í∞ïÌôî Ìï®ÏàòÎì§ ÎÅù ====================
    
    // === AI "ÌéòÏù¥Ïª§ Î™®Îìú" Ï¥àÍ∏∞ Íµ∞ÎåÄ Î∞∞Ïπò ===
    function initializeAiArmy() {
      // Ï†Å Î≥∏Í∏∞ÏßÄ ÏúÑÏπò Ï∞æÍ∏∞
      let enemyMainBase = null;
      let enemySubBase1 = null;
      let enemySubBase2 = null;
      let enemyHarbor = null;
      
      gameState.map.forEach((row, y) => {
        row.forEach((tile, x) => {
          if (tile.type === 'main_base' && tile.owner === 'enemy') {
            enemyMainBase = { x, y };
          }
          if (tile.type === 'sub_base' && tile.owner === 'enemy') {
            if (!enemySubBase1) enemySubBase1 = { x, y };
            else enemySubBase2 = { x, y };
          }
          if (tile.type === 'harbor' && tile.owner === 'enemy') {
            enemyHarbor = { x, y };
          }
        });
      });
      
      // === 1. Í±¥Î¨º Î∞∞Ïπò ===
      const buildingsToPlace = [
        { type: 'arms_factory', offset: { x: 2, y: 1 } },      // Íµ∞Ïàò Í≥µÏû•
        { type: 'arms_factory', offset: { x: -2, y: 1 } },     // Íµ∞Ïàò Í≥µÏû• 2
        { type: 'missile_silo', offset: { x: 3, y: 2 } },     // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ÎåÄ
        { type: 'missile_silo', offset: { x: -3, y: 2 } },    // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ÎåÄ 2
        { type: 'mortar', offset: { x: 1, y: 2 } },           // Î∞ïÍ≤©Ìè¨
        { type: 'mortar', offset: { x: 4, y: 1 } },           // Î∞ïÍ≤©Ìè¨ 2
        { type: 'runway', offset: { x: 2, y: 3 } },           // ÌôúÏ£ºÎ°ú
        { type: 'city', offset: { x: -1, y: 1 }, level: 3 },  // ÎèÑÏãú Lv.3
        { type: 'city', offset: { x: 5, y: 1 }, level: 3 },   // ÎèÑÏãú 2 Lv.3
        { type: 'city', offset: { x: -4, y: 2 }, level: 2 },  // ÎèÑÏãú 3 Lv.2
        { type: 'barracks', offset: { x: 1, y: -1 } },        // ÏßïÎ≥ëÏÜå
        { type: 'barracks', offset: { x: -1, y: -1 } },       // ÏßïÎ≥ëÏÜå 2
      ];
      
      if (enemyMainBase) {
        for (const bldg of buildingsToPlace) {
          const bx = enemyMainBase.x + bldg.offset.x;
          const by = enemyMainBase.y + bldg.offset.y;
          
          if (bx >= 0 && bx < MAP_WIDTH && by >= 0 && by < MAP_HEIGHT) {
            const tile = gameState.map[by][bx];
            if (tile.terrain === 'land' && tile.type === 'empty' && !getBuildingAt(bx, by)) {
              gameState.buildings.push({
                type: bldg.type,
                x: bx,
                y: by,
                owner: 'enemy',
                hp: BUILDINGS[bldg.type].hp,
                level: bldg.level || (bldg.type === 'missile_silo' || bldg.type === 'mortar' ? 2 : 1),
                fired: false,
                produced: false
              });
            }
          }
        }
      }
      
      // === 2. ÎåÄÍ∑úÎ™® Î≥ëÎ†• Î∞∞Ïπò (ÌÉ±ÌÅ¨ Ìè¨Ìï®!) ===
      const unitsToPlace = [
        // Î≥∏Í∏∞ÏßÄ Ï£ºÎ≥Ä ÎåÄÍµ∞
        { type: 'soldier', count: 10000, base: 'main', offset: { x: 0, y: 2 } },
        { type: 'soldier', count: 8000, base: 'main', offset: { x: 1, y: 3 } },
        { type: 'soldier', count: 8000, base: 'main', offset: { x: -1, y: 3 } },
        { type: 'commando', count: 3000, base: 'main', offset: { x: 2, y: 4 } },
        { type: 'commando', count: 3000, base: 'main', offset: { x: -2, y: 4 } },
        
        // ÌÉ±ÌÅ¨ Î∂ÄÎåÄ!
        { type: 'tank_advanced', count: 10, base: 'main', offset: { x: 3, y: 3 } },
        { type: 'tank_medium', count: 15, base: 'main', offset: { x: -3, y: 3 } },
        { type: 'tank_basic', count: 20, base: 'sub1', offset: { x: 2, y: 1 } },
        
        // ÎåÄÏ†ÑÏ∞® Î°úÏºìÎ≥ë
        { type: 'anti_tank', count: 500, base: 'main', offset: { x: 4, y: 2 } },
        { type: 'anti_tank', count: 500, base: 'main', offset: { x: -4, y: 2 } },
        
        // Î∂ÄÍ∏∞ÏßÄ Î≥ëÎ†•
        { type: 'soldier', count: 5000, base: 'sub1', offset: { x: 0, y: 1 } },
        { type: 'soldier', count: 5000, base: 'sub2', offset: { x: 0, y: 1 } },
        
        // Í±¥Ï∂ïÍ∞Ä
        { type: 'engineer', count: 1, base: 'main', offset: { x: 3, y: 0 } },
        { type: 'engineer', count: 1, base: 'main', offset: { x: -3, y: 0 } },
        { type: 'military_engineer', count: 1, base: 'main', offset: { x: 5, y: 0 } },
        { type: 'military_engineer', count: 1, base: 'sub1', offset: { x: 1, y: 0 } },
      ];
      
      for (const unitData of unitsToPlace) {
        let basePos = null;
        if (unitData.base === 'main') basePos = enemyMainBase;
        else if (unitData.base === 'sub1') basePos = enemySubBase1;
        else if (unitData.base === 'sub2') basePos = enemySubBase2;
        
        if (!basePos) continue;
        
        const ux = basePos.x + unitData.offset.x;
        const uy = basePos.y + unitData.offset.y;
        
        if (ux >= 0 && ux < MAP_WIDTH && uy >= 0 && uy < MAP_HEIGHT) {
          const tile = gameState.map[uy][ux];
          if (tile.terrain === 'land' && !getGroundUnitAt(ux, uy)) {
            gameState.units.push({
              id: Date.now() + Math.random(),
              type: unitData.type,
              x: ux,
              y: uy,
              owner: 'enemy',
              count: unitData.count,
              moved: false
            });
          }
        }
      }
      
      // === 3. Ìï¥Íµ∞ Î∞∞Ïπò (Ìï≠Íµ¨ Í∑ºÏ≤ò) ===
      if (enemyHarbor) {
        const navalUnits = [
          { type: 'transport_ship', cargo: [
            { type: 'soldier', count: 5000 },
            { type: 'commando', count: 2000 }
          ]},
          { type: 'transport_ship', cargo: [
            { type: 'soldier', count: 5000 },
            { type: 'soldier', count: 3000 }
          ]},
          { type: 'attack_ship', cargo: [] },
          { type: 'missile_cruiser', cargo: [] },
        ];
        
        let seaIdx = 0;
        for (let dy = -2; dy <= 2; dy++) {
          for (let dx = -2; dx <= 2; dx++) {
            if (seaIdx >= navalUnits.length) break;
            
            const nx = enemyHarbor.x + dx;
            const ny = enemyHarbor.y + dy;
            
            if (nx >= 0 && nx < MAP_WIDTH && ny >= 0 && ny < MAP_HEIGHT) {
              const tile = gameState.map[ny][nx];
              if (tile.terrain === 'sea' && !getUnitAt(nx, ny)) {
                const naval = navalUnits[seaIdx];
                gameState.units.push({
                  id: Date.now() + Math.random() + seaIdx,
                  type: naval.type,
                  x: nx,
                  y: ny,
                  owner: 'enemy',
                  count: 1,
                  hp: UNITS[naval.type].hp,
                  moved: false,
                  cargo: naval.cargo || []
                });
                seaIdx++;
              }
            }
          }
          if (seaIdx >= navalUnits.length) break;
        }
      }
      
      // === 4. Ï†ïÏ∞∞Í∏∞/Ìè≠Í≤©Í∏∞ Î∞∞Ïπò (ÌôúÏ£ºÎ°ú Í∑ºÏ≤ò) ===
      const runway = gameState.buildings.find(b => b.owner === 'enemy' && b.type === 'runway');
      if (runway) {
        // Ï†ïÏ∞∞Í∏∞
        gameState.units.push({
          id: Date.now() + Math.random(),
          type: 'recon_plane',
          x: runway.x,
          y: runway.y - 1 >= 0 ? runway.y - 1 : runway.y + 1,
          owner: 'enemy',
          count: 1,
          hp: UNITS.recon_plane.hp,
          moved: false
        });
        
        // Ìè≠Í≤©Í∏∞
        gameState.units.push({
          id: Date.now() + Math.random(),
          type: 'bomber',
          x: runway.x + 1 < MAP_WIDTH ? runway.x + 1 : runway.x - 1,
          y: runway.y,
          owner: 'enemy',
          count: 1,
          hp: UNITS.bomber.hp,
          moved: false
        });
      }
      
      addLog('‚ö†Ô∏è Í≤ΩÍ≥†: Ï†ÅÏù¥ ÎåÄÍ∑úÎ™® Íµ∞ÎåÄÎ•º Ìé∏ÏÑ±ÌñàÏäµÎãàÎã§!', 'enemy');
      addLog('üöÄ Ï†Å ÎØ∏ÏÇ¨Ïùº 5Î∞ú Í∞êÏßÄ!', 'enemy');
    }
    
    // ÏÑ¨ ÏúÑÏπò ÌåêÎ≥Ñ
    function getIslandAt(x, y) {
      if (x >= ISLAND.ENEMY_LEFT.x1 && x <= ISLAND.ENEMY_LEFT.x2 &&
          y >= ISLAND.ENEMY_LEFT.y1 && y <= ISLAND.ENEMY_LEFT.y2) {
        return 'enemy_left';
      }
      if (x >= ISLAND.ENEMY_RIGHT.x1 && x <= ISLAND.ENEMY_RIGHT.x2 &&
          y >= ISLAND.ENEMY_RIGHT.y1 && y <= ISLAND.ENEMY_RIGHT.y2) {
        return 'enemy_right';
      }
      if (x >= ISLAND.PLAYER_LEFT.x1 && x <= ISLAND.PLAYER_LEFT.x2 &&
          y >= ISLAND.PLAYER_LEFT.y1 && y <= ISLAND.PLAYER_LEFT.y2) {
        return 'player_left';
      }
      if (x >= ISLAND.PLAYER_RIGHT.x1 && x <= ISLAND.PLAYER_RIGHT.x2 &&
          y >= ISLAND.PLAYER_RIGHT.y1 && y <= ISLAND.PLAYER_RIGHT.y2) {
        return 'player_right';
      }
      return 'sea';
    }
    
    
    // ==================== ÌÑ¥ ÏãúÏä§ÌÖú ====================

    // ÌÑ¥ Ï¢ÖÎ£å
    function endTurn() {
      if (!gameState.isPlayerTurn) return;
      
      // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®ÎìúÏùº Îïå
      if (isMultiplayer) {
        endMultiplayerTurn();
        return;
      }
      
      // AI ÎåÄÏ†Ñ Î™®Îìú (Í∏∞Ï°¥ Î°úÏßÅ)
      gameState.isPlayerTurn = false;
      updateTurnDisplay();
      renderMap();
      addLog('ÌÑ¥ÏùÑ Ï¢ÖÎ£åÌï©ÎãàÎã§.', 'system');
      
      // Ï†Å ÌÑ¥ Ïã§Ìñâ
      setTimeout(async () => {
        await executeEnemyTurn();
        
        // ÌîåÎ†àÏù¥Ïñ¥ ÌÑ¥ ÏãúÏûë
        setTimeout(() => {
          // ÌîåÎ†àÏù¥Ïñ¥ ÏûêÏõê ÏàòÏûÖ
          gameState.resources.player += TURN_INCOME;
          
          let buildingIncome = 0;
          gameState.buildings.forEach(building => {
            if (building.owner === 'player') {
              buildingIncome += getBuildingIncome(building);
            }
          });
          
          gameState.resources.player += buildingIncome;
          
          if (buildingIncome > 0) {
            addLog(`ÌÑ¥ ÏàòÏûÖ: +${TURN_INCOME} (Í∏∞Î≥∏) +${buildingIncome} (Í±¥Î¨º) = +${TURN_INCOME + buildingIncome} ÏûêÏõê`, 'system');
          } else {
            addLog(`ÌÑ¥ ÏàòÏûÖ: +${TURN_INCOME} ÏûêÏõê`, 'system');
          }
          
          // ÌîåÎ†àÏù¥Ïñ¥ Ïú†Îãõ/Í±¥Î¨º ÏÉÅÌÉú Î¶¨ÏÖã
          gameState.units.forEach(unit => {
            if (unit.owner === 'player') {
              unit.moved = false;
            }
          });
          
          gameState.buildings.forEach(building => {
            if (building.owner === 'player') {
              if (building.fired !== undefined) building.fired = false;
              if (building.produced !== undefined) building.produced = false;
            }
          });
          
          // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ ÏßÑÌñâ
          processMissileProduction('player');
          
          gameState.isPlayerTurn = true;
          gameState.turnNumber++;
          updateResourceDisplay();
          startTurnTimer();
          renderMap();
          addLog('ÎãπÏã†Ïùò ÌÑ¥ÏûÖÎãàÎã§!', 'system');
        }, 300);
      }, 500);
    }
    
    // Îß§Ïπ≠ ÏãúÏûë
    function startMatching() {
      showScreen('matching');
      gameState.matchingTime = 0;
      
      const dotsEl = document.getElementById('matching-dots');
      const timeEl = document.getElementById('matching-time');
      const matchingContent = document.getElementById('matching-content');
      const matchFound = document.getElementById('match-found');
      
      matchingContent.style.display = 'block';
      matchFound.classList.remove('active');
      
      let dots = 0;
      const dotsInterval = setInterval(() => {
        dots = (dots + 1) % 4;
        dotsEl.textContent = '.'.repeat(dots);
      }, 500);
      
      gameState.matchingInterval = setInterval(() => {
        gameState.matchingTime++;
        const mins = Math.floor(gameState.matchingTime / 60).toString().padStart(2, '0');
        const secs = (gameState.matchingTime % 60).toString().padStart(2, '0');
        timeEl.textContent = `${mins}:${secs}`;
      }, 1000);
      
      // Îß§Ïπ≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò (3-8Ï¥à ÌõÑ Îß§Ïπ≠)
      const matchDelay = 3000 + Math.random() * 5000;
      setTimeout(() => {
        clearInterval(dotsInterval);
        clearInterval(gameState.matchingInterval);
        
        matchingContent.style.display = 'none';
        matchFound.classList.add('active');
        
        // ÏÉÅÎåÄ ÏÉùÏÑ±
        gameState.opponent = {
          name: `Commander_${Math.floor(Math.random() * 1000)}`,
          wins: gameState.player.wins + Math.floor(Math.random() * 3) - 1,
          losses: gameState.player.losses + Math.floor(Math.random() * 3) - 1
        };
        
        setTimeout(startGame, 2000);
      }, matchDelay);
    }
    
    // Îß§Ïπ≠ Ï∑®ÏÜå
    function cancelMatching() {
      if (gameState.matchingInterval) {
        clearInterval(gameState.matchingInterval);
      }
      showScreen('lobby');
    }
    
    // Í≤åÏûÑ ÏãúÏûë
    function startGame() {
      showScreen('game');
      
      gameState.map = createMap();
      gameState.turnNumber = 1;
      gameState.isPlayerTurn = true; // AI ÏÉÅÎåÄÎäî Ìï≠ÏÉÅ ÌîåÎ†àÏù¥Ïñ¥ ÏÑ†Í≥µ
      currentMapView = 'ground'; // ÏßÄÏÉÅÎßµÏúºÎ°ú ÏãúÏûë
      
      // AI ÏÑ§Ï†ï Í∞ÄÏ†∏Ïò§Í∏∞
      const aiConfig = AI_CONFIG[aiState.type];
      
      // ÏûêÏõê, Ïú†Îãõ, Í±¥Î¨º, Í∏∞ÏßÄ ÎÇ¥Íµ¨ÎèÑ Ï¥àÍ∏∞Ìôî
      gameState.resources.player = 1000;
      gameState.resources.enemy = aiConfig.initialResources || 100000;  // AI ÌÉÄÏûÖÎ≥Ñ Ï¥àÍ∏∞ ÏûêÏõê
      gameState.units = [];
      gameState.buildings = [];
      gameState.landmines = [];  // ÏßÄÎ¢∞ Ï¥àÍ∏∞Ìôî
      gameState.capturedTiles = { player: [], enemy: [] };  // Ï†êÎ†π ÌÉÄÏùº Ï¥àÍ∏∞Ìôî
      gameState.bases = {
        player: { main: BASE_HP.main_base, sub1: BASE_HP.sub_base, sub2: BASE_HP.sub_base },
        enemy: { main: BASE_HP.main_base, sub1: BASE_HP.sub_base, sub2: BASE_HP.sub_base }
      };
      
      // ÎØ∏ÏÇ¨Ïùº Ïû¨Í≥† Ï¥àÍ∏∞Ìôî
      gameState.missiles.player = 0;
      gameState.missiles.enemy = aiConfig.initialMissiles || 0;  // ÌïòÎìúÎ™®ÎìúÎßå 5Î∞ú
      gameState.missileQueue.player = [];
      gameState.missileQueue.enemy = [];
      
      // ÌïòÎìú Î™®ÎìúÏùº ÎïåÎßå Ï¥àÍ∏∞ Íµ∞ÎåÄ Î∞∞Ïπò
      if (aiConfig.isHardMode) {
        initializeAiArmy();
        addLog('‚ö†Ô∏è ÌïòÎìú Î™®Îìú: Ï†ÅÏù¥ ÎåÄÍ∑úÎ™® Íµ∞ÎåÄÎ•º Ìé∏ÏÑ±ÌñàÏäµÎãàÎã§!', 'enemy');
      }
      
      document.getElementById('game-player-name').textContent = gameState.player.name;
      document.getElementById('game-enemy-name').textContent = gameState.opponent.name;
      
      // ÌÉ≠ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
      document.querySelectorAll('.map-view-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.view === 'ground');
      });
      
      document.getElementById('log-container').innerHTML = '';
      addLog('Ï†ÑÌà¨Í∞Ä ÏãúÏûëÎêòÏóàÏäµÎãàÎã§!', 'system');
      addLog(`Îßµ ÌÅ¨Í∏∞: ${MAP_WIDTH}x${MAP_HEIGHT} (4Í∞ú ÏÑ¨ + Ïã≠ÏûêÍ∞Ä Î∞îÎã§)`, 'system');
      addLog(`Ï¥àÍ∏∞ ÏûêÏõê: ${gameState.resources.player}`, 'system');
      addLog('ÎãπÏã†Ïùò ÏÑ†Í≥µÏûÖÎãàÎã§.', 'system');
      addLog('üí° Ï¢åÏ∏° Îπ†Î•∏ Ïù¥Îèô Î≤ÑÌäºÏúºÎ°ú Í∞Å ÏÑ¨ÏúºÎ°ú Ïù¥ÎèôÌïòÏÑ∏Ïöî.', 'system');
      
      renderMap();
      
      // Ï¥àÍ∏∞ Îßµ ÏúÑÏπòÎ•º ÏïÑÍµ∞ Î≥∏Í∏∞ÏßÄÎ°ú Ïù¥Îèô
      setTimeout(() => {
        goToArea('player-main');
      }, 100);
      
      startTurnTimer();
    }
    
    // Ìï≠Î≥µ
    function surrender() {
      // Ìï≠Î≥µ ÌôïÏù∏ Î™®Îã¨ ÌëúÏãú
      document.getElementById('surrender-modal').classList.add('active');
      document.getElementById('action-overlay').classList.add('active');
    }
    
    // Ìï≠Î≥µ Î™®Îã¨ Îã´Í∏∞
    function hideSurrenderModal() {
      document.getElementById('surrender-modal').classList.remove('active');
      document.getElementById('action-overlay').classList.remove('active');
    }
    
    // Ìï≠Î≥µ ÌôïÏ†ï
    function confirmSurrender() {
      hideSurrenderModal();
      
      if (gameState.turnInterval) clearInterval(gameState.turnInterval);
      
      gameState.player.losses++;
      addLog(`${gameState.player.name}Ïù¥(Í∞Ä) Ìï≠Î≥µÌñàÏäµÎãàÎã§.`, 'system');
      addLog(`${gameState.opponent.name}Ïùò ÏäπÎ¶¨!`, 'enemy');
      
      // Í≤∞Í≥º ÌëúÏãú ÌõÑ Î°úÎπÑÎ°ú
      setTimeout(() => {
        alert(`${gameState.opponent.name}Ïùò ÏäπÎ¶¨!\n\nÎãπÏã†Ïùò Ï†ÑÏ†Å: ${gameState.player.wins}Ïäπ ${gameState.player.losses}Ìå®`);
        updateLobbyStats();
        showScreen('lobby');
      }, 300);
    }
    
    // Î°úÎπÑ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
    function updateLobbyStats() {
      document.getElementById('lobby-player-name').textContent = gameState.player.name;
      document.getElementById('lobby-wins').textContent = gameState.player.wins;
      document.getElementById('lobby-losses').textContent = gameState.player.losses;
      document.getElementById('currency-gold').textContent = gameState.currency.gold.toLocaleString();
      document.getElementById('currency-gems').textContent = gameState.currency.gems;
      
      // Ïú†Îãõ Î™©Î°ù Î†åÎçîÎßÅ
      renderLobbyUnits();
    }
    
    // Î°úÎπÑ Ïú†Îãõ Î™©Î°ù Î†åÎçîÎßÅ
    function renderLobbyUnits() {
      const unitList = document.getElementById('lobby-unit-list');
      unitList.innerHTML = '';
      
      Object.values(UNITS).forEach(unit => {
        const card = document.createElement('div');
        card.className = 'unit-card-large';
        
        let badgeText = '';
        if (unit.isDefault) {
          badgeText = '<div class="default-badge">Í∏∞Î≥∏</div>';
        } else if (unit.isAirUnit) {
          badgeText = '<div class="default-badge" style="background: rgba(100,100,150,0.8);">ÌôúÏ£ºÎ°ú</div>';
        }
        
        card.innerHTML = `
          ${badgeText}
          <div class="unit-icon">${unit.icon}</div>
          <div class="unit-name">${unit.name}</div>
          <div class="unit-desc">${unit.description}</div>
          <div class="unit-stats">
            <div class="stat">
              <span class="stat-icon">‚öîÔ∏è</span>
              <span>${unit.attack}</span>
            </div>
            <div class="stat">
              <span class="stat-icon">üõ°Ô∏è</span>
              <span>${unit.defense}</span>
            </div>
            <div class="stat">
              <span class="stat-icon">‚ù§Ô∏è</span>
              <span>${unit.hp}</span>
            </div>
          </div>
          <div class="unit-cost">${unit.isAirUnit ? 'ÏÉùÏÇ∞' : 'ÏßïÎ≥ë'} ÎπÑÏö©: üí∞ ${unit.cost.toLocaleString()}</div>
        `;
        unitList.appendChild(card);
      });
    }
    
    // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà ÏÑ§Ï†ï
    function setupEventListeners() {
      // Î°úÍ∑∏Ïù∏
      const nameInput = document.getElementById('player-name');
      const loginBtn = document.getElementById('login-btn');
      
      nameInput.addEventListener('input', () => {
        loginBtn.disabled = !nameInput.value.trim();
      });
      
      loginBtn.addEventListener('click', () => {
        const name = nameInput.value.trim();
        if (name) {
          gameState.player = {
            name,
            wins: Math.floor(Math.random() * 10),
            losses: Math.floor(Math.random() * 10)
          };
          updateLobbyStats();
          showScreen('lobby');
        }
      });
      
      nameInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !loginBtn.disabled) {
          loginBtn.click();
        }
      });
      
      // Î°úÎπÑ ÌÉ≠ ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò
      document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchTab(btn.dataset.tab);
        });
      });
      
      // PVP Î≤ÑÌäº ‚Üí Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®Îã¨ Ïó¥Í∏∞
      document.getElementById('pvp-btn').addEventListener('click', () => {
        initSocket();  // Socket.io Ïó∞Í≤∞
        document.getElementById('pvp-modal').style.display = 'block';
      });
      
      // AI Î≤ÑÌäº
      document.getElementById('ai-btn').addEventListener('click', () => {
        isMultiplayer = false;
        document.getElementById('ai-select-modal').style.display = 'block';
      });
      
      // Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥ Î™®Îã¨ Îã´Í∏∞
      document.getElementById('close-pvp-modal').addEventListener('click', () => {
        document.getElementById('pvp-modal').style.display = 'none';
        if (socket) socket.emit('cancel_match');
        // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
        document.getElementById('matching-status').style.display = 'none';
        document.getElementById('cancel-match-btn').style.display = 'none';
        document.getElementById('quick-match-option').style.display = 'flex';
        document.getElementById('room-code-display').style.display = 'none';
        document.getElementById('create-room-option').style.display = 'flex';
        document.getElementById('pvp-error').style.display = 'none';
      });
      
      // Îπ†Î•∏ Îß§Ïπ≠
      document.getElementById('quick-match-option').addEventListener('click', () => {
        socket.emit('quick_match');
        document.getElementById('quick-match-option').style.display = 'none';
        document.getElementById('matching-status').style.display = 'block';
        document.getElementById('matching-status').textContent = 'üîç ÏÉÅÎåÄÎ•º Ï∞æÎäî Ï§ë...';
        document.getElementById('cancel-match-btn').style.display = 'flex';
      });
      
      // Îß§Ïπ≠ Ï∑®ÏÜå (Î©ÄÌã∞ÌîåÎ†àÏù¥Ïñ¥)
      document.getElementById('cancel-match-btn').addEventListener('click', () => {
        socket.emit('cancel_match');
        document.getElementById('quick-match-option').style.display = 'flex';
        document.getElementById('matching-status').style.display = 'none';
        document.getElementById('cancel-match-btn').style.display = 'none';
      });
      
      // Î∞© ÎßåÎì§Í∏∞
      document.getElementById('create-room-option').addEventListener('click', () => {
        socket.emit('create_room');
      });
      
      // Î∞© Ï∞∏Í∞Ä
      document.getElementById('join-room-option').addEventListener('click', () => {
        const code = document.getElementById('join-code-input').value.trim();
        if (code.length === 4) {
          socket.emit('join_room', code);
          document.getElementById('pvp-error').style.display = 'none';
        } else {
          document.getElementById('pvp-error').style.display = 'block';
          document.getElementById('pvp-error').textContent = '4ÏûêÎ¶¨ ÏΩîÎìúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.';
        }
      });
      
      // Ï§ÄÎπÑ ÏôÑÎ£å
      document.getElementById('ready-btn').addEventListener('click', () => {
        console.log('üì¢ Ï§ÄÎπÑ Î≤ÑÌäº ÌÅ¥Î¶≠!');
        console.log('üì¢ socket ÏÉÅÌÉú:', socket ? 'OK' : 'NULL');
        console.log('üì¢ socket.connected:', socket?.connected);
        
        if (!socket || !socket.connected) {
          alert('ÏÑúÎ≤Ñ Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§. ÏÉàÎ°úÍ≥†Ïπ® Ìï¥Ï£ºÏÑ∏Ïöî.');
          return;
        }
        
        socket.emit('player_ready');
        console.log('üì¢ player_ready Ïù¥Î≤§Ìä∏ Ï†ÑÏÜ°Îê®');
        
        document.getElementById('ready-btn').style.opacity = '0.5';
        document.getElementById('ready-btn').style.pointerEvents = 'none';
        document.getElementById('ready-status').textContent = '‚úÖ Ï§ÄÎπÑ ÏôÑÎ£å! ÏÉÅÎåÄÎ∞© ÎåÄÍ∏∞ Ï§ë...';
      });
      
      // Ï±ÑÌåÖ Ï†ÑÏÜ°
      document.getElementById('mp-chat-send').addEventListener('click', () => {
        const input = document.getElementById('mp-chat-input');
        const msg = input.value.trim();
        if (msg && socket) {
          socket.emit('chat_message', msg);
          input.value = '';
        }
      });
      
      document.getElementById('mp-chat-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          document.getElementById('mp-chat-send').click();
        }
      });
      
      // Ï±ÑÌåÖ ÌÜ†Í∏Ä
      document.getElementById('toggle-chat-btn').addEventListener('click', () => {
        const messages = document.getElementById('mp-chat-messages');
        const inputArea = document.getElementById('mp-chat-input-area');
        if (messages.style.display === 'none') {
          messages.style.display = 'block';
          inputArea.style.display = 'flex';
        } else {
          messages.style.display = 'none';
          inputArea.style.display = 'none';
        }
      });
      
      // Ìï≠Î≥µ Î≤ÑÌäº
      document.getElementById('surrender-btn').addEventListener('click', () => {
        if (confirm('Ï†ïÎßê Ìï≠Î≥µÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
          if (isMultiplayer && socket) {
            socket.emit('surrender');
          }
          alert('Ìï≠Î≥µÌñàÏäµÎãàÎã§.');
          isMultiplayer = false;
          showScreen('lobby');
        }
      });
      
      // AI ÌÉÄÏûÖ ÏÑ†ÌÉù Î™®Îã¨
      document.getElementById('close-ai-modal').addEventListener('click', () => {
        document.getElementById('ai-select-modal').style.display = 'none';
      });
      
      document.querySelectorAll('[data-ai-type]').forEach(btn => {
        btn.addEventListener('click', () => {
          const aiType = btn.dataset.aiType;
          setAiType(aiType);
          document.getElementById('ai-select-modal').style.display = 'none';
          isMultiplayer = false;
          startGame();
        });
      });
      
      // Í≤åÏûÑ
      document.getElementById('end-turn-btn').addEventListener('click', endTurn);
      
      // Ïï°ÏÖò Î©îÎâ¥
      document.getElementById('close-action-menu').addEventListener('click', () => hideActionMenu(true));
      document.getElementById('action-overlay').addEventListener('click', () => {
        hideActionMenu(true);
        hideBuildModal();
        hideRecruitModal();
        hideDeployModal();
        hideSurrenderModal();
        hideAttackModal();
        hideShipModal();
        hideAircraftModal();
        hideTransportModal();
        hideLandModal();
        hideMissileProduceModal();
        hideMissileLaunchModal();
        hideEngineerBuildModal();
      });
      
      document.querySelectorAll('.action-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          handleAction(btn.dataset.action);
        });
      });
      
      // Í±¥Ï∂ï Î™®Îã¨
      document.getElementById('close-build-modal').addEventListener('click', hideBuildModal);
      document.getElementById('build-barracks').addEventListener('click', () => {
        if (!document.getElementById('build-barracks').classList.contains('disabled')) {
          buildStructure('barracks');
        }
      });
      
      // Ï†ÑÎ¨∏ Í±¥Ï∂ï Î™®Îã¨ (Í±¥Ï∂ïÍ∞Ä Ï†ÑÏö©)
      document.getElementById('close-engineer-build-modal').addEventListener('click', hideEngineerBuildModal);
      document.getElementById('build-city').addEventListener('click', () => {
        if (!document.getElementById('build-city').classList.contains('disabled')) {
          buildEngineerStructure('city');
        }
      });
      
      // ÏßïÎ≥ë Î™®Îã¨
      document.getElementById('close-recruit-modal').addEventListener('click', hideRecruitModal);
      document.getElementById('recruit-minus').addEventListener('click', () => changeRecruitQuantity(-1));
      document.getElementById('recruit-plus').addEventListener('click', () => changeRecruitQuantity(1));
      document.getElementById('recruit-max').addEventListener('click', maxRecruit);
      document.getElementById('confirm-recruit').addEventListener('click', confirmRecruit);
      
      // ÏßïÎ≥ë Ïú†Îãõ ÌÉÄÏûÖ ÏÑ†ÌÉù
      document.querySelectorAll('#recruit-type-select .build-option').forEach(opt => {
        opt.addEventListener('click', () => {
          if (!opt.classList.contains('disabled')) {
            selectRecruitUnit(opt.dataset.unit);
          }
        });
      });
      
      // ÏßïÎ≥ë Îí§Î°ú Î≤ÑÌäº
      document.getElementById('recruit-back').addEventListener('click', () => {
        recruitState.step = 'select';
        document.getElementById('recruit-type-select').style.display = 'block';
        document.getElementById('recruit-control').style.display = 'none';
      });
      
      // ÌñâÍµ∞/Ï£ºÎëî Î™®Îã¨
      document.getElementById('close-deploy-modal').addEventListener('click', hideDeployModal);
      
      // Ìï≠Î≥µ Î™®Îã¨
      document.getElementById('close-surrender-modal').addEventListener('click', hideSurrenderModal);
      document.getElementById('cancel-surrender').addEventListener('click', hideSurrenderModal);
      document.getElementById('confirm-surrender').addEventListener('click', confirmSurrender);
      
      // Í≥µÍ≤© Î™®Îã¨
      document.getElementById('close-attack-modal').addEventListener('click', hideAttackModal);
      
      // Î∞ïÍ≤©Ìè¨ Î∞úÏÇ¨ Î™®Îã¨
      document.getElementById('close-mortar-modal').addEventListener('click', hideMortarFireModal);
      
      // Íµ∞ÏÇ¨ Í±¥ÏÑ§ Î™®Îã¨
      document.getElementById('close-military-build-modal').addEventListener('click', hideMilitaryBuildModal);
      document.getElementById('build-mortar-option').addEventListener('click', () => {
        if (!document.getElementById('build-mortar-option').classList.contains('disabled')) {
          confirmMilitaryBuild('mortar');
        }
      });
      document.getElementById('build-runway-option').addEventListener('click', () => {
        if (!document.getElementById('build-runway-option').classList.contains('disabled')) {
          confirmMilitaryBuild('runway');
        }
      });
      document.getElementById('build-arms-factory-option').addEventListener('click', () => {
        if (!document.getElementById('build-arms-factory-option').classList.contains('disabled')) {
          confirmMilitaryBuild('arms_factory');
        }
      });
      document.getElementById('build-missile-silo-option').addEventListener('click', () => {
        if (!document.getElementById('build-missile-silo-option').classList.contains('disabled')) {
          confirmMilitaryBuild('missile_silo');
        }
      });
      
      // ÎØ∏ÏÇ¨Ïùº ÏÉùÏÇ∞ Î™®Îã¨
      document.getElementById('close-missile-produce-modal').addEventListener('click', hideMissileProduceModal);
      document.getElementById('produce-missile-option').addEventListener('click', () => {
        if (!document.getElementById('produce-missile-option').classList.contains('disabled')) {
          confirmMissileProduce();
        }
      });
      
      // ÌÉ±ÌÅ¨ ÏÉùÏÇ∞ Î™®Îã¨
      document.getElementById('close-tank-produce-modal').addEventListener('click', hideTankProduceModal);
      document.querySelectorAll('.tank-option').forEach(opt => {
        opt.addEventListener('click', () => {
          selectTankType(opt.dataset.tankType);
        });
      });
      document.getElementById('tank-qty-decrease').addEventListener('click', () => adjustTankQuantity(-1));
      document.getElementById('tank-qty-increase').addEventListener('click', () => adjustTankQuantity(1));
      document.getElementById('tank-qty-max').addEventListener('click', setMaxTankQuantity);
      document.getElementById('tank-quantity').addEventListener('input', updateTankTotalCost);
      document.getElementById('confirm-tank-produce').addEventListener('click', confirmTankProduce);
      
      // ÏßÄÎ¢∞ ÏÑ§Ïπò Î™®Îã¨
      document.getElementById('close-mine-modal').addEventListener('click', hideMinePlaceModal);
      document.getElementById('mine-qty-decrease').addEventListener('click', () => adjustMineQuantity(-1));
      document.getElementById('mine-qty-increase').addEventListener('click', () => adjustMineQuantity(1));
      document.getElementById('mine-qty-max').addEventListener('click', setMaxMineQuantity);
      document.getElementById('mine-quantity').addEventListener('input', updateMineTotalCost);
      document.getElementById('confirm-mine-place').addEventListener('click', confirmMinePlacement);
      
      // ÎØ∏ÏÇ¨Ïùº Î∞úÏÇ¨ Î™®Îã¨
      document.getElementById('close-missile-launch-modal').addEventListener('click', hideMissileLaunchModal);
      
      // ÎπÑÌñâÍ∏∞ ÏÉùÏÇ∞ Î™®Îã¨
      document.getElementById('close-aircraft-modal').addEventListener('click', hideAircraftModal);
      document.getElementById('build-recon-plane').addEventListener('click', () => {
        if (!document.getElementById('build-recon-plane').classList.contains('disabled')) {
          confirmProduceAircraft('recon_plane');
        }
      });
      
      // Ìï®ÏÑ† ÏÉùÏÇ∞ Î™®Îã¨
      document.getElementById('close-ship-modal').addEventListener('click', hideShipModal);
      document.getElementById('build-attack-ship').addEventListener('click', () => {
        if (!document.getElementById('build-attack-ship').classList.contains('disabled')) {
          produceShip('attack_ship');
        }
      });
      document.getElementById('build-missile-cruiser').addEventListener('click', () => {
        if (!document.getElementById('build-missile-cruiser').classList.contains('disabled')) {
          produceShip('missile_cruiser');
        }
      });
      document.getElementById('build-transport-ship').addEventListener('click', () => {
        if (!document.getElementById('build-transport-ship').classList.contains('disabled')) {
          produceShip('transport_ship');
        }
      });
      
      // Ìè≠Í≤©Í∏∞ ÏÉùÏÇ∞
      document.getElementById('build-bomber').addEventListener('click', () => {
        if (!document.getElementById('build-bomber').classList.contains('disabled')) {
          confirmProduceAircraft('bomber');
        }
      });
      
      // ÏàòÏÜ° Î™®Îã¨
      document.getElementById('close-transport-modal').addEventListener('click', hideTransportModal);
      document.getElementById('confirm-transport-btn').addEventListener('click', confirmTransport);
      
      // ÏÉÅÎ•ô Î™®Îã¨
      document.getElementById('close-land-modal').addEventListener('click', hideLandModal);
    }
    
    // Ï¥àÍ∏∞Ìôî
    setupEventListeners();
  </script>
</body>
</html>
